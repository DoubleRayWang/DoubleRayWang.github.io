<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Love Light</title>
  
  <subtitle>我的世界不只有 Coding！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://doubleray.top/"/>
  <updated>2021-06-24T04:02:41.975Z</updated>
  <id>https://doubleray.top/</id>
  
  <author>
    <name>DoubleRay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安装 node-sass 报错的解决记录</title>
    <link href="https://doubleray.top/2020/06/18/article-node-sass-error/"/>
    <id>https://doubleray.top/2020/06/18/article-node-sass-error/</id>
    <published>2020-06-18T15:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>yarn 或 npm install 命令的时候，总是在安装node-sass这一步卡住。终其原因还是「墙」的问题。<a id="more"></a></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>npm和yarn的解决方法一样，这里以yarn为示例。</p><p>查看 yarn 配置 yarn config list</p><p>将 yarn 源切换至淘宝源</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>执行 <code>yarn install</code> 或者 <code>yarn</code></p><ol><li>如果遇到错误 <em>error An unexpected error occurred: “EINVAL: invalid argument, symlink</em></li></ol><p>请在你的执行命令之后添加 <code>--no-bin-links</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install –no-bin-links</span><br></pre></td></tr></table></figure><ol start="2"><li>如果遇到错误 _error: xxxx node-sass: Command failed_，将 sass-binary-site 添加至 config 中，指定 node-sass 从 npm 的淘宝源中下载。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set sass-binary-site https://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;yarn 或 npm install 命令的时候，总是在安装node-sass这一步卡住。终其原因还是「墙」的问题。
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="Node" scheme="https://doubleray.top/tags/Node/"/>
    
      <category term="yarn" scheme="https://doubleray.top/tags/yarn/"/>
    
      <category term="npm" scheme="https://doubleray.top/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>node多版本管理（Windows）</title>
    <link href="https://doubleray.top/2020/04/13/other-node-nvm-windows/"/>
    <id>https://doubleray.top/2020/04/13/other-node-nvm-windows/</id>
    <published>2020-04-13T02:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.990Z</updated>
    
    <content type="html"><![CDATA[<p>旧的项目依赖低版本的node，但是现在的node版本变化太快，所以使用 nvm-windows 来管理不同版本的node。<a id="more"></a></p><p>软件地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="卸载现有的node和npm"><a href="#卸载现有的node和npm" class="headerlink" title="卸载现有的node和npm"></a>卸载现有的node和npm</h3><p>请注意，在安装NVM for Windows之前，您需要卸载任何现有版本的node.js. 还删除可能保留的任何现有nodejs安装目录（例如，C\Program Files\nodejs）。NVM生成的符号链接不会覆盖现有（甚至是空的）安装目录。</p><p>还应该删除现有的npm安装位置（例如C\Users&lt;user&gt;\AppData\Roaming\npm），以便正确使用nvm安装位置。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在releases中下载最新版本nvm-setup.zip，解压后，是一个安装文件，直接安装即可。</p><p>由于国内在一些情况下有些特殊。Node.js 官方镜像源又在国外，经常通过 nvm 安装 Node.js 时，速度比较慢，或者没有响应。</p><p>根据这种情况，nvm 允许更改安装的镜像源，我们可以将镜像源切换到国内的淘宝提供的镜像源。</p><p>默认安装目录（C:\Users[username]\AppData\Roaming\nvm）下的settings.txt文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看已安装的node</span><br><span class="line">nvm -ls </span><br><span class="line"># 安装指定版本的node</span><br><span class="line">nvm install &lt;version&gt;</span><br><span class="line"># 指定自己要使用的版本号</span><br><span class="line">nvm use &lt;version&gt;</span><br><span class="line"># 卸载指定版本的node</span><br><span class="line">nvm uninstall &lt;version&gt;</span><br></pre></td></tr></table></figure><blockquote><p>具体参考：<a href="https://github.com/coreybutler/nvm-windows#usage" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows#usage</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧的项目依赖低版本的node，但是现在的node版本变化太快，所以使用 nvm-windows 来管理不同版本的node。
    
    </summary>
    
    
      <category term="杂记" scheme="https://doubleray.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="NODE" scheme="https://doubleray.top/tags/NODE/"/>
    
  </entry>
  
  <entry>
    <title>CentOS配置Docker API TLS认证</title>
    <link href="https://doubleray.top/2020/04/03/other-docker-tls/"/>
    <id>https://doubleray.top/2020/04/03/other-docker-tls/</id>
    <published>2020-04-03T02:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.990Z</updated>
    
    <content type="html"><![CDATA[<p>我们利用Portainer来管理docker环境和用Jenkins来自动构建和部署docker时的远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。<a id="more"></a></p><p>下面我们针对CentOS系统进行配置：</p><p>一、利用系统自带的openssl生成相应的服务端和客户端证书<br>具体过程可参考：<a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a></p><p>我们利用脚本自动生成，这样非常便捷，脚本（auto-tls-certs.sh）如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动创建 Docker TLS 证书</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Config start</span></span><br><span class="line">IP="39.39.139.39"</span><br><span class="line">PASSWORD="123456"</span><br><span class="line">COUNTRY="CN"</span><br><span class="line">STATE="Beijing"</span><br><span class="line">CITY="Beijing"</span><br><span class="line">ORGANIZATION="COM"</span><br><span class="line">ORGANIZATIONAL_UNIT="Dev"</span><br><span class="line">COMMON_NAME="$IP"</span><br><span class="line">EMAIL="COM@china.cn"</span><br><span class="line"><span class="meta">#</span><span class="bash"> Config end</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成 CA 密钥</span></span><br><span class="line">if [[ ! -f ca-key.pem ]]; then</span><br><span class="line">    echo " - 生成 CA 密钥"</span><br><span class="line">    openssl genrsa -aes256 -passout "pass:$PASSWORD" -out "ca-key.pem" 4096</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成 CA</span></span><br><span class="line">if [[ ! -f ca.pem ]]; then</span><br><span class="line">    echo " - 生成 CA"</span><br><span class="line">    openssl req -new -x509 -days 365 -key "ca-key.pem" -sha256 -out "ca.pem" -passin "pass:$PASSWORD" -subj "/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL"</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成服务器密钥 &amp; 服务器证书</span></span><br><span class="line">if [[ ! -f server-key.pem ]]; then</span><br><span class="line">    echo " - 生成服务器密钥"</span><br><span class="line">    openssl genrsa -out "server-key.pem" 4096</span><br><span class="line">fi</span><br><span class="line">if [[ ! -f server.csr ]]; then</span><br><span class="line">     openssl req -subj "/CN=$COMMON_NAME" -sha256 -new -key "server-key.pem" -out server.csr</span><br><span class="line">fi</span><br><span class="line">if [[ ! -f server-cert.pem ]]; then</span><br><span class="line">    echo " - 生成服务器证书"</span><br><span class="line">    echo "subjectAltName = IP:$IP,IP:127.0.0.1" &gt;&gt; extfile.cnf</span><br><span class="line">    echo "extendedKeyUsage = serverAuth" &gt;&gt; extfile.cnf</span><br><span class="line">    openssl x509 -req -days 365 -sha256 -in server.csr -passin "pass:$PASSWORD" -CA "ca.pem" -CAkey "ca-key.pem" -CAcreateserial -out "server-cert.pem" -extfile extfile.cnf</span><br><span class="line">fi</span><br><span class="line">rm -f extfile.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成客户端证书</span></span><br><span class="line">if [[ ! -f key.pem ]]; then</span><br><span class="line">    openssl genrsa -out "key.pem" 4096</span><br><span class="line">fi</span><br><span class="line">if [[ ! -f cert.pem ]]; then</span><br><span class="line">    openssl req -subj '/CN=client' -new -key "key.pem" -out client.csr</span><br><span class="line">    echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br><span class="line">    openssl x509 -req -days 365 -sha256 -in client.csr -passin "pass:$PASSWORD" -CA "ca.pem" -CAkey "ca-key.pem" -CAcreateserial -out "cert.pem" -extfile extfile.cnf</span><br><span class="line">fi</span><br><span class="line">chmod -v 0400 "ca-key.pem" "key.pem" "server-key.pem"</span><br><span class="line">chmod -v 0444 "ca.pem" "server-cert.pem" "cert.pem"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包客户端证书</span></span><br><span class="line">echo " - 打包客户端证书为 tls-client-certs.tar.gz"</span><br><span class="line">mkdir -p "tls-client-certs"</span><br><span class="line">cp -f "ca.pem" "cert.pem" "key.pem" "tls-client-certs/"</span><br><span class="line">cd "tls-client-certs"</span><br><span class="line">tar zcf "tls-client-certs.tar.gz" *</span><br><span class="line">mv "tls-client-certs.tar.gz" ../</span><br><span class="line">cd ..</span><br><span class="line">rm -rf "tls-client-certs"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝服务端证书</span></span><br><span class="line">mkdir -p /etc/docker/certs.d</span><br><span class="line">cp -f "ca.pem" "server-cert.pem" "server-key.pem" /etc/docker/certs.d/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理</span></span><br><span class="line">rm -vf client.csr server.csr extfile.cnf ca.srl server-cert.pem server-key.pem cert.pem</span><br><span class="line">echo "Connect to server via docker-cli:"</span><br><span class="line">echo "docker -H $IP:2376 --tlsverify --tlscacert ~/.docker/ca.pem --tlscert ~/.docker/cert.pem --tlskey ~/.docker/key.pem ps -a"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端使用 cURL 连接</span></span><br><span class="line">echo "Connect to server via curl:"</span><br><span class="line">echo "curl --cacert ~/.docker/ca.pem --cert ~/.docker/cert.pem --key ~/.docker/key.pem https://$IP:2376/containers/json"</span><br><span class="line">echo -e "\e[1;32mAll be done.\e[0m"</span><br></pre></td></tr></table></figure><p>执行脚本前可能由于脚本是在windows端写地，会报一个错 $’\r’: command not found；所以先对脚本执行以下这个命令 ：</p><p><code>dos2unix auto-tls-certs.sh</code></p><p>然后再执行命令</p><p><code>sh ./auto-tls.certs.sh</code></p><p>对脚本中的变量进行修改并执行后，自动会创建好tls证书，服务器的证书会自动move到/etc/docker/certs.d/目录下；</p><p>客户端的证书在运行脚本的目录下，同时还自动打好了一个.tar.gz的包，很方便，可以下载到本地，配置时直接对应上传即可。</p><p>二、配置Docker服务<br>在 /usr/lib/systemd/system 目录下找到 文件 docker.service</p><p>原来的ExecStart项为：</p><blockquote><p>ExecStart=/usr/bin/dockerd -H fd:// –containerd=/run/containerd/containerd.sock</p></blockquote><p>修改为：</p><blockquote><p>ExecStart=/usr/bin/dockerd -H fd:// –containerd=/run/containerd/containerd.sock -H unix:///var/run/docker.sock -D -H tcp://0.0.0.0:2376   <br>         –tlsverify –tlscacert=/etc/docker/certs.d/ca.pem   <br>            –tlscert=/etc/docker/certs.d/server-cert.pem     <br>        –tlskey=/etc/docker/certs.d/server-key.pem</p></blockquote><p>然后执行命令重启docker服务：</p><p><code>systemctl daemon-reload</code><br><code>systemctl restart docker</code></p><p>成功重启后，服务端的配置就结束了(成功与否的检测方法在自动化脚本中有说明，也可以直接进行下一步)。</p><p>三、配置Portainer远程TLS连接</p><img src="/styles/images/Portainer-tls.png"><p>证书对应选择：</p><p>TLS CA certificate：ca.pem</p><p>TLS certificate：cert.pem</p><p>TLS key：key.pem</p><p>这样就完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们利用Portainer来管理docker环境和用Jenkins来自动构建和部署docker时的远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。
    
    </summary>
    
    
      <category term="杂记" scheme="https://doubleray.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://doubleray.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Harbor安装及使用</title>
    <link href="https://doubleray.top/2020/03/05/other-docker-harbor/"/>
    <id>https://doubleray.top/2020/03/05/other-docker-harbor/</id>
    <published>2020-03-05T08:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.989Z</updated>
    
    <content type="html"><![CDATA[<p>参考： <a href="https://istone.dev/2019/07/19/harbor-install/" target="_blank" rel="noopener">https://istone.dev/2019/07/19/harbor-install/</a></p><p><code>tar xvf harbor-offline-installer-v1.10.1.tgz</code></p><p><code>cd harbor</code></p><p>修改配置文件 harbor.yml</p><p><code>./install.sh --with-notary --with-clair --with-chartmuseum</code> 参数可选，分别对应三个扩展功能</p><p>完成后就可以访问了</p><p>将harbor加入开机自启，通过服务的形式</p><p>参考：<a href="https://www.cnblogs.com/kirito-c/p/11145881.html" target="_blank" rel="noopener">https://www.cnblogs.com/kirito-c/p/11145881.html</a></p><p><code>sudo systemctl enable harbor</code></p><p><code>sudo systemctl start harbor</code></p><p><code>systemctl status harbor.service -l</code>  检查是否开启</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考： &lt;a href=&quot;https://istone.dev/2019/07/19/harbor-install/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://istone.dev/2019/07/19/harbor-install/&lt;
      
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://doubleray.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门及实践</title>
    <link href="https://doubleray.top/2020/02/25/other-docker-know/"/>
    <id>https://doubleray.top/2020/02/25/other-docker-know/</id>
    <published>2020-02-25T10:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.989Z</updated>
    
    <content type="html"><![CDATA[<p>Docker官方文档：<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">https://docs.docker.com/get-started/</a></p><p>腾讯云的中文文档：<a href="https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3</a></p><p>DockerInfo中文文档：<a href="http://www.dockerinfo.net/document" target="_blank" rel="noopener">http://www.dockerinfo.net/document</a></p><p>Docker — 从入门到实践： <a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener">https://vuepress.mirror.docker-practice.com/</a></p><a id="more"></a><hr><p>所有命令可参考：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p><ul><li>列出本地已有镜像：  <code>docker images</code></li><li>移除镜像： <code>docker rmi 或者 docker image rm [id|name]</code></li></ul><blockquote><p>注意：在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。可加参数 -f 强制删除。</p></blockquote><ul><li>生成镜像： <code>docker build -t [repositoryName]:[tag] [Directory]</code></li></ul><p>命令行参数参考：<a href="https://www.runoob.com/docker/docker-build-command.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-build-command.html</a></p><blockquote><p>“Directory” 是 Dockerfile 所在的路径<br>一个镜像不能超过 127 层,编写Dockerfile时应注意</p></blockquote><ul><li>从镜像run容器：<code>docker run -d -p 1202:3000 --name=&quot;quoted&quot; tmd.ictr.cn:89/web-server/quoted:1.0</code></li></ul><p>命令行参数参考：<a href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-run-command.html</a></p><ul><li>docker重启退出的容器 docker attach [container]</li></ul><p><code>docker ps</code>: 查看当前运行的容器<br><code>docker ps -a</code>:查看所有容器，包括停止的。<br><code>docker ps -l</code>:查看最新创建的容器，只列出最后创建的。<br><code>docker ps -n=2</code>:-n=x选项，会列出最后创建的x个容器。</p><ul><li>移除容器：<code>docker rm [id]</code></li></ul><p>查看日志： <code>docker logs name</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker官方文档：&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/get-started/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;腾讯云的中文文档：&lt;a href=&quot;https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DockerInfo中文文档：&lt;a href=&quot;http://www.dockerinfo.net/document&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.dockerinfo.net/document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker — 从入门到实践： &lt;a href=&quot;https://vuepress.mirror.docker-practice.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://vuepress.mirror.docker-practice.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://doubleray.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 8安装Node</title>
    <link href="https://doubleray.top/2020/02/23/other-Centos-node/"/>
    <id>https://doubleray.top/2020/02/23/other-Centos-node/</id>
    <published>2020-02-23T04:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wget下载源码"><a href="#wget下载源码" class="headerlink" title="wget下载源码"></a>wget下载源码</h3><p>在需要安装nodejs的目录中执行</p><p><code>wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz</code></p><p><a href="https://nodejs.org/dist" target="_blank" rel="noopener">https://nodejs.org/dist</a> 这个目录下可以找到各个版本的源码</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>xz -d node-v12.16.1-linux-x64.tar.xz</code></p><p><code>tar -xvf node-v12.16.1-linux-x64.tar</code></p><h3 id="配置软连接"><a href="#配置软连接" class="headerlink" title="配置软连接"></a>配置软连接</h3><p>要想node能够在全局能够使用，需要添加软连接，配置完即可使用</p><p><code>ln -s /usr/local/node-v12.16.1-linux-x64/bin/node /usr/local/bin/node</code></p><p><code>ln -s /usr/local/node-v12.16.1-linux-x64/bin/npm /usr/local/bin/npm</code></p><h3 id="全局安装的包执行shell时找不到命令的解决方法"><a href="#全局安装的包执行shell时找不到命令的解决方法" class="headerlink" title="全局安装的包执行shell时找不到命令的解决方法"></a>全局安装的包执行shell时找不到命令的解决方法</h3><p><a href="https://blog.csdn.net/m0_37263637/article/details/81942435" target="_blank" rel="noopener">https://blog.csdn.net/m0_37263637/article/details/81942435</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;wget下载源码&quot;&gt;&lt;a href=&quot;#wget下载源码&quot; class=&quot;headerlink&quot; title=&quot;wget下载源码&quot;&gt;&lt;/a&gt;wget下载源码&lt;/h3&gt;&lt;p&gt;在需要安装nodejs的目录中执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget https://no
      
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Node" scheme="https://doubleray.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 8安装Docker</title>
    <link href="https://doubleray.top/2020/02/17/other-CentOS8-Docker/"/>
    <id>https://doubleray.top/2020/02/17/other-CentOS8-Docker/</id>
    <published>2020-02-17T02:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS-8安装Docker"><a href="#CentOS-8安装Docker" class="headerlink" title="CentOS 8安装Docker"></a>CentOS 8安装Docker</h2><p>本文参考<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a><a id="more"></a></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code>yum install -y yum-utils  device-mapper-persistent-data  lvm2</code></pre><blockquote><p>yum options -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）    </p></blockquote><h3 id="更改yum源为国内源"><a href="#更改yum源为国内源" class="headerlink" title="更改yum源为国内源"></a>更改yum源为国内源</h3><pre><code>yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</code></pre><h3 id="更新-yum-软件源缓存"><a href="#更新-yum-软件源缓存" class="headerlink" title="更新 yum 软件源缓存"></a>更新 yum 软件源缓存</h3><pre><code>yum makecache</code></pre><h3 id="安装-docker-ce"><a href="#安装-docker-ce" class="headerlink" title="安装 docker-ce"></a>安装 docker-ce</h3><pre><code>yum install docker-ce -y</code></pre><p>如果报错： Problem: package docker-ce-3:19.03.7-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of theproviders can be installed</p><p>问题的根源在于containerd.io的版本过低，这里通过安装较高版本的containerd.io即可解决问题。<br>访问官网：<a href="https://containerd.io/downloads/，根据提示，直接安装二进制包：" target="_blank" rel="noopener">https://containerd.io/downloads/，根据提示，直接安装二进制包：</a></p><pre><code>wget https://github.com/containerd/containerd/releases/download/v1.3.2/containerd-1.3.2.linux-amd64.tar.gz tar xvf containerd-1.3.2.linux-amd64.tar.gz</code></pre><p>这时候又有一个问题就是官网下载的网速奇慢，所以直接使用DNF工具从docker-ce的仓库（<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/）中下载：" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/）中下载：</a></p><pre><code>dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install docker-ce -ydocker --version （查看安装是否成功）</code></pre><p>###开启Docker服务</p><pre><code>systemctl enable docker （开机自启）systemctl start docker  （启动docker服务）systemctl restart docker 重启</code></pre><h3 id="Docker加速"><a href="#Docker加速" class="headerlink" title="Docker加速"></a>Docker加速</h3><p><a href="https://blog.csdn.net/varyall/article/details/104266706" target="_blank" rel="noopener">https://blog.csdn.net/varyall/article/details/104266706</a></p><p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p><p>curl -sSL <a href="https://get.daocloud.io/daotools/set_mirror.sh" target="_blank" rel="noopener">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a></p><p><code>docker pull node:12.16.1-alpine</code></p><p><code>docker run -it --name node-test node:12.16.1-alpine</code></p><p>我们在doker容器中直接运行node服务，并且打印字符串。这里我们通过run指令，用node镜像创建的一个叫node-test的容器， -i(interactive,表示开启交互), -t(terminal, 表示终端)，-it是两个参数的简写，表示通过命令行的方式运行。还可以添加-d(deamon)表示在后台运行。退出控制台后，我们通过docker ps -a查看当前的所有容器.</p><p>接下来我们再次启动这个容器，并进入其中运行bash命令行:</p><p><code>docker exec -it node-test sh</code></p><p>我们一般可能会在容器启动后进入容器，常用的是docker attach 镜像id，但是启动镜像的时候如果没有带 参数 -it的话，attach进去后可能是日志界面，并不能执行命令。所以我们会用 docker exec -it [镜像id] /bin/bash/</p><p>平常的容器一般都可以执行/bin/bash，但是alpine没有，改成 docker exec -it [镜像id] sh 就好了。</p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>下载docker-compose二进制文件安装，因为github网速慢，所以改到了daocloud</p><pre><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre><p>添加可执行权限 </p><p> <code>chmod +x /usr/local/bin/docker-compose</code></p><p>测试安装结果 </p><p><code>docker-compose --version</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CentOS-8安装Docker&quot;&gt;&lt;a href=&quot;#CentOS-8安装Docker&quot; class=&quot;headerlink&quot; title=&quot;CentOS 8安装Docker&quot;&gt;&lt;/a&gt;CentOS 8安装Docker&lt;/h2&gt;&lt;p&gt;本文参考&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker 官方 CentOS 安装文档&lt;/a&gt;
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://doubleray.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Auto Polyfill</title>
    <link href="https://doubleray.top/2019/11/14/article-js-auto-polyfill/"/>
    <id>https://doubleray.top/2019/11/14/article-js-auto-polyfill/</id>
    <published>2019-11-14T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是补丁？"><a href="#什么是补丁？" class="headerlink" title="什么是补丁？"></a>什么是补丁？</h2><blockquote><p>A polyfill, or polyfiller, is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape if you will.</p></blockquote><p>我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁。<a id="more"></a></p><hr><p>如果你是一个 3 年陈 + 的前端，应该会有听说过 shim、sham、es5-shim 和 es6-shim 等等现在看起来很古老的补丁方式。</p><p>那么，shim 和 sham 是啥？又有什么区别？</p><ul><li>shim 是能用的补丁</li><li>sham 顾名思义，是假的意思，所以 sham 是一些假的方法，只能使用保证不出错，但不能用。至于为啥会有 sham，因为有些方法的低端浏览器里根本实现不了</li></ul><hr><p>在 shim 和 sham 之后，还有一种补丁方式是引入包含所有语言层补丁的 babel-polyfill.js。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.2.5/polyfill.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>@babel/preset-env + useBuiltins: entry + targets</p><p>babel-polyfill 包含所有补丁，那我只需要支持某些浏览器的某些版本，是否有办法只包含这些浏览器的补丁？这就是 @babel/preset-env + useBuiltins: entry + targets 配置的方案。</p><p>我们先在入口文件里引入 @babel/polyfill，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span>;</span><br></pre></td></tr></table></figure><p>然后配置 .babelrc，添加 preset @babel/preset-env，并设置 useBuiltIns 和 targets，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/env"</span>, &#123;</span><br><span class="line">      useBuiltIns: 'entry',</span><br><span class="line">      targets: &#123; chrome: 62 &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useBuiltIns: entry 的含义是找到入口文件里引入的 @babel/polyfill，并替换为 targets 浏览器/环境需要的补丁列表。</p><p>替换后的内容，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"core-js/modules/es7.string.pad-start"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"core-js/modules/es7.string.pad-end"</span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这样就只会引入 chrome@62 及以上所需要的补丁，什么 Promise 之类的都不会再打包引入。</p><p>这种方案存在的问题：</p><ul><li>特性列表是按浏览器整理的，那怎么知道哪些特性我用了，哪些没有用到，没有用到的部分也引入了是不是也是冗余？@babel/preset-env 有提供 exclude 的配置，如果我配置了 exclude，后面是否得小心翼翼地确保不要用到 exclude 掉的特性</li><li>补丁是打包到静态文件的，如果我配置 targets 为 chrome: 62, ie: 9，那意味着 chrome 62 也得载入 ie 9 相关的补丁，这也是一份冗余</li><li>我们是基于 core-js 打的补丁，所以只会包含 ecmascript 规范里的内容，其他比如说 dom 里的补丁，就不在此列，应该如何处理？</li></ul><h2 id="在线补丁，比如：polyfill-io"><a href="#在线补丁，比如：polyfill-io" class="headerlink" title="在线补丁，比如：polyfill.io"></a>在线补丁，比如：polyfill.io</h2><p>目前最流行的应该就是 polyfill.io，提供的是 cdn 服务，有些站点在用，例如 <a href="https://spectrum.chat/。另外，polyfill.io" target="_blank" rel="noopener">https://spectrum.chat/。另外，polyfill.io</a> 还开源了 polyfill-service 供我们自己搭建使用。</p><p>使用上，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://polyfill.io/v3/polyfill.min.js?features=default%2CPromise"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://polyfill.alicdn.com/polyfill.min.js?features=default,es5,es6,es7,RegeneratorRuntime"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 Chrome@71 下的输出是：</p><p>/* Disable minification (remove <code>.min</code> from URL path) for more info */<br>啥都没有，因为 Promsie 特性 Chrome@71 已经支持了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是补丁？&quot;&gt;&lt;a href=&quot;#什么是补丁？&quot; class=&quot;headerlink&quot; title=&quot;什么是补丁？&quot;&gt;&lt;/a&gt;什么是补丁？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A polyfill, or polyfiller, is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape if you will.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁。
    
    </summary>
    
    
      <category term="实践之路" scheme="https://doubleray.top/categories/%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="Polyfill" scheme="https://doubleray.top/tags/Polyfill/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0 Function API</title>
    <link href="https://doubleray.top/2019/07/07/article-vue3-function-api/"/>
    <id>https://doubleray.top/2019/07/07/article-vue3-function-api/</id>
    <published>2019-07-07T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>Vue 3.0 的发布引起了轩然大波，让我们解读下它的 <a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#comparison-with-react-hooks" target="_blank" rel="noopener">function api RFC</a> 详细了解一下 Vue 团队是怎么想的吧！</p><a id="more"></a><p>首先官方回答了几个最受关注的问题：</p><p><strong>Vue 3.0 是否有 break change，就像 Python 3 / Angular 2 一样？</strong></p><p>不，100% 兼容 Vue 2.0，且暂未打算废弃任何 API（未来也不）。之前有草案试图这么做，但由于用户反馈太猛，被撤回了。</p><p><strong>Vue 3.0 的设计盖棺定论了吗？</strong></p><p>没有呀，这次精读的稿子就是 RFC（Request For Comments），翻译成中文就是 “意见征求稿”，还在征求大家意见中哦。</p><p><strong>这 RFC 咋这么复杂？</strong></p><p>RFC 是写给贡献者/维护者的，要考虑许多边界情况与细节，所以当然会复杂很多喽！当然 Vue 本身使用起来还是很简单的。</p><blockquote><p>Vue 本身 Mutable + Template 就注定了是个用起来简单（约定 + 自然），实现起来复杂（解析 + 双绑）的框架。</p></blockquote><p><strong>这次改动很像在模仿 React，为啥不直接用 React？</strong></p><p>首先 Template 机制还是没变，其次模仿的是 Hooks 而不是 React 全部，如果你不喜欢这个改动，那你更不会喜欢用 React。</p><p>PS: 问这个问题的人，一定没有同时理解 React 与 Vue，其实这两个框架到现在差别蛮大的，后面精读会详细说明。</p><p>下面正式进入 Vue 3.0 Function API 的介绍。</p><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><p>Vue 函数式基本 Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;count++&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; value, computed, watch, onMounted &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // reactive state</span><br><span class="line">    const count = value(0)</span><br><span class="line">    // computed state</span><br><span class="line">    const plusOne = computed(() =&gt; count.value + 1)</span><br><span class="line">    // method</span><br><span class="line">    const increment = () =&gt; &#123; count.value++ &#125;</span><br><span class="line">    // watch</span><br><span class="line">    watch(() =&gt; count.value * 2, val =&gt; &#123;</span><br><span class="line">      console.log(`count * 2 is $&#123;val&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    // lifecycle</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(`mounted`)</span><br><span class="line">    &#125;)</span><br><span class="line">    // expose bindings on render context</span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">      plusOne,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>函数式风格的入口是 <code>setup</code> 函数，采用了函数式风格后可以享受如下好处：类型自动推导、减少打包体积。</p><p><code>setup</code> 函数返回值就是注入到页面模版的变量。我们也可以返回一个函数，通过使用 <code>value</code> 这个 API 产生属性并修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; value &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = value(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">const</span> appendName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      msg.value = <span class="string">`hello <span class="subst">$&#123;props.name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg,</span><br><span class="line">      appendName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div @click="appendName"&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，<code>value()</code> 返回的是一个对象，通过 <code>.value</code> 才能访问到其真实值。</p><p>为何 <code>value()</code> 返回的是 Wrappers 而非具体值呢？原因是 Vue 采用双向绑定，只有对象形式访问值才能保证访问到的是最终值，这一点类似 React 的 <code>useRef()</code> API 的 <code>.current</code> 规则。</p><p>那既然所有 <code>value()</code> 返回的值都是 Wrapper，那直接给模版使用时要不要调用 <code>.value</code> 呢？<strong>答案是否定的，直接使用即可，模版会自动 <code>Unwrapping</code>:</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: value(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;button @click="count++"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 <strong>Hooks</strong>，下面是一个使用 Hooks 实现获得鼠标实时位置的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in consuming component</span></span><br><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br><span class="line">    <span class="keyword">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, z &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>useMouse</code> 将所有与 “处理鼠标位置” 相关的逻辑都封装了进去，乍一看与 React Hooks 很像，但是有两个区别：</p><ol><li><code>useMouse</code> 函数内改变 <code>x</code>、<code>y</code> 后，不会重新触发 <code>setup</code> 执行。</li><li><code>x</code> <code>y</code> 拿到的都是 Wrapper 而不是原始值，且这个值会动态变化。</li></ol><p>另一个重要 API 就是 <strong><code>watch</code></strong>，它的作用类似 React Hooks 的 <strong>useEffect</strong>，但实现原理和调用时机其实完全不一样。</p><p><code>watch</code> 的目的是监听某些变量变化后执行逻辑，比如当 <code>id</code> 变化后重新取数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = value(<span class="literal">null</span>)</span><br><span class="line">    watch(<span class="function"><span class="params">()</span> =&gt;</span> props.id, <span class="keyword">async</span> (id) =&gt; &#123;</span><br><span class="line">      data.value = <span class="keyword">await</span> fetchData(id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以要 <code>watch</code>，因为在 Vue 中，<code>setup</code> 函数仅执行一次，所以不像 React Function Component，每次组件 <code>props</code> 变化都会重新执行，因此无论是在变量、<code>props</code> 变化时如果想做一些事情，都需要包裹在 <code>watch</code> 中。</p><p>后面还有 <code>unwatching</code>、生命周期函数、依赖注入，都是一些语法定义，感兴趣可以继续<a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#dependency-injection" target="_blank" rel="noopener">阅读原文</a>，笔者就不赘述了。</p><h2 id="Vue-与-React-逻辑结构"><a href="#Vue-与-React-逻辑结构" class="headerlink" title="Vue 与 React 逻辑结构"></a>Vue 与 React 逻辑结构</h2><p>React Function Component 与 Hooks，虽然在实现原理上，与 Vue3.0 存在 Immutable 与 Mutable、JSX 与 Template 的区别，但逻辑理解上有着相通之处。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = value(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> setXRandom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      x.value = <span class="built_in">Math</span>.random()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; x, setXRandom &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @onClick="setXRandom"/&gt;&#123;&#123;x&#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在 Vue 中，<code>setup</code> 函数仅执行一次，看上去与 React 函数完全不一样（React 函数每次都执行），但其实 Vue 将渲染层（Template）与数据层（setup）分开了，而 React 合在了一起。</p><p>我们可以利用 React Hooks 将数据层与渲染层完全隔离：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似 vue 的 setup 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyComponentSetup</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [x, setX] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setXRandom = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setX(<span class="built_in">Math</span>.random())</span><br><span class="line">  &#125;, [setX])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; x, setXRandom &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 vue 的 template 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props: &#123; name: String &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; x, setXRandom &#125; = useMyComponentSetup(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;setXRandom&#125;&gt;&#123;x&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这源于 JSX 与 Template 的根本区别。JSX 使模版与 JS 可以写在一起，因此数据层与渲染层可以耦合在一起写（也可以拆分），但 Vue 采取的 Template 思路使数据层强制分离了，这也使代码分层更清晰了。</p><p>而实际上 Vue3.0 的 <code>setup</code> 函数也是可选的，再配合其支持的 TSX 功能，与 React 真的只有 Mutable 的区别了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是个 Vue 组件</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = createComponent(<span class="function">(<span class="params">props: &#123; msg: string &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> h(<span class="string">'div'</span>, props.msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们很难评价 Template 与 JSX 的好坏，但为了更透彻的理解 Vue 与 React，需要抛开 JSX&amp;Template，Mutable&amp;Immutable 去看，其实去掉这两个框架无关的技术选型，React@16 与 Vue@3 已经非常像了。</p><blockquote><p>Vue3.0 的精髓是学习了 React Hooks 概念，因此正好可以用 Hooks 在 React 中模拟 Vue 的 setup 函数。</p></blockquote><p>关于这两套技术选型，已经是相对完美的组合，不建议在 JSX 中再实现类似 Mutable + JSX 的花样来（因为喜欢 Mutable 可以用 Vue 呀）：</p><ul><li>Vue：Mutable + Template</li><li>React：Immutable + JSX</li></ul><p>真正影响编码习惯的就是 Mutable 与 Immutable，使用 Vue 就坚定使用 Mutable，使用 React 就坚定使用 Immutable，这样能最大程度发挥两套框架的价值。</p><h2 id="Vue-Hooks-与-React-Hooks-的差异"><a href="#Vue-Hooks-与-React-Hooks-的差异" class="headerlink" title="Vue Hooks 与 React Hooks 的差异"></a>Vue Hooks 与 React Hooks 的差异</h2><p>先看 React Hooks 的简单语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setToOne = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Vue Hooks 的简单语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = value(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setToOne = <span class="function"><span class="params">()</span> =&gt;</span> count.value = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>之所以 React 返回的 <code>count</code> 是一个数字，是因为 Immutable 规则，而 Vue 返回的 <code>count</code> 是个对象，拥有 <code>count.value</code> 属性，也是因为 Vue Mutable 规则导致，这使得 Vue 定义的所有变量都类似 React 中 <code>useRef</code> 定义变量，因此不存 React <code>capture value</code> 的特性。</p><blockquote><p>关于 capture value 更多信息，可以阅读 <a href="https://github.com/dt-fe/weekly/blob/v2/095.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20VS%20Class%20%E7%BB%84%E4%BB%B6%E3%80%8B.md#capture-props" target="_blank" rel="noopener">精读《Function VS Class 组件》 Capute Value 介绍</a></p></blockquote><p>另外，对于 Hooks 的值变更机制也不同，我们看 Vue 的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br><span class="line">    <span class="keyword">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, z &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>setup</code> 函数仅执行一次，怎么做到当 <code>useMouse</code> 导致 <code>x</code>、<code>y</code> 值变化时，可以在 <code>setup</code> 中拿到最新的值？</p><p>在 React 中，<code>useMouse</code> 如果修改了 <code>x</code> 的值，那么使用 <code>useMouse</code> 的函数就会被重新执行，以此拿到最新的 <code>x</code>，而在 Vue 中，将 Hooks 与 Mutable 深度结合，通过包装 <code>x.value</code>，使得当 <code>x</code> 变更时，引用保持不变，仅值发生了变化。所以 Vue 利用 Proxy 监听机制，可以做到 <code>setup</code> 函数不重新执行，但 Template 重新渲染的效果。</p><p>这就是 Mutable 的好处，Vue Hooks 中，不需要 <code>useMemo</code> <code>useCallback</code> <code>useRef</code> 等机制，仅需一个 <code>value</code> 函数，直观的 Mutable 修改，就可以实现 React 中一套 Immutable 性能优化后的效果，这个是 Mutable 的魅力所在。</p><h2 id="Vue-Hooks-的优势"><a href="#Vue-Hooks-的优势" class="headerlink" title="Vue Hooks 的优势"></a>Vue Hooks 的优势</h2><p>笔者对 RFC 中对 Vue、React Hooks 的对比做一个延展解释：</p><p>首先最大的不同：<code>setup</code> 仅执行一遍，而 React Function Component 每次渲染都会执行。</p><p><strong>Vue 的代码使用更符合 JS 直觉。</strong></p><p>这句话直截了当戳中了 JS 软肋，JS 并非是针对 Immutable 设计的语言，所以 Mutable 写法非常自然，而 Immutable 的写法就比较别扭。</p><p>当 Hooks 要更新值时，Vue 只要用等于号赋值即可，而 React Hooks 需要调用赋值函数，<strong>当对象类型复杂时，还需借助第三方库才能保证进行了正确的 Immutable 更新。</strong></p><p><strong>对 Hooks 使用顺序无要求，而且可以放在条件语句里。</strong></p><p>对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。</p><p>而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 <code>setup</code> 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。</p><p><strong>不会再每次渲染重复调用，减少 GC 压力。</strong></p><p>这确实是 React Hooks 的一个问题，所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。</p><p>而 Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 <code>setup</code> 的执行，所以确实不会造成 GC 压力。</p><p><strong>必须要总包裹 <code>useCallback</code> 函数确保不让子元素频繁重渲染。</strong></p><p>React Hooks 有一个问题，就是完全依赖 Immutable 属性。<strong>而在 Function Component 内部创建函数时，每次都会创建一个全新的对象，这个对象如果传给子组件，必然导致子组件无法做性能优化。</strong> 因此 React 采取了 <code>useCallback</code> 作为优化方案：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> <span class="comment">/* .. */</span>, [])</span><br></pre></td></tr></table></figure><p>只有当第二个依赖参数变化时才返回新引用。但第二个依赖参数需要 lint 工具确保依赖总是正确的（关于为何要对依赖诚实，感兴趣可以移步 <a href="https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md#%E6%B0%B8%E8%BF%9C%E5%AF%B9%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%AF%9A%E5%AE%9E" target="_blank" rel="noopener">精读《Function Component 入门》 - 永远对依赖诚实</a>）。</p><p>回到 Vue 3.0，由于 <code>setup</code> 仅执行一次，因此函数本身只会创建一次，不存在多实例问题，不需要 <code>useCallback</code> 的概念，更不需要使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">lint 插件</a> 保证依赖书写正确，这对开发者是实实在在的友好。</p><p><strong>不需要使用 <code>useEffect</code> <code>useMemo</code> 等进行性能优化，所有性能优化都是自动的。</strong></p><p>这也是实在话，毕竟 Mutable + 依赖自动收集就可以做到最小粒度的精确更新，根本不会触发不必要的 Rerender，因此 <code>useMemo</code> 这个概念也不需要了。</p><p>而 <code>useEffect</code> 也需要传递第二个参数 “依赖项”，在 Vue 中根本不需要传递 “依赖项”，所以也不会存在用户不小心传错的问题，更不需要像 React 写一个 lint 插件保证依赖的正确性。（这也是笔者想对 React Hooks 吐槽的点，React 团队如何保障每个人都安装了 lint？就算装了 lint，如果 IDE 有 BUG，导致没有生效，随时可能写出依赖不正确的 “危险代码”，造成比如死循环等严重后果）</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>通过对比 Vue Hooks 与 React Hooks 可以发现，Vue 3.0 将 Mutable 特性完美与 Hooks 结合，规避了一些 React Hooks 的硬伤。所以我们可以说 Vue 借鉴了 React Hooks 的思想，但创造出来的确实一个更精美的艺术品。</p><p>但 React Hooks 遵循的 Immutable 也有好的一面，就是每次渲染中状态被稳定的固化下来了，不用担心状态突然变更带来的影响（其实反而要注意状态用不变更带来的影响），对于数据记录、程序运行的稳定性都有较高的可预期性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;p&gt;Vue 3.0 的发布引起了轩然大波，让我们解读下它的 &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#comparison-with-react-hooks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;function api RFC&lt;/a&gt; 详细了解一下 Vue 团队是怎么想的吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://doubleray.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>重新思考 Redux</title>
    <link href="https://doubleray.top/2019/07/06/article-react-redux-think/"/>
    <id>https://doubleray.top/2019/07/06/article-react-redux-think/</id>
    <published>2019-07-06T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>《重新思考 Redux》是 <a href="https://github.com/rematch/rematch" target="_blank" rel="noopener">rematch</a> 作者 <a href="https://github.com/ShMcK" target="_blank" rel="noopener">Shawn McKay</a> 写的一篇干货软文。</p><p><a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> 之后，有许多基于 redux 的状态管理框架，但大部分都很局限，甚至是倒退。但直到看到了 rematch，总算觉得 redux 社区又进了一步。</p><p>这篇文章的宝贵之处在于，抛开 Mobx、RXjs 概念，仅针对 redux 做深入的重新思考，对大部分还在使用 redux 的工程场景非常有帮助。</p><a id="more"></a><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><p>比较新颖的是，作者给出一个公式，评价一个框架或工具的质量：</p><p><code>工具质量 = 工具节省的时间/使用工具消耗的时间</code></p><p>如果这样评估原生的 redux，我们会发现，使用 redux 需要额外花费的时间可能超过了其节省下来的时间，从这个角度看，redux 是会降低工作效率的。</p><p>但 redux 的数据管理思想是正确的，复杂的前端项目也确实需要这种理念，为了更有效率的使用 redux，我们需要使用基于 redux 的框架。作者从 6 个角度阐述了基于 redux 的框架需要解决什么问题。</p><h3 id="简化初始化"><a href="#简化初始化" class="headerlink" title="简化初始化"></a>简化初始化</h3><p>redux 初始化代码涉及的概念比较多，比如 <code>compose</code> <code>thunk</code> 等等，同时将 <code>reducer</code>、<code>initialState</code>、<code>middlewares</code> 这三个重要概念拆分成了函数方式调用，而不是更容易接受的配置方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="function"><span class="params">preloadedState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(</span><br><span class="line">    rootReducer,</span><br><span class="line">    preloadedState,</span><br><span class="line">    compose(applyMiddleware(thunk, api), DevTools.instrument())</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果换成配置方式，理解成本会降低不少：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Redux.Store(&#123;</span><br><span class="line">  instialState: &#123;&#125;,</span><br><span class="line">  reducers: &#123; count &#125;,</span><br><span class="line">  middlewares: [api, devTools]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>笔者注：redux 的初始化方式非常函数式，而下面的配置方式就更面向对象一些。相比之下，还是面向对象的方式更好理解，毕竟 store 是一个对象。<code>instialState</code> 也存在同样问题，相比显示申明，将 <code>preloadedState</code> 作为函数入参就比较抽象了，同时 redux 对初始 state 的赋值也比较隐蔽，<code>createStore</code> 时统一赋值比较别扭，因为 reducers 是分散的，如果在 reducers 中赋值，要利用 es 的默认参数特性，看起来更像业务思考，而不是 redux 提供的能力。</p></blockquote><h3 id="简化-Reducers"><a href="#简化-Reducers" class="headerlink" title="简化 Reducers"></a>简化 Reducers</h3><p>redux 的 reducer 粒度太大，不但导致函数内手动匹配 <code>type</code>，还带来了 <code>type</code>、<code>payload</code> 等理解成本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> state - action.payload;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果用配置的方式设置 reducers，就像定义一个对象一样，会更清晰：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countReducer = &#123;</span><br><span class="line">  INCREMENT: <span class="function">(<span class="params">state, action</span>) =&gt;</span> state + action.payload,</span><br><span class="line">  DECREMENT: <span class="function">(<span class="params">state, action</span>) =&gt;</span> state - action.payload</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="支持-async-await"><a href="#支持-async-await" class="headerlink" title="支持 async/await"></a>支持 async/await</h3><p>redux 支持动态数据还是挺费劲的，需要理解高阶函数，理解中间件的使用方式，否则你不会知道为什么这样写是对的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> incrementAsync = <span class="function"><span class="params">count</span> =&gt;</span> <span class="keyword">async</span> dispatch =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> delay();</span><br><span class="line">  dispatch(increment(count));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么不抹掉理解成本，直接允许 <code>async</code> 类型的 action 呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> incrementAsync = <span class="keyword">async</span> count =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> delay();</span><br><span class="line">  dispatch(increment(count));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>笔者注：我们发现 rematch 的方式，dispatch 是 import 进来的（全局变量），而 redux 的 dispatch 是注入进来的，乍一看似乎 redux 更合理，但其实我更推崇 rematch 的方案。经过长期实践，组件最好不要使用数据流，项目的数据流只用一个实例完全够用了，全局 dispatch 的设计其实更合理，而注入 dispatch 的设计看似追求技术极致，但忽略了业务使用场景，导致画蛇添足，增加了不必要的麻烦。</p></blockquote><h3 id="将-action-reducer-改为两种-action"><a href="#将-action-reducer-改为两种-action" class="headerlink" title="将 action + reducer 改为两种 action"></a>将 action + reducer 改为两种 action</h3><p>redux 抽象的 action 与 reducer 的指责很清晰，action 负责改 store 以外所有事，而 reducer 负责改 store，偶尔用来做数据处理。这种概念其实比较模糊，因为往往不清楚数据处理放在 action 还是 reducer 里，同时过于简单的 reducer 又要写 action 与之匹配，感觉过于形式化，而且繁琐。</p><p>重新考虑这个问题，我们只有两类 action：<code>reducer action</code> 与 <code>effect action</code>。</p><ul><li>reducer action：改变 store。</li><li>effect action：处理异步场景，能调用其他 action，不能修改 store。</li></ul><p>同步的场景，一个 reducer 函数就能处理，只有异步场景需要 <code>effect action</code> 处理掉异步部分，同步部分依然交给 reducer 函数，这两种 action 职责更清晰。</p><h3 id="不再显示申明-action-type"><a href="#不再显示申明-action-type" class="headerlink" title="不再显示申明 action type"></a>不再显示申明 action type</h3><p>不要在用一个文件存储 Action 类型了，<code>const ACTION_ONE = &#39;ACTION_ONE&#39;</code> 其实重复写了一遍字符串，直接用对象的 key 表示 action 的值，再加上 store 的 name 为前缀保证唯一性即可。</p><p>同时 redux 建议使用 <code>payload</code> key 来传值，那为什么不强制使用 <code>payload</code> 作为入参，而要通过 <code>action.payload</code> 取值呢？直接使用 <code>payload</code> 不但视觉上减少代码数量，容易理解，同时也强制约束了代码风格，让建议真正落地。</p><h3 id="Reducer-直接作为-ActionCreator"><a href="#Reducer-直接作为-ActionCreator" class="headerlink" title="Reducer 直接作为 ActionCreator"></a>Reducer 直接作为 ActionCreator</h3><p>redux 调用 action 比较繁琐，使用 <code>dispatch</code> 或者将 reducer 经过 <code>ActionCreator</code> 函数包装。为什么不直接给 reducer 自动包装 <code>ActionCreator</code> 呢？减少样板代码，让每一行代码都有业务含义。</p><p>最后作者给出了一个 <code>rematch</code> 完整的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init, dispatch &#125; <span class="keyword">from</span> <span class="string">"@rematch/core"</span>;</span><br><span class="line"><span class="keyword">import</span> delay <span class="keyword">from</span> <span class="string">"./makeMeWait"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: <span class="number">0</span>,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    increment: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> state + payload,</span><br><span class="line">    decrement: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> state - payload</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    <span class="keyword">async</span> incrementAsync(payload) &#123;</span><br><span class="line">      <span class="keyword">await</span> delay();</span><br><span class="line">      <span class="keyword">this</span>.increment(payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = init(&#123;</span><br><span class="line">  models: &#123; count &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch.count.incrementAsync(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>我觉得本文基本上把 redux 存在的工程问题分析透彻了，同时还给出了一套非常好的实现。</p><h3 id="细节的极致优化"><a href="#细节的极致优化" class="headerlink" title="细节的极致优化"></a>细节的极致优化</h3><p>首先是直接使用 <code>payload</code> 而不是整个 <code>action</code> 作为入参，加强了约束同时简化代码复杂度:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increment: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> state + payload;</span><br></pre></td></tr></table></figure><p>其次使用 <code>async</code> 在 effects 函数中，使用 <code>this.increment</code> 函数调用方式，取代 <code>put({type: &quot;increment&quot;})</code>（dva），在 typescript 中拥有了类型支持，不但可以用自动跳转代替字符串搜索，还能校验参数类型，在 redux 框架中非常难得。</p><p>最后在 <code>dispatch</code> 函数，也提供了两种调用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123; <span class="keyword">type</span>: <span class="string">"count/increment"</span>, payload: <span class="number">1</span> &#125;);</span><br><span class="line">dispatch.count.increment(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果为了更好的类型支持，或者屏蔽 <code>payload</code> 概念，可以使用第二种方案，再一次简化 redux 概念。</p><h3 id="内置了比较多的插件"><a href="#内置了比较多的插件" class="headerlink" title="内置了比较多的插件"></a>内置了比较多的插件</h3><p>rematch 将常用的 reselect、persist、immer 等都集成为了插件，相对比较强化插件生态的概念。数据流对数据缓存，性能优化，开发体验优化都有进一步施展的空间，拥抱插件生态是一个良好的发展方向。</p><p>比如 <a href="https://github.com/rematch/rematch/blob/master/plugins/immer/README.md" target="_blank" rel="noopener">rematch-immer</a> 插件，可以用 mutable 的方式修改 store：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: <span class="number">0</span>,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    add(state) &#123;</span><br><span class="line">      state += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是当 state 为非对象时，immer 将不起作用，所以最好能养成 <code>return state</code> 的习惯。</p><p>最后说一点瑕疵的地方，<code>reducers</code> 申明与调用参数不一致。</p><h3 id="Reducers-申明与调用参数不一致"><a href="#Reducers-申明与调用参数不一致" class="headerlink" title="Reducers 申明与调用参数不一致"></a>Reducers 申明与调用参数不一致</h3><p>比如下面的 reducers：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: <span class="number">0</span>,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    increment: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> state + payload,</span><br><span class="line">    decrement: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> state - payload</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    <span class="keyword">async</span> incrementAsync(payload) &#123;</span><br><span class="line">      <span class="keyword">await</span> delay();</span><br><span class="line">      <span class="keyword">this</span>.increment(payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义时 <code>increment</code> 是两个参数，而 <code>incrementAsync</code> 调用它时，只有一个参数，这样可能造成一些误导，笔者建议保持参数对应关系，将 <code>state</code> 放在 <code>this</code> 中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = &#123;</span><br><span class="line">  state: <span class="number">0</span>,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    increment: <span class="function"><span class="params">payload</span> =&gt;</span> <span class="keyword">this</span>.state + payload,</span><br><span class="line">    decrement: <span class="function"><span class="params">payload</span> =&gt;</span> <span class="keyword">this</span>.state - payload</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    <span class="keyword">async</span> incrementAsync(payload) &#123;</span><br><span class="line">      <span class="keyword">await</span> delay();</span><br><span class="line">      <span class="keyword">this</span>.increment(payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然 rematch 的方式保持了函数的无副作性质，可以看出是做了一些取舍。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>重复一下作者提出工具质量的公式：</p><p><code>工具质量 = 工具节省的时间/使用工具消耗的时间</code></p><p>如果一个工具能节省开发时间，但本身带来了很大使用成本，在想清楚如何减少使用成本之前，不要急着用在项目中，这是我得到的最大启发。</p><p>最后感谢 rematch 作者精益求精的精神，给 redux 带来进一步的极致优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;《重新思考 Redux》是 &lt;a href=&quot;https://github.com/rematch/rematch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rematch&lt;/a&gt; 作者 &lt;a href=&quot;https://github.com/ShMcK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shawn McKay&lt;/a&gt; 写的一篇干货软文。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dvajs/dva&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dva&lt;/a&gt; 之后，有许多基于 redux 的状态管理框架，但大部分都很局限，甚至是倒退。但直到看到了 rematch，总算觉得 redux 社区又进了一步。&lt;/p&gt;
&lt;p&gt;这篇文章的宝贵之处在于，抛开 Mobx、RXjs 概念，仅针对 redux 做深入的重新思考，对大部分还在使用 redux 的工程场景非常有帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
      <category term="Redux" scheme="https://doubleray.top/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>如何安全地使用 React context</title>
    <link href="https://doubleray.top/2019/06/22/article-react-c-context/"/>
    <id>https://doubleray.top/2019/06/22/article-react-c-context/</id>
    <published>2019-06-22T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>在 React 源码中，context 始终存在，却在 React 0.14 的官方文档中才有所体现。在目前最新的官方文档中，仍不建议使用 context，也表明 context 是一个实验性的 API，在未来 React 版本中可能被更改。那么哪些场景下需要用到 context，而哪些情况下应该避免使用，context 又有什么坑呢？让我们一起来讨论一下。</p><a id="more"></a><h2 id="2-内容概要"><a href="#2-内容概要" class="headerlink" title="2 内容概要"></a>2 内容概要</h2><p>React context 可以把数据直接传递给组件树的底层组件，而无需中间组件的参与。Redux 作者 Dan Abramov 为 contenxt 的使用总结了一些注意事项：</p><ul><li>如果你是一个库的作者，需要将信息传递给深层次组件时，context 在一些情况下可能无法更新成功。</li><li>如果是界面主题、本地化信息，context 被应用于不易改变的全局变量，可以提供一个高阶组件，以便在 API 更新时只需修改一处。</li><li>如果库需要你使用 context，请它提供高阶组件给你。</li></ul><p>正如 Dan 第一条所述，在 React issue 中，经常能找到 React.PureComponent、shouldComponentUpdate 与包含 Context 的库结合后引发的一些问题。原因在于 shouldComponentUpdate 会切断子树的 rerender，当 state 或 props 没有发生变化时，可能意外中断上层 context 传播。也就是当 shouldComponentUpdate 返回 false 时，context 的变化是无法被底层所感知的。</p><p>因此，我们认为 context 应该是不变的，在构造时只接受 context 一次，使用 context，应类似于依赖注入系统来进行。结合精读文章的示例总结一下思路，不变的 context 中包含可变的元素，元素的变化触发自身的监听器实现底层组件的更新，从而绕过 shouldComponentUpdate。</p><p>最后作者提出了 Mobx 下的两种解决方案。context 中的可变元素可用 observable 来实现，从而避免上述事件监听器编写，因为 observable 会帮你完成元素改变后的响应。当然 Provider + inject 也可以完成，具体可参考精读文章中的代码。</p><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>本次提出独到观点的同学有：<br><a href="https://www.zhihu.com/people/turbe-xue" target="_blank" rel="noopener">@monkingxue</a> <a href="https://github.com/alcat2008" target="_blank" rel="noopener">@alcat2008</a> <a href="https://www.zhihu.com/people/huang-zi-yi-83" target="_blank" rel="noopener">@ascoders</a>，精读由此归纳。</p><h3 id="context-的使用场景"><a href="#context-的使用场景" class="headerlink" title="context 的使用场景"></a>context 的使用场景</h3><blockquote><p>In some cases, you want to pass data through the component tree without having to pass the props down manually at every level.</p></blockquote><p>context 的本质在于为组件树提供一种跨层级通信的能力，原本在 React 只能通过 props 逐层传递数据，而 context 打破了这一层束缚。</p><p>context 虽然不被建议使用，但在一些流行库中却非常常见，例如：<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a>、<a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a>。究其原因，我认为是单一顶层与多样底层间不是单纯父子关系的结果。例如：react-redux 中的 Provider，react-router 中的 Router，均在顶层控制 store 信息与路由信息。而对于 Connect 与 Route 而言，它们在 view 中的层级是多样化的，通过 context 获取顶层 Provider 与 Router 中的相关信息再合适不过。</p><h3 id="context-的坑"><a href="#context-的坑" class="headerlink" title="context 的坑"></a>context 的坑</h3><ul><li>context 相当于一个全局变量，难以追溯数据源，很难找到是在哪个地方中对 context 进行了更新。</li><li>组件中依赖 context，会使组件耦合度提高，既不利于组件复用，也不利于组件测试。</li><li>当 props 改变或是 setState 被调用，getChildContext 也会被调用，生成新的 context，但 shouldComponentUpdate 返回的 false 会 block 住 context，导致没有更新，这也是精读文章的重点内容。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>正如精读文章开头所说，context 是一个非常强大的，具有很多免责声明的特性，就像伊甸园中的禁果。的确，引入全局变量似乎是应用混乱的开始，而 context 与 props/state 相比也实属异类。在业务代码中，我们应抵制使用 context，而在框架和库中可结合场景适当使用，相信 context 也并非洪水猛兽。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;在 React 源码中，context 始终存在，却在 React 0.14 的官方文档中才有所体现。在目前最新的官方文档中，仍不建议使用 context，也表明 context 是一个实验性的 API，在未来 React 版本中可能被更改。那么哪些场景下需要用到 context，而哪些情况下应该避免使用，context 又有什么坑呢？让我们一起来讨论一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks</title>
    <link href="https://doubleray.top/2019/05/19/article-react-hooks-intro/"/>
    <id>https://doubleray.top/2019/05/19/article-react-hooks-intro/</id>
    <published>2019-05-19T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，想尝试的同学安装此版本即可。</p><p><strong>React Hooks 要解决的问题是状态共享</strong>，是继 <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">render-props</a> 和 <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p><p>状态共享可能描述的不恰当，称为<strong>状态逻辑复用</strong>会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p><p>为了更快理解 React Hooks 是什么，先看下面一段 renderProps 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Toggle initial=&#123;false&#125;&gt;</span><br><span class="line">      &#123;(&#123; on, toggle &#125;) =&gt; (</span><br><span class="line">        &lt;Button type=&quot;primary&quot; onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt;</span><br><span class="line">        &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恰巧，React Hooks 解决的也是这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [open, setOpen] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setOpen(true)&#125;&gt;</span><br><span class="line">        Open Modal</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Modal</span><br><span class="line">        visible=&#123;open&#125;</span><br><span class="line">        onOk=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">        onCancel=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，<strong>这个组件是没有状态的</strong>。</p><a id="more"></a><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p><ol><li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li><li>Hooks 可以引用其他 Hooks。</li><li>更容易将组件的 UI 与状态分离。</li></ol><p>第二点展开说一下：Hooks 可以引用其他 Hooks，我们可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 底层 Hooks, 返回布尔值：是否在线</span><br><span class="line">function useFriendStatusBoolean(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offline</span><br><span class="line">function useFriendStatusString(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatusBoolean(props.friend.id);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &quot;Loading...&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用了底层 Hooks 的 UI</span><br><span class="line">function FriendListItem(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatusBoolean(props.friend.id);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;li style=&#123;&#123; color: isOnline ? &quot;green&quot; : &quot;black&quot; &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用了上层 Hooks 的 UI</span><br><span class="line">function FriendListStatus(props) &#123;</span><br><span class="line">  const status = useFriendStatusString(props);</span><br><span class="line"></span><br><span class="line">  return &lt;li&gt;&#123;status&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，有两个 Hooks：<code>useFriendStatusBoolean</code> 与 <code>useFriendStatusString</code>, <code>useFriendStatusString</code> 是利用 <code>useFriendStatusBoolean</code> 生成的新 Hook，这两个 Hook 可以给不同的 UI：<code>FriendListItem</code>、<code>FriendListStatus</code> 使用，而因为两个 Hooks 数据是联动的，因此两个 UI 的状态也是联动的。</p><p>顺带一提，这个例子也可以用来理解 <a href="https://zhuanlan.zhihu.com/p/48264713" target="_blank" rel="noopener">对 React Hooks 的一些思考</a> 一文的那句话：<strong>“有状态的组件没有渲染，有渲染的组件没有状态”</strong>：</p><ul><li><code>useFriendStatusBoolean</code> 与 <code>useFriendStatusString</code> 是有状态的组件（使用 <code>useState</code>），没有渲染（返回非 UI 的值），这样就可以作为 <strong>Custom Hooks</strong> 被任何 UI 组件调用。</li><li><code>FriendListItem</code> 与 <code>FriendListStatus</code> 是有渲染的组件（返回了 JSX），没有状态（没有使用 <code>useState</code>），这就是一个纯函数 UI 组件，</li></ul><h3 id="利用-useState-创建-Redux"><a href="#利用-useState-创建-Redux" class="headerlink" title="利用 useState 创建 Redux"></a>利用 useState 创建 Redux</h3><p>Redux 的精髓就是 Reducer，而利用 React Hooks 可以轻松创建一个 Redux 机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这就是 Redux</span><br><span class="line">function useReducer(reducer, initialState) &#123;</span><br><span class="line">  const [state, setState] = useState(initialState);</span><br><span class="line"></span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    const nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个自定义 Hook 的 value 部分当作 redux 的 state，setValue 部分当作 redux 的 dispatch，合起来就是一个 redux。而 react-redux 的 connect 部分做的事情与 Hook 调用一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 一个 Action</span><br><span class="line">function useTodos() &#123;</span><br><span class="line">  const [todos, dispatch] = useReducer(todosReducer, []);</span><br><span class="line"></span><br><span class="line">  function handleAddClick(text) &#123;</span><br><span class="line">    dispatch(&#123; type: &quot;add&quot;, text &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [todos, &#123; handleAddClick &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定 Todos 的 UI</span><br><span class="line">function TodosUI() &#123;</span><br><span class="line">  const [todos, actions] = useTodos();</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;todos.map((todo, index) =&gt; (</span><br><span class="line">        &lt;div&gt;&#123;todo.text&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      &lt;button onClick=&#123;actions.handleAddClick&#125;&gt;Add Todo&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 已经作为一个内置 Hooks 了，在这里可以查阅所有 <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">内置 Hooks</a>。</p><p>不过这里需要注意的是，每次 <code>useReducer</code> 或者自己的 Custom Hooks 都不会持久化数据，所以比如我们创建两个 App，App1 与 App2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function App1() &#123;</span><br><span class="line">  const [todos, actions] = useTodos();</span><br><span class="line"></span><br><span class="line">  return &lt;span&gt;todo count: &#123;todos.length&#125;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App2() &#123;</span><br><span class="line">  const [todos, actions] = useTodos();</span><br><span class="line"></span><br><span class="line">  return &lt;span&gt;todo count: &#123;todos.length&#125;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function All() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;App1 /&gt;</span><br><span class="line">      &lt;App2 /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个实例同时渲染时，并不是共享一个 todos 列表，而是分别存在两个独立 todos 列表。也就是 React Hooks 只提供状态处理方法，不会持久化状态。</p><p>如果要真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 <code>useReducer</code> 都会访问到同一份数据，可以和 <a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener">useContext</a> 一起使用。</p><p>大体思路是利用 <code>useContext</code> 共享一份数据，作为 Custom Hooks 的数据源。具体实现可以参考 <a href="https://github.com/facebookincubator/redux-react-hook/blob/master/src/index.ts" target="_blank" rel="noopener">redux-react-hook</a>。</p><h3 id="利用-useEffect-代替一些生命周期"><a href="#利用-useEffect-代替一些生命周期" class="headerlink" title="利用 useEffect 代替一些生命周期"></a>利用 useEffect 代替一些生命周期</h3><p>在 useState 位置附近，可以使用 useEffect 处理副作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const subscription = props.source.subscribe();</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // Clean up the subscription</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>useEffect</code> 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Component extends React.PureComponent&lt;Props, State&gt; &#123;</span><br><span class="line">  private chart: G2.Chart = null;</span><br><span class="line">  private rootDomRef: React.ReactInstance = null;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.rootDom = ReactDOM.findDOMNode(this.rootDomRef) as HTMLDivElement;</span><br><span class="line"></span><br><span class="line">    this.chart = new G2.Chart(&#123;</span><br><span class="line">      container: document.getElementById(&quot;chart&quot;),</span><br><span class="line">      forceFit: true,</span><br><span class="line">      height: 300</span><br><span class="line">    &#125;);</span><br><span class="line">    this.freshChart(this.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps: Props) &#123;</span><br><span class="line">    this.freshChart(nextProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    this.chart.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freshChart(props: Props) &#123;</span><br><span class="line">    // do something</span><br><span class="line">    this.chart.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;ref =&gt; (this.rootDomRef = ref)&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 React Hooks 可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const ref = React.useRef(null);</span><br><span class="line">  let chart: G2.Chart = null;</span><br><span class="line"></span><br><span class="line">  React.useEffect(() =&gt; &#123;</span><br><span class="line">    chart = new G2.Chart(&#123;</span><br><span class="line">      container: ReactDOM.findDOMNode(ref.current) as HTMLDivElement,</span><br><span class="line">      width: 500,</span><br><span class="line">      height: 500</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // do something</span><br><span class="line">    chart.render();</span><br><span class="line"></span><br><span class="line">    return () =&gt; chart.destroy();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return &lt;div ref=&#123;ref&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将细碎的代码片段结合成了一个完整的代码块，更易维护。</p><p>现在介绍了 <code>useState</code> <code>useContext</code> <code>useEffect</code> <code>useRef</code> 等常用 hooks，更多可以查阅：<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">内置 Hooks</a>，相信不久的未来，这些 API 又会成为一套新的前端规范。</p><h3 id="Hooks-带来的约定"><a href="#Hooks-带来的约定" class="headerlink" title="Hooks 带来的约定"></a>Hooks 带来的约定</h3><p>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。</p><p>为什么不能用 condition 包裹 useHook 语句，详情可以见 <a href="https://reactjs.org/docs/hooks-rules.html#explanation" target="_blank" rel="noopener">官方文档</a>，这里简单介绍一下。</p><p>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>），而是通过数组实现的，每次 <code>useState</code> 都会改变下标，如果 <code>useState</code> 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 <code>useState</code> 导出的 <code>setter</code> 更新错数据。</p><p>虽然有 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的<strong>代码命名和顺序限制</strong>（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。</p><p>笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！”</p><blockquote><p>React 约定大于配置脚手架 <a href="https://github.com/zeit/next.js" target="_blank" rel="noopener">nextjs</a> <a href="https://github.com/umijs/umi" target="_blank" rel="noopener">umi</a> 以及笔者的 <a href="https://github.com/prijs/pri" target="_blank" rel="noopener">pri</a> 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，<strong>那么 React Hooks 就像代码级别的约定</strong>，大大降低了代码复杂度。</p></blockquote><h3 id="状态与-UI-的界限会越来越清晰"><a href="#状态与-UI-的界限会越来越清晰" class="headerlink" title="状态与 UI 的界限会越来越清晰"></a>状态与 UI 的界限会越来越清晰</h3><p>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 <code>useEffect</code> 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。</p><p>不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useCount();</span><br><span class="line">  return &lt;span&gt;&#123;count&#125;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>useCount</code> 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Count&gt;&#123;(count, setCount) =&gt; &lt;App count=&#123;count&#125; setCount=&#123;setCount&#125; /&gt;&#125;&lt;/Count&gt;;</span><br><span class="line"></span><br><span class="line">function App(props) &#123;</span><br><span class="line">  return &lt;span&gt;&#123;props.count&#125;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 App 组件是无状态的，输出完全由输入（Props）决定。</p><p>那么有状态无 UI 的组件就是 <code>useCount</code> 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function useCount() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return [count, setCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态的地方应该指 <code>useState(0)</code> 这句，不过这句和无状态 UI 组件 App 的 <code>useCount()</code> 很像，既然 React 把 <code>useCount</code> 成为自定义 Hook，那么 <code>useState</code> 就是官方 Hook，具有一样的定义，因此可以认为 <code>useCount</code> 是无状态的，<code>useState</code> 也是一层 renderProps，最终的状态其实是 <code>useState</code> 这个 React 内置的组件。</p><p>我们看 renderProps 嵌套的表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;UseState&gt;</span><br><span class="line">  &#123;(count, setCount) =&gt; (</span><br><span class="line">    &lt;UseCount&gt;</span><br><span class="line">      &#123;&quot; &quot;&#125;</span><br><span class="line">      &#123;/**虽然是透传，但给 count 做了去重，不可谓没有作用 */&#125;</span><br><span class="line">      &#123;(count, setCount) =&gt; &lt;App count=&#123;count&#125; setCount=&#123;setCount&#125; /&gt;&#125;</span><br><span class="line">    &lt;/UseCount&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/UseState&gt;</span><br></pre></td></tr></table></figure><p>能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;React Hooks 是 React &lt;code&gt;16.7.0-alpha&lt;/code&gt; 版本推出的新特性，想尝试的同学安装此版本即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Hooks 要解决的问题是状态共享&lt;/strong&gt;，是继 &lt;a href=&quot;https://reactjs.org/docs/render-props.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;render-props&lt;/a&gt; 和 &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;higher-order components&lt;/a&gt; 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。&lt;/p&gt;
&lt;p&gt;状态共享可能描述的不恰当，称为&lt;strong&gt;状态逻辑复用&lt;/strong&gt;会更恰当，因为只共享数据处理逻辑，不会共享数据本身。&lt;/p&gt;
&lt;p&gt;为了更快理解 React Hooks 是什么，先看下面一段 renderProps 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function App() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;Toggle initial=&amp;#123;false&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;(&amp;#123; on, toggle &amp;#125;) =&amp;gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;Button type=&amp;quot;primary&amp;quot; onClick=&amp;#123;toggle&amp;#125;&amp;gt; Open Modal &amp;lt;/Button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;Modal visible=&amp;#123;on&amp;#125; onOk=&amp;#123;toggle&amp;#125; onCancel=&amp;#123;toggle&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      )&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/Toggle&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;恰巧，React Hooks 解决的也是这个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function App() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const [open, setOpen] = useState(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;Button type=&amp;quot;primary&amp;quot; onClick=&amp;#123;() =&amp;gt; setOpen(true)&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Open Modal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/Button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;Modal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        visible=&amp;#123;open&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onOk=&amp;#123;() =&amp;gt; setOpen(false)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onCancel=&amp;#123;() =&amp;gt; setOpen(false)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，&lt;strong&gt;这个组件是没有状态的&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 高阶组件</title>
    <link href="https://doubleray.top/2019/05/18/article-react-hoc/"/>
    <id>https://doubleray.top/2019/05/18/article-react-hoc/</id>
    <published>2019-05-18T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。</p><p>高阶组件的概念其实并不难，我们能通过类比高阶函数迅速掌握。高阶函数是把函数作为参数传入到函数中并返回一个新的函数。这里我们把函数替换为组件，就是高阶组件了。</p><p><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p><p>当然了解高阶组件的概念只是万里长征第一步，精读文章在阐述其概念与实现外，也强调了其重要性与局限性，以及与其他方案的比较，让我们一起来领略吧。</p><a id="more"></a><h1 id="2-内容概要"><a href="#2-内容概要" class="headerlink" title="2 内容概要"></a>2 内容概要</h1><p>高阶组件常见有两种实现方式，一种是 Props Proxy，它能够对 WrappedComponent 的 props 进行操作，提取 WrappedComponent state 以及使用其他元素来包裹 WrappedComponent。Props Proxy 作为一层代理，具有隔离的作用，因此传入 WrappedComponent 的 ref 将无法访问到其本身，需要在 Props Proxy 内完成中转，具体可参考以下代码，react-redux 也是这样实现的。</p><p>此外各个 Props Proxy 的默认名称是相同的，需要根据 WrappedComponent 来进行不同命名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现 HOC 不同的命名</span></span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;WrappedComponent.displayName&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">    getWrappedInstance() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.wrappedInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 ref 的访问</span></span><br><span class="line">    setWrappedInstance(ref) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrappedInstance = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;</span></span></span><br><span class="line"><span class="xml">        ...this.props,</span></span><br><span class="line"><span class="xml">        ref: this.setWrappedInstance.bind(this),</span></span><br><span class="line"><span class="xml">      &#125; /&gt;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">@ppHOC</span></span><br><span class="line"><span class="xml">class Example extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  static displayName = 'Example';</span></span><br><span class="line"><span class="xml">  handleClick() &#123; ... &#125;</span></span><br><span class="line"><span class="xml">  ...</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class App extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  handleClick() &#123;</span></span><br><span class="line"><span class="xml">    this.refs.example.getWrappedInstance().handleClick();</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">        &lt;Example ref="example" /&gt;</span><br><span class="line">      &lt;/div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种是 Inheritance Inversion，HOC 类继承了 WrappedComponent，意味着可以访问到 WrappedComponent 的 state、props、生命周期和 render 等方法。如果在 HOC 中定义了与 WrappedComponent 同名方法，将会发生覆盖，就必须手动通过 super 进行调用了。通过完全操作 WrappedComponent 的 render 方法返回的元素树，可以真正实现渲染劫持。这种方案依然是继承的思想，对于 WrappedComponent 也有较强的侵入性，因此并不常见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleEnhance</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">super</span>.componentDidMount();</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="keyword">super</span>.componentWillUnmount();</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h1><p>本次提出独到观点的同学有：<br><a href="https://www.zhihu.com/people/turbe-xue" target="_blank" rel="noopener">@monkingxue</a> <a href="https://github.com/alcat2008" target="_blank" rel="noopener">@alcat2008</a> <a href="https://www.zhihu.com/people/BlackGanglion" target="_blank" rel="noopener">@淡苍</a> <a href="https://www.zhihu.com/people/camsong" target="_blank" rel="noopener">@camsong</a>，精读由此归纳。</p><h2 id="HOC-的适用范围"><a href="#HOC-的适用范围" class="headerlink" title="HOC 的适用范围"></a>HOC 的适用范围</h2><p>对比 HOC 范式 <code>compose(render)(state)</code> 与父组件（Parent Component）的范式 <code>render(render(state))</code>，如果完全利用 HOC 来实现 React 的 implement，将操作与 view 分离，也未尝不可，但却不优雅。HOC 本质上是统一功能抽象，强调逻辑与 UI 分离。但在实际开发中，前端无法逃离 DOM ，而逻辑与 DOM 的相关性主要呈现 3 种关联形式：</p><ul><li>与 DOM 相关，建议使用父组件，类似于原生 HTML 编写</li><li>与 DOM 不相关，如校验、权限、请求发送、数据转换这类，通过数据变化间接控制 DOM，可以使用 HOC 抽象</li><li>交叉的部分，DOM 相关，但可以做到完全内聚，即这些 DOM 不会和外部有关联，均可</li></ul><p>DOM 的渲染适合使用父组件，这是 React JSX 原生支持的方式，清晰易懂。最好是能封装成木偶组件（Dumb Component）。HOC 适合做 DOM 不相关又是多个组件共性的操作。如 Form 中，validator 校验操作就是纯数据操作的，放到了 HOC 中。但 validator 信息没有放到 HOC 中。但如果能把 Error 信息展示这些逻辑能够完全隔离，也可以放到 HOC 中（可结合下一小节 Form 具体实践详细了解）。<br>数据请求是另一类 DOM 不相关的场景，<a href="https://github.com/heroku/react-refetch" target="_blank" rel="noopener">react-refetch</a> 的实现就是使用了 HOC，做到了高效和优雅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="function"><span class="params">props</span> =&gt;</span> (&#123;</span><br><span class="line">  usersFetch: <span class="string">`/users?status=<span class="subst">$&#123;props.status&#125;</span>&amp;page=<span class="subst">$&#123;props.page&#125;</span>`</span>,</span><br><span class="line">  userStatsFetch: &#123; <span class="attr">url</span>: <span class="string">`/users/stats`</span>, <span class="attr">force</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;))(UsersList)</span><br></pre></td></tr></table></figure><h2 id="HOC-的具体实践"><a href="#HOC-的具体实践" class="headerlink" title="HOC 的具体实践"></a>HOC 的具体实践</h2><p>HOC 在真实场景下的运行非常多，之前笔者在 <a href="https://zhuanlan.zhihu.com/p/22054582" target="_blank" rel="noopener">基于Decorator的组件扩展实践</a> 一文中也提过使用高阶组件将更细粒度的组件组合成 Selector 与 Search。结合精读文章，这次让我们通过 Form 组件的抽象来表现 HOC 具有的良好扩展机制。</p><p>Form 中会包含各种不同的组件，常见的有 Input、Selector、Checkbox 等等，也会有根据业务需求加入的自定义组件。Form 灵活多变，从功能上看，表单校验可能为单组件值校验，也可能为全表单值校验，可能为常规检验，比如：非空、输入限制，也可能需要与服务端配合，甚至需要根据业务特点进行定制。从 UI 上看，检验结果显示的位置，可能在组件下方，也可能是在组件右侧。</p><p>直接裸写 Form，无疑是机械而又重复的。将 Form 中组件的 value 经过 validator，把 value，validator 产生的 error 信息储存到 state 或 redux store 中，然后在 view 层完成显示。这条路大家都是相同的，可以进行复用，只是我们面对的是不同的组件，不同的 validator，不同的 view 而已。对于 Form 而言，既要满足通用，又要满足部分个性化的需求，以往单纯的配置化只会让使用愈加繁琐，我们所需要抽象的是 Form 功能而非 UI，因此通过 HOC 针对 Form 的功能进行提取就成为了必然。</p><p><img src="https://user-images.githubusercontent.com/9314735/27116337-3f1f16a8-5103-11e7-8dc6-c7197e1b1eab.png" alt="image"></p><p>至于 HOC 在 Form 上的具体实现，首先将表单中的组件（Input、Selector…）与相应 validator 与组件值回调函数名（trigger）传入 Decorator，将 validator 与 trigger 相绑定。Decorator 完成了各种不同组件与 Form 内置 Store 间 value 的传递、校验功能的抽象，即精读文章中提到 Props Proxy 方式的其中两种作用：<strong>提取state</strong> 与 <strong>操作props</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formFactoryFactory</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  validator,</span></span></span><br><span class="line"><span class="function"><span class="params">  trigger = <span class="string">'onChange'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FormFactory(WrappedComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      getBind(trigger, validator) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">          ...this.props,</span><br><span class="line">          [trigger]: <span class="keyword">this</span>.getBind(trigger, validator),</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 调用</span></span><br><span class="line"><span class="xml">formFactoryFactory(&#123;</span></span><br><span class="line"><span class="xml">  validator: (value) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    return value !== '';</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line">&#125;)(&lt;Input placeholder="请输入..." /&gt;)</span><br></pre></td></tr></table></figure><p>当然为了考虑个性化需求，Form Store 也向外暴露很多 API，可以直接获取和修改 value、error 的值。现在我们需要对一个表单的所有值提交到后端进行校验，根据后端返回，分别列出各项的校验错误信息，就需要借助相应项的 setError 去完成了。</p><p>这里主要参考了 <a href="https://github.com/react-component/form" target="_blank" rel="noopener">rc-form</a> 的实现方式，有兴趣的读者可以阅读其源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createForm &#125; <span class="keyword">from</span> <span class="string">'rc-form'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  submit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.form.validateFields(<span class="function">(<span class="params">error, value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getFieldError, getFieldDecorator &#125; = <span class="keyword">this</span>.props.form;</span><br><span class="line">    <span class="keyword">const</span> errors = getFieldError(<span class="string">'required'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;getFieldDecorator(<span class="string">'required'</span>, &#123;</span><br><span class="line">          rules: [&#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        &#125;)(<span class="xml"><span class="tag">&lt;<span class="name">Input</span> /&gt;</span>)&#125;</span></span><br><span class="line"><span class="xml">        &#123;errors ? errors.join(',') : null&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submit&#125;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> createForm()(Form);</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>React 始终强调组合优于继承的理念，期望通过复用小组件来构建大组件使得开发变得简单而又高效，与传统面向对象思想是截然不同的。高阶函数（HOC）的出现替代了原有 Mixin 侵入式的方案，对比隐式的 Mixin 或是继承，HOC 能够在 Devtools 中显示出来，满足抽象之余，也方便了开发与测试。当然，不可过度抽象是我们始终要秉持的原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h1&gt;&lt;p&gt;高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。&lt;/p&gt;
&lt;p&gt;高阶组件的概念其实并不难，我们能通过类比高阶函数迅速掌握。高阶函数是把函数作为参数传入到函数中并返回一个新的函数。这里我们把函数替换为组件，就是高阶组件了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const EnhancedComponent = higherOrderComponent(WrappedComponent);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然了解高阶组件的概念只是万里长征第一步，精读文章在阐述其概念与实现外，也强调了其重要性与局限性，以及与其他方案的比较，让我们一起来领略吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>setState 做了什么</title>
    <link href="https://doubleray.top/2019/04/13/article-react-setstate/"/>
    <id>https://doubleray.top/2019/04/13/article-react-setstate/</id>
    <published>2019-04-13T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p><code>setState</code> 是 React 框架最常用的命令，它是用来更新状态的，这也是 React 框架划时代的功能。</p><p>但是 <code>setState</code> 函数是 <code>react</code> 包导出的，他们又是如何与 <code>react-dom</code> <code>react-native</code> <code>react-art</code> 这些包结合的呢？</p><a id="more"></a><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h1><p><code>setState</code> 函数是在 <code>React.Component</code> 组件中调用的，所以最自然的联想是，更新 DOM 的逻辑在 <code>react</code> 包中实现。</p><p>但是 <code>react</code> 却可以和 <code>react-dom</code> <code>react-native</code> <code>react-art</code> 这些包打配合，甚至与 <code>react-dom/server</code> 配合在服务端运行，那可以肯定 <code>react</code> 包中不含有 DOM 更新逻辑。</p><p>所以可以推断，<strong>平台相关的 UI 更新逻辑分布在平台相关的包里，<code>react</code> 包只做了代理。</strong></p><h2 id="React-引擎不在-react-包里"><a href="#React-引擎不在-react-包里" class="headerlink" title="React 引擎不在 react 包里"></a>React 引擎不在 react 包里</h2><p>从 react 0.14 版本之后，引擎代码就从 react 包中抽离了，react 包仅仅做通用接口抽象。</p><p>也就是说，react 包定义了标准的状态驱动模型的 API，而 <code>react-dom</code> <code>react-native</code> <code>react-art</code> 这些包是在各自平台的具体实现。</p><p>各平台具体的渲染引擎实现被称为 <a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">reconciler</a>，通过这个链接可以看到 <code>react-dom</code> <code>react-native</code> <code>react-art</code> 这三个包的 reconciler 实现。</p><p>这说明了 react 包仅告诉你 React 拥有哪些语法，而并不关心如何实现他们，所以我们需要结合 react 包与 react-xxx 一起使用。</p><p>对于 <code>context</code>，react 包仅仅会做如下定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bit simplified</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContext</span>(<span class="params">defaultValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = &#123;</span><br><span class="line">    _currentValue: defaultValue,</span><br><span class="line">    Provider: <span class="literal">null</span>,</span><br><span class="line">    Consumer: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  context.Provider = &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>.for(<span class="string">"react.provider"</span>),</span><br><span class="line">    _context: context</span><br><span class="line">  &#125;;</span><br><span class="line">  context.Consumer = &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>.for(<span class="string">"react.context"</span>),</span><br><span class="line">    _context: context</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体用到时，由 <code>react-dom</code> 和 <code>react-native</code> 决定用何种方式实现 <code>MyContext.Provider</code> 这个 API。</p><p>这也说明了，如果你不同步升级 <code>react</code> 与 <code>react-dom</code> 版本的话，就可能碰到这样的报错：<a href="https://stackoverflow.com/questions/49662743/context-components-in-react-16-3-are-invalid/49677020#49677020" target="_blank" rel="noopener">fail saying these types are invalid</a>，原因是 API 定义与实现不匹配。</p><h2 id="setState-怎么调用平台实现"><a href="#setState-怎么调用平台实现" class="headerlink" title="setState 怎么调用平台实现"></a>setState 怎么调用平台实现</h2><p>每个平台对 UI 更新逻辑的实现，会封装在 <code>updater</code> 函数里，所以不同平台代码会为组件添加各自的 <code>updater</code> 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React DOM</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactDOMUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside React DOM Server</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactDOMServerUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside React Native</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactNativeUpdater;</span><br></pre></td></tr></table></figure><p>不同于 <code>props</code>, <code>updater</code> 无法被直接调用，因为这个 API 是由 react 引擎在 <code>setState</code> 时调用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bit simplified</span></span><br><span class="line">setState(partialState, callback) &#123;</span><br><span class="line">  <span class="comment">// Use the `updater` field to talk back to the renderer!</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系可以这么描述：<code>react</code> -&gt; setState -&gt; updater &lt;- <code>react-dom</code> 等。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Hooks 的原理与 <code>setState</code> 类似，当调用 <code>useState</code> 或 <code>useEffect</code> 时，其内部调用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In React (simplified a bit)</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  <span class="comment">// Real property is hidden a bit deeper, see if you can find it!</span></span><br><span class="line">  __currentDispatcher: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  useState(initialState) &#123;</span><br><span class="line">    <span class="keyword">return</span> React.__currentDispatcher.useState(initialState);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  useEffect(initialState) &#123;</span><br><span class="line">    <span class="keyword">return</span> React.__currentDispatcher.useEffect(initialState);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ReactDOM 提供了 <code>__currentDispatcher</code>（简化的说法）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In React DOM</span></span><br><span class="line"><span class="keyword">const</span> prevDispatcher = React.__currentDispatcher;</span><br><span class="line">React.__currentDispatcher = ReactDOMDispatcher;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = YourComponent(props);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Restore it back</span></span><br><span class="line">  React.__currentDispatcher = prevDispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Hooks 的原理与 <code>setState</code> 基本一致，但需要注意 <code>react</code> 与 <code>react-dom</code> 之间传递了 <code>dispatch</code>，虽然你看不到。但这个 <code>dispatch</code> 必须对应到唯一的 React 实例，这就是为什么 Hooks 不允许同时加载多个 React 实例的原因。</p><p>和 <code>updater</code> 一样，<code>dispatch</code> 也可以被各平台实现重写，比如 <code>react-debug-hooks</code> 就重写了 <a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214" target="_blank" rel="noopener">dispatcher</a>。</p><p>由于需要同时实现 <code>readContext</code>, <code>useCallback</code>, <code>useContext</code>, <code>useEffect</code>, <code>useImperativeMethods</code>, <code>useLayoutEffect</code>, <code>useMemo</code>, <code>useReducer</code>, <code>useRef</code>, <code>useState</code>，工程量比较浩大，建议了解基本架构就足够了，除非你要深入参与 React 生态建设。</p><h1 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h1><p>与其他 React 分析文章不同，本文并没有过于刨根问题的上来就剖析 <a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">reconciler</a> 实现，而是问了一个最基本的疑问：为什么 <code>setState</code> 来自 <code>react</code> 包，但实现却在 <code>react-dom</code> 里？React 是如何实现这个 magic 的？</p><p>通过这个疑问，我们了解了 React 更上层的抽象能力，如何用一个包制定规范，用 N 包去实现它。</p><h2 id="接口的力量"><a href="#接口的力量" class="headerlink" title="接口的力量"></a>接口的力量</h2><p>在日常编程中，接口也拥有的强大力量，下面举几个例子。</p><h3 id="UI-组件跨三端的接口"><a href="#UI-组件跨三端的接口" class="headerlink" title="UI 组件跨三端的接口"></a>UI 组件跨三端的接口</h3><p>由于 RN、Weex、Flutter 的某些不足，越来越多的人选择 “一个思想三端实现” 的方式做跨三端的 UI 组件，这样既兼顾了性能，又可以照顾到平台差异性，对不同平台组件细节做定制优化。</p><p>要实施这个方案，最大问题就是接口约定。一定要保证三套实现遵循同一套 API 接口，业务代码才可以实现 “针对任意一个平台编写，自动移植到其他平台”。</p><p>比较常用的做法是，通过一套统一的 API 文件约束，固定组件的输入输出，不同平台的组件做平台具体实现。这个思想和 React 如出一辙。</p><blockquote><p>当然 RN 这些框架本身也是同一接口在不同平台实现的典型，只是做的不够彻底，JS 与 Native 的通信导致了性能不如原生。</p></blockquote><h3 id="通用数据查询服务"><a href="#通用数据查询服务" class="headerlink" title="通用数据查询服务"></a>通用数据查询服务</h3><p>通用数据查询服务也比较流行，通过磨平各数据库语法，让用户通过一套 SQL 查询各种类型数据库的数据。</p><p>这个方案中，一套通用的查询语法就类似 React 定义的 API，执行阶段会转化为各数据库平台的 SQL 方言。</p><h3 id="小程序融合方案"><a href="#小程序融合方案" class="headerlink" title="小程序融合方案"></a>小程序融合方案</h3><p>现在这种方案很火。通过基于 template 或者 jsx 的语法，一键发布到各平台小程序应用。</p><p>这种方案一定会抽象一套通用语法，甚至几乎等价与 <code>react</code> 与 <code>react-dom</code> 的关系：所有符合规范的语法，转化为各小程序平台的实现。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>这种分平台实现方案与跨平台方案还是有很大区别的，像 JAVA 虚拟机本质还是一套实现方案。而分平台的实现可以带来最原生的性能与体验，同样收到的约束也最大，应该其 API 应该是所有平台支持的一个子集。</p><p>另外，这种方案不仅可以用于 一套规范，不同平台的实现，甚至可以用在 “同一平台的实现”。</p><p>无论是公司还是开源节界，都有许多重复的轮子或者平台，如果通过技术委员会约定一套平台的实现规范，大家都遵循这个规范开发平台，那未来就比较好做收敛，或者说收敛的第一步都是先统一 API 规范。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;setState&lt;/code&gt; 是 React 框架最常用的命令，它是用来更新状态的，这也是 React 框架划时代的功能。&lt;/p&gt;
&lt;p&gt;但是 &lt;code&gt;setState&lt;/code&gt; 函数是 &lt;code&gt;react&lt;/code&gt; 包导出的，他们又是如何与 &lt;code&gt;react-dom&lt;/code&gt; &lt;code&gt;react-native&lt;/code&gt; &lt;code&gt;react-art&lt;/code&gt; 这些包结合的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 的多态性</title>
    <link href="https://doubleray.top/2019/03/09/article-react-surprising-polymorphism/"/>
    <id>https://doubleray.top/2019/03/09/article-react-surprising-polymorphism/</id>
    <published>2019-03-09T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>参考的文章是：<a href="https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc" target="_blank" rel="noopener">surprising-polymorphism-in-react-applications</a>，看看作者是如何解释这个多态性含义的。</p><p>读完文章才发现，文章标题改为 Redux 的多态性更妥当，因为整篇文章都在说 Redux，而 Redux 使用场景不局限于 React。</p><a id="more"></a><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><p>Redux immutable 特性可能产生浏览器无法优化的性能问题，也就是浏览器无法做 <a href="https://github.com/dt-fe/weekly/blob/master/62.%E7%B2%BE%E8%AF%BB%E3%80%8AJS%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%20Shapes%20and%20Inline%20Caches%E3%80%8B.md#shapes" target="_blank" rel="noopener">shapes 优化</a>，也就是上一篇精读《JS 引擎基础之 Shapes and Inline Caches》 里提到的。</p><p>先看看普通的 redux 的 reducer：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todo = <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ADD_TODO"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"TOGGLE_TODO"</span>:</span><br><span class="line">      <span class="keyword">if</span> (state.id !== action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        completed: !state.completed</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们简化一下使用场景，假设基于这个 reducer <code>todo</code>，生成了两个新 store <code>s1</code> <code>s2</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = todo(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    text: <span class="string">"Finish blog post"</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = todo(s1, &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"TOGGLE_TODO"</span>,</span><br><span class="line">  id: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看上去很常见，也的确如此，我们每次 dispatch 都会根据 reducer 生成新的 store 树，而且是一个新的对象。然而对 js 引擎而言，这样的代码可能做不了 Shapes 优化（关于 Shapes 优化建议阅读上一期精读 <a href="https://github.com/dt-fe/weekly/blob/master/62.%E7%B2%BE%E8%AF%BB%E3%80%8AJS%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%20Shapes%20and%20Inline%20Caches%E3%80%8B.md#shapes" target="_blank" rel="noopener">Shapes 优化</a>），也就是最需要做优化的全局 store，在生成新 store 时无法被浏览器优化，这个问题很容易被忽视，但的确影响不小。</p><p>至于为什么会阻止 js 引擎的 shapes 优化，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transition-trees.js</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;;</span><br><span class="line">b.x = <span class="number">1</span>;</span><br><span class="line">b.y = <span class="number">2</span>;</span><br><span class="line">b.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a is"</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b is"</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a and b have same map:"</span>, %HaveSameMap(a, b));</span><br></pre></td></tr></table></figure><p>通过 <code>node --allow-natives-syntax test.js</code> 执行，通过调用 node 原生函数 <code>%HaveSameMap</code> 判断这种情况下 <code>a</code> 与 <code>b</code> 是否共享一个 shape（v8 引擎的 Shape 实现称为 Map）。</p><p><img src="https://user-images.githubusercontent.com/7970947/42121947-089a1796-7c6c-11e8-89de-3eaaf81eb02e.png" alt="image"></p><p>结果是 <code>false</code>，也就是 js 引擎无法对 <code>a</code> <code>b</code> 做 Shapes 优化，这是因为 <code>a</code> 与 <code>b</code> 对象初始化的方式不同。</p><p>同样，在 Redux 代码中常用的 <code>Object.assign</code> 也有这个问题：</p><p><img src="https://user-images.githubusercontent.com/7970947/42121964-55d0f3ae-7c6c-11e8-9d6e-995cac2f83d3.png" alt="image"></p><p>因为新的对象以 <code>{}</code> 空对象作为最初状态，js 引擎会为新对象创建 Empty Shape，这与原对象的 Shape 一定不同。</p><p>顺带一提 es6 的解构语法也存在同样的问题，因为 <code>babel</code> 将解构最终解析为 <code>Object.assign</code>：</p><p><img src="https://user-images.githubusercontent.com/7970947/42121971-9c0bb8d6-7c6c-11e8-85ed-e15f27654d5b.png" alt="image"></p><p>对这种尴尬的情况，作者的建议是对所有对象赋值时都是用 <code>Object.assign</code> 以保证 js 引擎可以做 Shapes 优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a is"</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b is"</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a and b have same map:"</span>, %HaveSameMap(a, b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>这篇文章需要与上一篇 <a href="https://github.com/dt-fe/weekly/blob/master/62.%E7%B2%BE%E8%AF%BB%E3%80%8AJS%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%20Shapes%20and%20Inline%20Caches%E3%80%8B.md" target="_blank" rel="noopener">精读《JS 引擎基础之 Shapes and Inline Caches》</a> 连起来看容易理解。</p><p>作者描述的性能问题是引擎级别的 Shapes 优化问题，读过上篇精读就很容易知道，只有相同初始化方式的对象才被 js 引擎做优化，而 Redux 频繁生成的 immutable 全局 store 是否能被优化呢？答案是“往往不能”，因为 immutable 赋值问题，我们往往采用 <code>Object.assign</code> 或者解构方式赋值，这种方式产生的新对象与原对象的 Shape 不同，导致 Shape 无法复用。</p><p>这里解释一下疑惑，为什么说 immutable 对象之间也要优化呢？这不是两个不同的引用吗？这是因为 js 引擎级别的 Shapes 优化就是针对不同引用的对象，将对象的结构：Shape 与数据分离开，这样可以大幅优化存储效率，对数组也一样，上一篇精读有详细介绍。</p><p>所以笔者更推荐使用比如 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">immutable-js</a> 这种库操作 immutable 对象，而不是 Object.assign，因为封装库内部是可能通过统一对象初始化方式利用 js 引擎进行优化的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>原文提到的多态是指多个相同结构对象，被拆分成了多个 Shape；而单态是指这些对象可以被一个 Shape 复用。</p><p>笔者以前也经历过从 <code>Object.assign</code> 到 Immutablejs 库，最后又回到解构新语法的经历，觉得在层级不深情况下解构语法可以代替 Immutablejs 库。</p><p>通过最近两篇精读的分析，我们需要重新思考这样做带来的优缺点，因为在 js 环境中，<code>Object.assign</code> 的优化效率比 Immutablejs 库更低。</p><p>最后，也完全没必要现在就开始重构，因为这只是 js 运行环境中很小一部分影响因素，比如为了引入 Immutablejs 让你的网络延时增加了 100%？所以仅在有必要的时候优化它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;参考的文章是：&lt;a href=&quot;https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;surprising-polymorphism-in-react-applications&lt;/a&gt;，看看作者是如何解释这个多态性含义的。&lt;/p&gt;
&lt;p&gt;读完文章才发现，文章标题改为 Redux 的多态性更妥当，因为整篇文章都在说 Redux，而 Redux 使用场景不局限于 React。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 八种条件渲染</title>
    <link href="https://doubleray.top/2019/02/23/article-react-condition-render/"/>
    <id>https://doubleray.top/2019/02/23/article-react-condition-render/</id>
    <published>2019-02-23T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p><a href="https://blog.logrocket.com/conditional-rendering-in-react-c6b0e5af381e" target="_blank" rel="noopener">8 React conditional rendering methods</a></p><p>介绍了八种 React 条件渲染方式。</p><p>模板条件渲染非常常见，遇到的时候往往会随机选择一种方式使用，那么怎么写会有较好的维护性呢？先一起了解下有哪八种条件渲染方式吧！</p><a id="more"></a><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><h3 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF/ELSE"></a>IF/ELSE</h3><p>既然 JSX 支持 js 与 html 混写，那么交替使用就能解决条件渲染的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  if (renderComponent1) &#123;</span><br><span class="line">    return &lt;Component1 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &lt;div /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="return-null"><a href="#return-null" class="headerlink" title="return null"></a>return <code>null</code></h3><p>如果不想渲染空元素，最好使用 <code>null</code> 代替空的 <code>div</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  if (renderComponent1) &#123;</span><br><span class="line">    return &lt;Component1 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样对 React 渲染效率有提升。</p><h3 id="组件变量"><a href="#组件变量" class="headerlink" title="组件变量"></a>组件变量</h3><p>将组件赋值到变量，就可以在 return 前任意修改它了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  let component = null;</span><br><span class="line"></span><br><span class="line">  if (renderComponent1) &#123;</span><br><span class="line">    component = &lt;Component1 /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><a href="https://en.wikipedia.org/wiki/%3F:" target="_blank" rel="noopener">三元运算符</a>的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr_if_true : expr_if_false</span><br></pre></td></tr></table></figure><p>用在 JSX 上也很方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  return renderComponent1 ? &lt;Component1 /&gt; : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但三元运算符产生嵌套时，理解成本会变得很高。</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>这个是最常用了，因为代码量最少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  return renderComponent1 &amp;&amp; &lt;Component1 /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>IIFE 含义是立即执行函数，也就是如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"><span class="comment">/* arguments */</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(<span class="comment">/* arguments */</span>);</span><br></pre></td></tr></table></figure><p>当深陷 JSX 代码中，又想写一大块逻辑时，除了回到上方，还可以使用 IIFE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;(() =&gt; &#123;</span><br><span class="line">        if (renderComponent1) &#123;</span><br><span class="line">          return &lt;Component1 /&gt;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return &lt;div /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)()&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><p>这是 IIFE 的变种，也就是把这段立即执行函数替换成一个普通函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SubRender /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubRender() &#123;</span><br><span class="line">  if (renderComponent1) &#123;</span><br><span class="line">    return &lt;Component1 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &lt;div /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IF-组件"><a href="#IF-组件" class="headerlink" title="IF 组件"></a>IF 组件</h3><p>做一个条件渲染组件 <code>IF</code> 代替 js 函数的 <code>if</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;If condition=&#123;true&#125;&gt;</span><br><span class="line">  &lt;span&gt;Hi!&lt;/span&gt;</span><br><span class="line">&lt;/If&gt;</span><br></pre></td></tr></table></figure><p>这个组件实现也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const If = props =&gt; &#123;</span><br><span class="line">  const condition = props.condition || false;</span><br><span class="line">  const positive = props.then || null;</span><br><span class="line">  const negative = props.else || null;</span><br><span class="line"></span><br><span class="line">  return condition ? positive : negative;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>高阶组件，就是返回一个新组件的函数，并且接收一个组件作为参数。</p><p>那么我们就能在高阶组件里写条件语句，返回不同的组件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function higherOrderComponent(Component) &#123;</span><br><span class="line">  return function EnhancedComponent(props) &#123;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">      return &lt;AnotherComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>这么多方法都能实现条件渲染，那么重点在于可读性与可维护性。</p><p>比如通过调用函数实现组件渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;renderButton()&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>看上去还是比较冗余，如果使用 <code>renderButton</code> getter 定义，我们就可以这么写它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;button&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>其实我们想要的就是 button，而不是 <code>renderButton</code>。那么还可以进一步，干脆封装成 JSX 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Button /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>是否要付出这些努力，取决于应用的复杂度。如果应用复杂度非常高，那你应当尽量使用最后一种封装，让每个文件的逻辑尽量独立、简单。</p><p>如果应用复杂度比较低，那么注意不要过度封装，以免把自己绕进去。</p><p>所以看来这又是一个没有固定答案的问题，选择何种方式封装，取决于应用复杂度。</p><h3 id="应用复杂度"><a href="#应用复杂度" class="headerlink" title="应用复杂度"></a>应用复杂度</h3><p>对任何代码封装，都会增加这段 <strong>连接逻辑</strong> 的复杂度。</p><p>假定无论如何代码的复杂度都是恒定不变的，下面这段代码，连接复杂度为 0，而对于 <code>render</code> 函数而言，逻辑复杂度是 100：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  if (renderComponent) &#123;</span><br><span class="line">    return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &lt;div /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段代码拆成了两个函数，逻辑复杂度对 <code>render</code> <code>SubComponent</code> 来说都是 50，但连接复杂度是 50：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (renderComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;SubComponent&gt;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们通过函数拆分，降低了每个函数的逻辑复杂度，但却提高了连接复杂度。</p><p>下面来做一个比较，我们假设一个正常的程序员，可以一次性轻松记忆 10 个函数。如果再多，函数之间的调用关系就会让人摸不着头脑。</p><h4 id="应用较小时"><a href="#应用较小时" class="headerlink" title="应用较小时"></a>应用较小时</h4><p>在应用代码量比较小时，假设一共有 10 个函数，如果做了逻辑抽象，拆分出了 10 个子函数，那么总逻辑复杂度不变，函数变成了 20 个。</p><p>此时小王要修改此项目，他需要找到关键代码的位置。</p><p>如果没有做逻辑抽象，小王一下子就记住了 10 个函数，并且很快完成了需求。</p><p>如果应用做了逻辑抽象，他需要理解的逻辑复杂度是不变的，但是要读的函数变成了 20 个。小王需要像侦探一样在线索中不断跳转，他还是只找了 10 个关键函数，但一共也就 20 个函数，逻辑并不复杂，这值得吗？</p><p>小王心里可能会嘀咕：简单的逻辑瞎抽象，害我文件找了半天！</p><h4 id="应用较大时"><a href="#应用较大时" class="headerlink" title="应用较大时"></a>应用较大时</h4><p>此时应用代码量比较大，假设一共有 500 个函数，我们不考虑抽象后带来的复用好处，假设都无法复用，那么做了逻辑抽象后，那么总逻辑复杂度不变，函数变成了 1000 个。</p><p>此时小王接到了需求，终于维护了一个大项目。</p><p>小王知道这个项目很复杂，从一开始就没觉得能理解项目全貌，所以把自己当作一名侦探，准备一步步探索。</p><p>现在有两种选择，一种是在未做逻辑抽象时探索，一种是在做过逻辑抽象后探索。</p><p>如果没做逻辑抽象，小王需要面对 <code>500</code> 个这种函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  if (renderComponent) &#123;</span><br><span class="line">    return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return isReady ? &lt;Component3 /&gt; : &lt;Component4 /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果做了逻辑抽象，小王需要面对 <code>1000</code> 个这种函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  if (renderComponent) &#123;</span><br><span class="line">    return &lt;Component1And2 /&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &lt;Component3And4 /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目庞大后，总函数数量并不会影响对线索的查找，而总线索深度也几乎总是固定的，一般在 5 层左右。</p><p>小王理解 5 个或 10 个函数成本都差不多，但没有做逻辑抽象时，这 5 个函数各自参杂了其他逻辑，反而影响对函数的理解。</p><p>这时做逻辑抽象是合适的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>所以总的来说，笔者更倾向使用子函数、子组件、IF 组件、高阶组件做条件渲染，因为这四种方式都能提高程序的抽象能力。</p><p>往往抽象后的代码会更具有复用性，单个函数逻辑更清晰，在切面编程时更利于理解。</p><p>当项目很简单时，整个项目的理解成本都很低，抽象带来的复杂度反而让项目变成了需要切面编程的时候，就得不偿失了。</p><p>总结一下：</p><ul><li>当项目很简单，或者条件渲染的逻辑确认无法复用时，推荐在代码中用 <code>&amp;&amp;</code> 或者三元运算符、IIFE 等直接实现条件渲染。</li><li>当项目很复杂时，尽量都使用 子函数、子组件、IF 组件、高阶组件 等方式做更有抽象度的条件渲染。</li><li>在做逻辑抽象时，考虑下项目的复杂度，避免因为抽象带来的成本增加，让本可以整体理解的项目变得支离破碎。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.logrocket.com/conditional-rendering-in-react-c6b0e5af381e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;8 React conditional rendering methods&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍了八种 React 条件渲染方式。&lt;/p&gt;
&lt;p&gt;模板条件渲染非常常见，遇到的时候往往会随机选择一种方式使用，那么怎么写会有较好的维护性呢？先一起了解下有哪八种条件渲染方式吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 代码整洁之道</title>
    <link href="https://doubleray.top/2019/01/26/article-react-clean/"/>
    <id>https://doubleray.top/2019/01/26/article-react-clean/</id>
    <published>2019-01-26T05:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>编程也是艺术行为，当我们思考代码复用、变量命名时，就是在进行艺术思考。</p><p>可能这篇文章没法提高面试能力、开发效率，因为涉及的内容都是 “软能力”。但如果与我一样，时常害怕自己代码不够优雅，那就在茶余饭后看看这篇文章，也许，可以解决一部分你心中的困惑。</p><a id="more"></a><h2 id="2-内容概要"><a href="#2-内容概要" class="headerlink" title="2 内容概要"></a>2 内容概要</h2><p>作者整理了几个好的思维习惯，尝试认同它，再看看如何实践。</p><h3 id="不冗余"><a href="#不冗余" class="headerlink" title="不冗余"></a>不冗余</h3><p>避免重复代码段，对 JSX 同理：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;OtherComponent <span class="keyword">type</span>=<span class="string">"a"</span> className=<span class="string">"colorful"</span> foo=&#123;<span class="number">123</span>&#125; bar=&#123;<span class="number">456</span>&#125; /&gt;</span><br><span class="line">    &lt;OtherComponent <span class="keyword">type</span>=<span class="string">"b"</span> className=<span class="string">"colorful"</span> foo=&#123;<span class="number">123</span>&#125; bar=&#123;<span class="number">456</span>&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Clean</span></span><br><span class="line"><span class="regexp">const MyOtherComponent = (&#123; type &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;OtherComponent type=&#123;type&#125; className="colorful" foo=&#123;123&#125; bar=&#123;456&#125; /</span>&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyOtherComponent <span class="keyword">type</span>=<span class="string">"a"</span> /&gt;</span><br><span class="line">    &lt;MyOtherComponent <span class="keyword">type</span>=<span class="string">"b"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>但也不要过度优化，过度优化和搞破坏没什么区别。</p><h3 id="可预测、可测试"><a href="#可预测、可测试" class="headerlink" title="可预测、可测试"></a>可预测、可测试</h3><p>如果使用 <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a> 测试，可以考虑截图测试插件：<a href="https://github.com/americanexpress/jest-image-snapshot" target="_blank" rel="noopener">Jest Image Snapshot</a></p><h3 id="自我解释"><a href="#自我解释" class="headerlink" title="自我解释"></a>自我解释</h3><p>尽可能减少代码中的注释。可以通过让变量名更语义化、只注释复杂、潜在逻辑，来减少注释量，同时也提高了可维护性，毕竟不用总在代码与注释之间同步了。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">id</span>) =&gt;</span> (</span><br><span class="line">  fetch(buildUri<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>) <span class="comment">// Get User DTO record from REST API</span></span><br><span class="line">    .then(convertFormat) <span class="comment">// Convert to snakeCase</span></span><br><span class="line">    .then(validateUser) <span class="comment">// Make sure the the user is valid</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> fetchUser = <span class="function">(<span class="params">id</span>) =&gt;</span> (</span><br><span class="line">  fetch(buildUri<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">    .then(snakeToCamelCase)</span><br><span class="line">    .then(validateUser)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的例子，方法 <code>convertFormat</code> 含义是 “转换格式”，太过于笼统，以至于不得不添加注释。如果换成 <code>snakeToCamelCase</code> （转换为驼峰风格），这个名字就解释了自己的功能。</p><h3 id="斟酌变量名"><a href="#斟酌变量名" class="headerlink" title="斟酌变量名"></a>斟酌变量名</h3><blockquote><p>布尔值或者返回值是布尔类型的函数，命名以 <code>is</code> <code>has</code> <code>should</code> 开头：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> done = current &gt;= goal;</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> isComplete = current &gt;= goal;</span><br></pre></td></tr></table></figure><blockquote><p>函数以其效果命名，而不是怎么做的来命名</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> loadConfigFromServer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> loadConfig = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很多时候我也经常犯这种错误，毕竟写代码的时候总要考虑实现，一不小心就将实现的方式带入了函数名中。</p><h3 id="遵循设计模式"><a href="#遵循设计模式" class="headerlink" title="遵循设计模式"></a>遵循设计模式</h3><p>这里的设计模式，并不是指工程上的，而是更广泛的开发中的设计模式，比如 “你应该使用 tslint 校验代码格式” “typescript 开启 stricts 模式” “编写一个 React 函数，应当将 React 作为 <code>peerDependency</code>” 等等（当然，不要随意设置 <code>peerDependency</code> 也是一种江湖约定）。</p><p>对于 React，遵循以下几个最佳实践：</p><ul><li>单一责任原则, 确保每个功能都完整完成一项功能，比如更细粒度的组件拆分，同时也更利于测试。</li><li>不要把组件的内部依赖强加给使用方。</li><li>lint 规则尽量严格。</li></ul><p>根据我的体验，尤为痛恨违背第二条的组件，<strong>比如当 React 组件使用了数据流，但必须依赖项目初始化该数据流才能执行，如果不是被生活所迫，我才不会使用这种组件。</strong></p><p>第三条也一样，<strong>如果你是一个知名轮子的作者，请毫不留情的使用最严格的 lint 规则。如果使用者的 lint 规则比你还严格，你的组件将无法使用。</strong></p><h3 id="考虑到以上几点并不会降低编码速度"><a href="#考虑到以上几点并不会降低编码速度" class="headerlink" title="考虑到以上几点并不会降低编码速度"></a>考虑到以上几点并不会降低编码速度</h3><p>编写整洁的代码在开始一定会放慢开发速度，因为你需要转变自己的思维模式，但随着不断迭代，它的带来的效率提升会逐渐弥补前面的损失，并不断带来开发效率的提升。</p><p>写组件库也是同理，用脚写固然能快速完成，但后续往往要重构掉。我很羡慕函数式工作环境的开发者，他们几乎只要为每个功能写一遍，剩下的就是记住并调用它。</p><h3 id="在-React-中的实践"><a href="#在-React-中的实践" class="headerlink" title="在 React 中的实践"></a>在 React 中的实践</h3><p>略过几个没意思的例子。。</p><blockquote><p>在 React 使用 defaultProps 代替在代码中动态判断</p></blockquote><p>显然，利用 React 组件的规则，将入参的默认值预先定义好是最高效的。但顺带一句，如果在 ts 最严格的 <code>stricts</code> 模式里，依然会报错：变量可能未定义。这是因为 <code>defaultProps</code> 依然是个约定，而不能通过强类型推导出，目前还没有更优雅的解决思路。</p><blockquote><p>渲染与判断逻辑分开</p></blockquote><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">class</span> User <span class="keyword">extends</span> Component &#123;</span><br><span class="line">  state = &#123; loading: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loading, user &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> loading</span><br><span class="line">      ? &lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      : &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            First name: &#123;user.firstName&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            First name: &#123;user.lastName&#125;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          ...</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetchUser(<span class="keyword">this</span>.props.id)</span><br><span class="line">      .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123; <span class="keyword">this</span>.setState(&#123; loading: <span class="literal">false</span>, user &#125;)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">import</span> RenderUser <span class="keyword">from</span> <span class="string">'./RenderUser'</span>;</span><br><span class="line"><span class="keyword">class</span> User <span class="keyword">extends</span> Component &#123;</span><br><span class="line">  state = &#123; loading: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loading, user &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> loading ? &lt;Loading /&gt; : &lt;RenderUser user=&#123;user&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetchUser(<span class="keyword">this</span>.props.id)</span><br><span class="line">      .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123; <span class="keyword">this</span>.setState(&#123; loading: <span class="literal">false</span>, user &#125;)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑与渲染分离，便于维护，其次便于测试。</p><p>当然有人可能会问 “就算逻辑与渲染分离了，但组成的大组件不还是逻辑耦合的吗”，对，这就像函数单一指责一样，<code>render</code> 是过程代码，但过程中涉及到的逻辑，分配给单一指责的渲染组件渲染，如果把逻辑与渲染写在一起，就类似一个函数把功能全做完，这样做显然诸事不利。</p><h3 id="提倡无状态组件"><a href="#提倡无状态组件" class="headerlink" title="提倡无状态组件"></a>提倡无状态组件</h3><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">class</span> TableRowWrapper <span class="keyword">extends</span> Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Clean</span></span><br><span class="line"><span class="regexp">const TableRowWrapper = (&#123; children &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;tr&gt;</span></span><br><span class="line"><span class="regexp">    &#123;children&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>tr&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>性能是一个原因，原文比较强调性能与代码量。我认为 <code>stateless</code> 重点在于阻碍了内部状态的使用，移除了生命周期，所以提高了组件的可控性，也就拓宽了组件的使用场景。</p><p>受控与非受控组件都有其适用场景，像非常基础的底层组件库，往往倾向提供两套机制，通过 <code>value</code> 与 <code>defaultValue</code> 决定是否受控。拥有这样能力的组件源码就没法通过 <code>stateless</code> 写，所以无状态组件的面向对象并不是基础底层组件，而且这些基础组件也没必要完全无状态，两者都提供是最好的选择。</p><p>说到这，也就是考虑到成本问题，那么无状态组件也就更适合上层具有业务含义的组件。页面级别组件状态太多，不适合，所以我认为无状态组件比较适合 <code>Wrapper</code> 层，也就是对基础组件包裹并增强业务能力这一层。</p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dirty</span></span><br><span class="line"><span class="keyword">const</span> splitLocale = locale.split(<span class="string">'-'</span>);</span><br><span class="line"><span class="keyword">const</span> language = splitLocale[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> country = splitLocale[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line"><span class="keyword">const</span> [language, country] = locale.split(<span class="string">'-'</span>);</span><br></pre></td></tr></table></figure><p>ES6 新增的语法可以提升不少代码可读性，需要刻意训练去培养这个习惯。</p><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>本周精读已经融于内容概要中 ^_^。最后推荐在 typescript 中开启 <code>strict</code> 模式，强制使用良好的开发习惯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">onChange(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value.name))</span><br><span class="line"><span class="comment">// Dirty</span></span><br><span class="line">onChange(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    value = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(value.name)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line">onChange(<span class="function">(<span class="params">value = &#123;&#125;</span>) =&gt;</span> <span class="built_in">console</span>.log(value.name))</span><br><span class="line"><span class="comment">// Clean</span></span><br><span class="line">onChange(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value?.name))</span><br></pre></td></tr></table></figure><p>不要信任任何回调函数给你的变量，它们随时可能是 <code>undefined</code>，使用初始值是个不错的选择，但有的时候初始值没什么意义，使用 <code>?.</code> 语法可以安全的访问属性，是时候抛弃 <code>_.get</code> 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h2&gt;&lt;p&gt;编程也是艺术行为，当我们思考代码复用、变量命名时，就是在进行艺术思考。&lt;/p&gt;
&lt;p&gt;可能这篇文章没法提高面试能力、开发效率，因为涉及的内容都是 “软能力”。但如果与我一样，时常害怕自己代码不够优雅，那就在茶余饭后看看这篇文章，也许，可以解决一部分你心中的困惑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>那些入坑 React 前没有人会提醒你的事</title>
    <link href="https://doubleray.top/2018/12/15/article-react-cao-dian/"/>
    <id>https://doubleray.top/2018/12/15/article-react-cao-dian/</id>
    <published>2018-12-15T13:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>站在 React 已经繁荣昌盛、无需四处布道宣传的今天，我们不妨冷静下来问问自己，React 真的是一个完美的框架吗？社区里一直不缺少吐槽的声音，这周我们就来看看，React 到底有哪些槽点。</p><p>针对以下两篇文章：</p><p>一篇是 Gianluca Guarini 写的 《<a href="https://medium.com/@gianluca.guarini/things-nobody-will-tell-you-about-react-js-3a373c1b03b4" target="_blank" rel="noopener">Things nobody will tell you about React.js</a>》，我将它译作 《那些入坑 React 前没有人会提醒你的事》，因为作者行文中明显带着对 React 的批判和失望。</p><p>另一篇则是 Facebook 员工，也是 Redux 作者的 Dan Abramov 针对上文的回复 《<a href="https://medium.com/@dan_abramov/hey-thanks-for-feedback-bf9502689ca4" target="_blank" rel="noopener">Hey, thanks for feedback!</a>》。</p><a id="more"></a><h1 id="2-内容概要"><a href="#2-内容概要" class="headerlink" title="2 内容概要"></a>2 内容概要</h1><p>Gianluca Guarini 着重吐槽的点在于：</p><ul><li>React 项目文件组织规范不统一，社区中 Starter Kit 太多（100+），新手不知道该怎么组织文件</li><li>由于 React 只关心 View 层，开发者就要面临选择 mobx 还是 redux 的纠结，无论选择哪种都会带来一系列的问题（重新配置构建脚本，更新 eslint 规则等）</li><li>如果选了 mobx，会发现 mobx 无法保证自己的 store 不被外部更新（官方建议是加上特殊的前缀）</li><li>如果选了 redux，会发现要实现同样的功能需要写很多的重复代码（这也是为什么社区中有海量的 redux helper 存在）</li><li>路由用起来也很蛋疼，因为 React Router 几乎是社区中唯一的选择，但是这货版本更新太快，一不小心就用了废弃的 API</li><li>用 JSX 的时候总是要嵌很多没必要的 <code>div</code> 或 <code>span</code></li><li>要上手一个 React 应用，要配置很多的构建工具和规则才能看到效果</li><li>…</li></ul><p>Dan Abramov 的回复：</p><ul><li>「React 16.0 引入的 Fiber 架构会导致现有代码全部需要重构」的说法是不对的，因为新的架构做到了向后兼容，而且 Facebook 内部超过 3 万个组件都能无痛迁移到新架构上</li><li>缺少统一脚手架的问题，可以通过 create-react-app 解决</li><li>觉得 redux 和 mobx 繁琐的话，对于刚刚上手的小应用不建议使用</li><li>React Router 升级太频繁？2015 年发布的 1.0，2016 年 2 月发布的 2.0，2016 年 10 月发布的 3.0。虽然 4.0 紧接着 3.0 马上就发布了，但是 React Router 很早就已经公布了这样的升级计划。</li><li>…</li></ul><h1 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h1><p>本次提出独到观点的同学有：<a href="https://www.zhihu.com/people/rccoder/answers" target="_blank" rel="noopener">@rccoder</a>  <a href="https://www.zhihu.com/people/turbe-xue" target="_blank" rel="noopener">@Turbe Xue</a> <a href="https://github.com/Pines-Cheng" target="_blank" rel="noopener">@Pines-Cheng</a> <a href="https://github.com/jin5354" target="_blank" rel="noopener">@An Yan</a> <a href="https://www.zhihu.com/people/5ac53c9c0484e83672e1c1716bdf0ff9" target="_blank" rel="noopener">@淡苍</a>  <a href="https://www.zhihu.com/people/3ec85a04bc9eaa35b1830874cc463a52" target="_blank" rel="noopener">@黄子毅</a> <a href="https://www.zhihu.com/people/twobin/pins/posts" target="_blank" rel="noopener">@宾彬</a> <a href="https://github.com/cisen" target="_blank" rel="noopener">@cisen</a> <a href="https://github.com/ybning" target="_blank" rel="noopener">@Bobo</a> 精读由此归纳。</p><p>很高兴能看到不少新同学积极参与到精读的讨论中来，每一个人的声音都是社区发展的一份力量。</p><h3 id="React-上手困难"><a href="#React-上手困难" class="headerlink" title="React 上手困难"></a>React 上手困难</h3><p>很早之前我们去四处布道 React 的时候，都会强调 React 很简单，因为它的 public API 非常之少，React 完整的文档 1 个小时就能看完。</p><p>那么说「React 上手困难」又是从何谈起呢？参与精读的同学中有不少都有 Vue 的使用经验（包括本周吐槽文的作者），所以不免会把两个框架上手的难易程度放在心里做个对比。</p><p>都说没有对比就没有伤害，大家普遍的观点是 Vue 上手简单、文档清晰、构建工具完善、脚手架统一……再反观 React，虽然 Dan 在文章里做了不少解释，但引用 @An Yan 的原话，『他也只是在说「事情没有那么糟糕」』。</p><p>所以说，大家认为的 React 上手困难，很大程度上不是 React 本身，而是 React 附带的生态圈野蛮发展太快，导致新人再进入的时候普遍感觉无所适从。虽然官方的 create-react-app 缓解了这一问题，但还没有从根本程度上找到解法。</p><h3 id="状态管理的迷思"><a href="#状态管理的迷思" class="headerlink" title="状态管理的迷思"></a>状态管理的迷思</h3><p>在今时今日的前端圈子里，说 React 不说 Redux 就像说 Ruby 却不说 Rails 一样，总感觉缺点儿什么。</p><p>因为 React 将自己定位成 View 层的解决方案，所以对于中大型业务来说一个合适的状态管理方案是不可或缺的。从最早的 Backbone Model，到 Flux，再到 reflux、Redux，再到 mobx 和 redux-observable，你不得不感叹 React 社区的活力是多么强大。</p><p>然而当你真正开始做新项目架构的时候，你到底是选 Redux 还是 Mobx，疑惑是封装解决方案如 dva 呢？ @淡苍 认为，Redux 与 MobX，React 两大状态管理方案，各有千秋，Redux 崇尚自由，扩展性好，却也带来了繁琐，一个简单的异步请求都必须引入中间件才能解决，MobX 上手容易，Reactive 避免不必要的渲染，带来性能提升，但相对封闭，不利于业务抽象，缺少最佳实践。至于如何选择？根据具体场景与需求判断。</p><p>不难看出，想要做好基于 React 的前端架构，你不仅需要对自己的业务了如指掌，还需要对各种解决方案的特性以及适合怎样的业务形态了如指掌。在 React 社区，永远没有标准解决方案。</p><h3 id="Redux-亦非万能解"><a href="#Redux-亦非万能解" class="headerlink" title="Redux 亦非万能解"></a>Redux 亦非万能解</h3><p>Redux 在刚刚推出的时候凭借酷炫的 devtool 和时间旅行功能，瞬间俘获了不少工程师的心。</p><p>但当你真正开始使用 Redux 的时候，你会发现你不仅需要学习很多新的概念，如 reducer、store、dispatch、action 等，还有很多基础的问题都没有标准解法，最典型的例子就是异步 action。虽然 Redux 的 middleware 机制提供了实现异步 action 的可能性，但是对于小白来说去 dispatch 一个非 Object 类型的 action 之前需要先了解 thunk 的概念，还要给 Redux 添加一个 redux-thunk 中间件实属难题。</p><p>不仅如此，在前端工程中常见的表单处理，Redux 社区也一直没有给出完美的解法。前有简单的 util 工具 redux-form-utils，后有庞大复杂的 redux-form，还有 rc-component 实现的一套基于 HOC 的解决方案。若没有充分的了解和调研，你将如何选择？</p><p>这还没有提到最近非常火热的 redux-saga 和 redux-observable，虽然 Dan 说如果你不需要的话完全可以不用了解，但是如果你不了解他们的话怎么知道自己需不需要呢？</p><h3 id="React-与-Vue-之争"><a href="#React-与-Vue-之争" class="headerlink" title="React 与 Vue 之争"></a>React 与 Vue 之争</h3><p>Vue 之所以觉得入门简单，因为一开始就提供了 umd 的引入方式，这与传统 js 开发的习惯一致，以及 Avalon 多年布道的铺垫，大家可以很快接受一个不依赖于构建的 Vue。</p><p>React 因为引入了 JSX 概念，本可以以 umd 方式推广，但为了更好的 DX 所以上来就推荐大家使用 JSX，导致新手觉得门槛高。</p><p>React + Mobx 约等于一个复杂的 Vue，但这不是抛弃 React 的理由。为什么大家觉得 Vuex 比 Redux 更适合 Vue 呢？因为 Vuex 简单，而 Redux 麻烦，这已经将两个用户群划分开了。</p><p>一个简单的小公司，就是需要这种数据流简单，不需要编译，没有太多技术选型要考虑的框架，他们看中的是开发效率，可维护性并不是第一位，这点根本性的导致了这两类人永远也撮合不到一块。</p><p>而 Vue 就是解决了这个问题，帮助了那么多开发者，仅凭这点就非常值得称赞，而我们不应该从 React 维护性的角度去抨击谁好谁坏，因为站在我们的角度，大部分中小公司的开发者是不 care 的。</p><p>React 用户圈汇集了一批高端用户，他们不断探索技术选型，为开源社区迸发活力，如果大家都转向 Vue，这块摊子就死了，函数式、响应式编程的演进也会从框架的大统一而暂时终止，起码这是不利于技术进步的，也是不可能发生的。Vue 在自己的领域做好，将 React 敏捷思想借鉴过来，帮助更多适合场景的开发者，应该才是作者的目的。</p><h3 id="小贴士：如何在开源社区优雅的撕逼"><a href="#小贴士：如何在开源社区优雅的撕逼" class="headerlink" title="小贴士：如何在开源社区优雅的撕逼"></a>小贴士：如何在开源社区优雅的撕逼</h3><p>开源社区撕逼常有，各种嘴炮也吃充斥在社区里，甚至有人在 Github 上维护了一份开源社区撕逼历史。虽然说做技术的人有争论很正常，但是撕的有理有据令人信服的案例却不多。这次 Facebook 的员工 Dan Abramov 就做出了很好的表率。面对咄咄逼人的文章，逐条回复，不回避、不扯淡且态度保持克制，实属难能可贵。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>React 开发者们也不要因为产生了 Mobx 这种亲 Vue 派而产生焦虑，这也是对特定业务场景的权衡，未来更多更好的数据流方案还会继续诞生，技术社区对技术的优化永无止尽。</p><p>比如 <a href="https://github.com/mobxjs/mobx-state-tree" target="_blank" rel="noopener">mobx-state-tree</a> 就是一种 redux 与 mobx 结合的大胆尝试，作者在很早之前也申明了，Mobx 一样可以做时间旅行，只要遵守一定的开发规范。</p><p>最后打个比方：安卓手机在不断进步，体验越来越逼近苹果，作为一个逼格高的用户，果断换苹果吧。但作为 java 开发人员的你，是否要为此换到 oc 流派呢？换，或者不换，其实都一样，安卓和苹果已经越来越像了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h1&gt;&lt;p&gt;站在 React 已经繁荣昌盛、无需四处布道宣传的今天，我们不妨冷静下来问问自己，React 真的是一个完美的框架吗？社区里一直不缺少吐槽的声音，这周我们就来看看，React 到底有哪些槽点。&lt;/p&gt;
&lt;p&gt;针对以下两篇文章：&lt;/p&gt;
&lt;p&gt;一篇是 Gianluca Guarini 写的 《&lt;a href=&quot;https://medium.com/@gianluca.guarini/things-nobody-will-tell-you-about-react-js-3a373c1b03b4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Things nobody will tell you about React.js&lt;/a&gt;》，我将它译作 《那些入坑 React 前没有人会提醒你的事》，因为作者行文中明显带着对 React 的批判和失望。&lt;/p&gt;
&lt;p&gt;另一篇则是 Facebook 员工，也是 Redux 作者的 Dan Abramov 针对上文的回复 《&lt;a href=&quot;https://medium.com/@dan_abramov/hey-thanks-for-feedback-bf9502689ca4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hey, thanks for feedback!&lt;/a&gt;》。&lt;/p&gt;
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React学习总结</title>
    <link href="https://doubleray.top/2018/11/17/article-react-learn-sum/"/>
    <id>https://doubleray.top/2018/11/17/article-react-learn-sum/</id>
    <published>2018-11-17T10:13:05.000Z</published>
    <updated>2021-06-24T04:02:41.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React开发步骤总结"><a href="#React开发步骤总结" class="headerlink" title="React开发步骤总结"></a>React开发步骤总结</h2><ol><li>UI拆分（单一职责原则）</li><li>构建静态版本（无state，无交互，可测试页面构成）</li><li>确定state（为了好维护：最小但完整）</li><li>某些可以根据props计算而来 或者 根据已有state和props计算而来的 不是必须state。</li><li>确定状态的位置</li><li>考虑涉及到同一state的组件有哪些，将该state放到所有关联组件的共同祖先组件</li><li>反向数据流</li><li>在确定好state之后，通过props向下传递，形成正向数据流；反向数据流就是事件响应等修改祖先组件中的state。</li></ol><h2 id="React基础知识总结"><a href="#React基础知识总结" class="headerlink" title="React基础知识总结"></a>React基础知识总结</h2><ol><li>React只更新必需要更新的部分，即使render了整个react元素，也只更新需要更新的部分，不必纠结render执行的资源消耗，参见<a href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" rel="noopener">react diff</a></li><li>JSX 可防止注入攻击，由于其在渲染前，所有数据会被转义成字符串处理；JSX本身可看作对象，即React元素，React会根据这些React元素来构建真正的DOM，并保持更新。</li><li>state状态更新可能是异步的，React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新，所以不能依赖他们的值计算下一个state(状态)；</li><li>组件的状态只能自身访问，组件外不能获取；一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)；</li><li><strong>事件处理</strong> (通过preventDefault来阻止默认行为)，注意事件处理函数的this绑定；</li><li><strong>条件渲染：</strong><ul><li>if + 变量，根据不同state或者props来返回不同组件；</li><li>在返回的组件JSX中使用 &amp;&amp; ，JSX中可使用任何表达式（内联）;</li><li>三元表达式（内联）；</li></ul></li><li>组件属性 props.children 表示组件包裹的元素，可包裹JSX组件元素、字符串、{}包裹的js表达式、回调函数。false，null，undefined，和 true 都是有效的的 children(子元素)，但是并不会被渲染。</li><li>return null 可防止组件被渲染（可在函数组件中return null），从组件的 render 方法返回 null 不会影响组件生命周期方法的触发。 例如， componentWillUpdate 和 componentDidUpdate 仍将被调用；</li><li><strong>列表渲染：</strong><ul><li>列表组件</li><li>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识；keys 在同辈元素中必须是唯一的，不需要全局唯一；key不会作为props传入组件内部，若想使用，可利用props传入相同的值；</li></ul></li><li><strong>表单</strong>（受控组件）(React元素中input、textare、select标签的value，onChange与selected属性都与HTML元素不同，都接受一个 value 属性来实现一个受控组件)</li><li><strong>状态提升：</strong><ul><li>React遵循单一数据流原则，即从上到下的数据流，通过将state转props进行父子通信，若需要组件间通信，则需要将组件的状态提升到最近的共同祖先组件；</li><li>当你看到 UI 中的错误，你可以使用 React 开发者工具来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头;</li><li>组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数;</li></ul></li></ol><h2 id="redux-学习记录"><a href="#redux-学习记录" class="headerlink" title="redux 学习记录"></a>redux 学习记录</h2><p><a href="https://segmentfault.com/a/1190000017064759" target="_blank" rel="noopener">中文文档 segmentfault</a></p><p><a href="https://cn.redux.js.org/" target="_blank" rel="noopener">中文文档 GitBook</a></p><h3 id="redux-的来源与思想"><a href="#redux-的来源与思想" class="headerlink" title="redux 的来源与思想"></a>redux 的来源与思想</h3><ol><li>来源：Redux 由 Flux 演变而来，但受 Elm （函数式编程语言）的启发，避开了 Flux 的复杂性。</li><li>思想：Web 应用是一个状态机，视图与状态是一一对应的。所有的状态，保存在一个对象里面。让 state 的变化变得可预测 。</li><li>三大原则：<ul><li>单一数据源（整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中）</li><li>State 是只读的（唯一改变 state 的方法就是触发 action）</li><li>使用纯函数来执行修改（通过 reducers 函数来修改 state tree）</li></ul></li></ol><h3 id="redux-的适用场景"><a href="#redux-的适用场景" class="headerlink" title="redux 的适用场景"></a>redux 的适用场景</h3><p>从应用的角度：</p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p>从组件的角度：</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React开发步骤总结&quot;&gt;&lt;a href=&quot;#React开发步骤总结&quot; class=&quot;headerlink&quot; title=&quot;React开发步骤总结&quot;&gt;&lt;/a&gt;React开发步骤总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;UI拆分（单一职责原则）&lt;/li&gt;
&lt;li&gt;构建静态版本
      
    
    </summary>
    
    
      <category term="干货分享" scheme="https://doubleray.top/categories/%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://doubleray.top/tags/JavaScript/"/>
    
      <category term="React" scheme="https://doubleray.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>单页面 SEO 优化</title>
    <link href="https://doubleray.top/2018/10/10/other-SEO/"/>
    <id>https://doubleray.top/2018/10/10/other-SEO/</id>
    <published>2018-10-10T02:10:10.000Z</published>
    <updated>2021-06-24T04:02:41.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><ol><li>logo上加首页的地址，并且只将logo是放在<code>h1</code>标签中</li><li>外链优化，提高关键词排名，<code>meta</code>信息</li><li>对外联css,以及js使用了延迟加载以及<code>dns-prefetch</code>，<code>preload</code></li><li>使用<code>Robots.txt</code></li></ol><p>… 等等</p><h2 id="服务端渲染-后端渲染SSR"><a href="#服务端渲染-后端渲染SSR" class="headerlink" title="服务端渲染(后端渲染SSR)"></a>服务端渲染(后端渲染SSR)</h2><p>可以使用<a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">Nuxt.js</a>作为框架来处理项目的所有UI呈现</p><ul><li>好处：前端耗时少（前端只负责将<code>html</code>进行展示），利于SEO</li><li>坏处：网络传输数据量大，占用（部分、少部分）服务器运算资源，response 出的数据量会（稍）大点，模板改了前端的交互和样式什么的一样得跟着联动修改</li></ul><h2 id="预渲染的方式-PreRender"><a href="#预渲染的方式-PreRender" class="headerlink" title="预渲染的方式(PreRender)"></a>预渲染的方式(PreRender)</h2><p><a href="https://github.com/muwoo/vue-meta-info" target="_blank" rel="noopener">vue-meta-info</a> 动态设置<code>meta</code>信息，配合 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a> 实现关键页面的预渲染。</p><blockquote><p>需要路由使用<code>history</code>模式，使用<code>hash</code>模式会导致失效</p></blockquote><ul><li>缺点：不能很好地处理用户独特性路由，预渲染路由过多的话会增加编译时间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通用方法&quot;&gt;&lt;a href=&quot;#通用方法&quot; class=&quot;headerlink&quot; title=&quot;通用方法&quot;&gt;&lt;/a&gt;通用方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;logo上加首页的地址，并且只将logo是放在&lt;code&gt;h1&lt;/code&gt;标签中&lt;/li&gt;
&lt;li&gt;外链优化，
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://doubleray.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="SEO" scheme="https://doubleray.top/tags/SEO/"/>
    
  </entry>
  
</feed>

{"meta":{"title":"Love Light","subtitle":"我的世界不只有 Coding！","description":"前端日常","author":"DoubleRay","url":"https://doubleray.top","root":"/"},"pages":[{"title":"文章分类","date":"2017-11-29T05:12:05.000Z","updated":"2021-06-24T04:02:41.992Z","comments":true,"path":"categories/index.html","permalink":"https://doubleray.top/categories/index.html","excerpt":"","text":""},{"title":"前端情报局","date":"2017-11-29T05:57:51.000Z","updated":"2021-06-24T04:02:41.993Z","comments":true,"path":"dairy/index.html","permalink":"https://doubleray.top/dairy/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2017-11-29T05:12:29.000Z","updated":"2021-06-24T04:02:42.090Z","comments":true,"path":"tags/index.html","permalink":"https://doubleray.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"article-blog-coding","date":"2021-06-24T04:02:41.953Z","updated":"2021-06-24T04:02:41.953Z","comments":true,"path":"2021/06/24/article-blog-coding/","link":"","permalink":"https://doubleray.top/2021/06/24/article-blog-coding/","excerpt":"layout: posttitle: “与时俱进（折腾）”date: 2017-04-11 15:25:15 +0800categories: 实践之路tags: Web 2017年3月21日收到一条来自多说的消息，多说将要关闭服务继而成为历史，首先感谢多说团队这些年来提供的免费服务！希望你们转型后能更加美好～ 那么，我们的评论该迁移至何处呢？这个问题，对有服务器的同学来说其实也并不是问题，在服务器上部署一个评论系统不是一个难事，也可以直接安装诸如 wordpress 之类的产品，自带了完善了评论功能，并且还支持导入多说的数据。其实，受伤的是那些使用诸如 hexo/jekyll 构建的静态博客，没有数据库能力的，首先想到的有两个方案： Disqus：这款国外最流行的社会化评论组件，体验优良，而且基于评论做了一个交流社区，形成了良好的生态； commentit.io：可以将评论直接作为 commit，用 JS 脚本提交到 Github，保存进代码库。 但是呢，这两个解决方案都有被墙的可能，左思右想而且还都亲自尝试了一下，在国内体验确实比较糟糕，那么只能暂时另辟蹊径了！","text":"layout: posttitle: “与时俱进（折腾）”date: 2017-04-11 15:25:15 +0800categories: 实践之路tags: Web 2017年3月21日收到一条来自多说的消息，多说将要关闭服务继而成为历史，首先感谢多说团队这些年来提供的免费服务！希望你们转型后能更加美好～ 那么，我们的评论该迁移至何处呢？这个问题，对有服务器的同学来说其实也并不是问题，在服务器上部署一个评论系统不是一个难事，也可以直接安装诸如 wordpress 之类的产品，自带了完善了评论功能，并且还支持导入多说的数据。其实，受伤的是那些使用诸如 hexo/jekyll 构建的静态博客，没有数据库能力的，首先想到的有两个方案： Disqus：这款国外最流行的社会化评论组件，体验优良，而且基于评论做了一个交流社区，形成了良好的生态； commentit.io：可以将评论直接作为 commit，用 JS 脚本提交到 Github，保存进代码库。 但是呢，这两个解决方案都有被墙的可能，左思右想而且还都亲自尝试了一下，在国内体验确实比较糟糕，那么只能暂时另辟蹊径了！ 多说到跟帖 通过多方“打听”和尝试，最后选择了网易云跟帖。先声明我不是打广告，我也是个多说的忠实用户，现在多说要关闭了，很难过的就是它的之前的评论，看了友言不支持导入多说、畅言必须是备案的域名，使用‘网易云跟帖’，不必备案域名，也支持导入多说的评论。真是好极了。。。 有兴趣的可以参看这里从多说到跟帖：推荐网易云跟帖，文章中详细说明了 注册网易云跟帖站点 和 如何导入多说的评论。 拥抱Coding CODING 是国内首个一站式云端软件服务平台，于 2014 年 2 月在深圳成立，并于北京、上海、成都、西雅图设立分部。在云计算时代，CODING 致力于通过技术创新推动软件开发与交付模式的转变，让开发更简单。 CODING 旗下自主研发运营 Coding.net 云端软件开发协作平台，目前已累积 30 万开发者，50 万个项目。秉承着“让开发更简单”的使命，将代码托管、项目管理、WebIDE 等开发工具集成到浏览器中，免除繁杂的开发环境部署，降低开发和部署软件的成本，提升团队协作沟通效率，提高软件开发生产力，最终实现 “Coding Anytime Anywhere” 的愿景。 Coding Pages Coding Pages 是一个免费的静态网页托管和演示服务。您可以使用 Coding Pages 托管博客、项目官网等静态网页，还可以绑定自定义域名。而且Coding Pages 可自动构建 Jekyll 网站，目前支持 Jekyll 3.0。 等等。。。 这不是和github pages同效嘛，既然想让站点更快，那就干脆回到祖国的怀抱吧，OK，正式拥抱 Coding！ 没有用迁移这个说法，这是因为就是重新部署了一下。至于要切过去的原因，我乃天朝子民，岂久用番邦外夷器具乎（i.e. vpn严重影响打开速度）。 具体步骤和github差不多，而且还是母语，相信不用教程也完全可以，我就不详细说了，有问题请自行看帮助或者去Google。 转移仓库时Coding提供了一个导入仓库功能，可直接从github上“pull”过来，如图： ![coding git](/styles/images/build blog/coding_git.png) 结语 互联网的世界真是日新月异，生命不息折腾不止！","categories":[],"tags":[]},{"title":"安装 node-sass 报错的解决记录","slug":"article-node-sass-error","date":"2020-06-18T15:13:05.000Z","updated":"2021-06-24T04:02:41.975Z","comments":true,"path":"2020/06/18/article-node-sass-error/","link":"","permalink":"https://doubleray.top/2020/06/18/article-node-sass-error/","excerpt":"问题yarn 或 npm install 命令的时候，总是在安装node-sass这一步卡住。终其原因还是「墙」的问题。","text":"问题yarn 或 npm install 命令的时候，总是在安装node-sass这一步卡住。终其原因还是「墙」的问题。 解决npm和yarn的解决方法一样，这里以yarn为示例。 查看 yarn 配置 yarn config list 将 yarn 源切换至淘宝源 1yarn config set registry https://registry.npm.taobao.org 执行 yarn install 或者 yarn 如果遇到错误 error An unexpected error occurred: “EINVAL: invalid argument, symlink 请在你的执行命令之后添加 --no-bin-links 1yarn install –no-bin-links 如果遇到错误 _error: xxxx node-sass: Command failed_，将 sass-binary-site 添加至 config 中，指定 node-sass 从 npm 的淘宝源中下载。 1yarn config set sass-binary-site https://npm.taobao.org/mirrors/node-sass","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://doubleray.top/tags/Node/"},{"name":"yarn","slug":"yarn","permalink":"https://doubleray.top/tags/yarn/"},{"name":"npm","slug":"npm","permalink":"https://doubleray.top/tags/npm/"}]},{"title":"node多版本管理（Windows）","slug":"other-node-nvm-windows","date":"2020-04-13T02:10:10.000Z","updated":"2021-06-24T04:02:41.990Z","comments":true,"path":"2020/04/13/other-node-nvm-windows/","link":"","permalink":"https://doubleray.top/2020/04/13/other-node-nvm-windows/","excerpt":"旧的项目依赖低版本的node，但是现在的node版本变化太快，所以使用 nvm-windows 来管理不同版本的node。","text":"旧的项目依赖低版本的node，但是现在的node版本变化太快，所以使用 nvm-windows 来管理不同版本的node。 软件地址：https://github.com/coreybutler/nvm-windows/releases 卸载现有的node和npm请注意，在安装NVM for Windows之前，您需要卸载任何现有版本的node.js. 还删除可能保留的任何现有nodejs安装目录（例如，C\\Program Files\\nodejs）。NVM生成的符号链接不会覆盖现有（甚至是空的）安装目录。 还应该删除现有的npm安装位置（例如C\\Users&lt;user&gt;\\AppData\\Roaming\\npm），以便正确使用nvm安装位置。 安装在releases中下载最新版本nvm-setup.zip，解压后，是一个安装文件，直接安装即可。 由于国内在一些情况下有些特殊。Node.js 官方镜像源又在国外，经常通过 nvm 安装 Node.js 时，速度比较慢，或者没有响应。 根据这种情况，nvm 允许更改安装的镜像源，我们可以将镜像源切换到国内的淘宝提供的镜像源。 默认安装目录（C:\\Users[username]\\AppData\\Roaming\\nvm）下的settings.txt文件中添加： 12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 使用12345678# 查看已安装的nodenvm -ls # 安装指定版本的nodenvm install &lt;version&gt;# 指定自己要使用的版本号nvm use &lt;version&gt;# 卸载指定版本的nodenvm uninstall &lt;version&gt; 具体参考：https://github.com/coreybutler/nvm-windows#usage","categories":[{"name":"杂记","slug":"杂记","permalink":"https://doubleray.top/categories/杂记/"}],"tags":[{"name":"NODE","slug":"NODE","permalink":"https://doubleray.top/tags/NODE/"}]},{"title":"CentOS配置Docker API TLS认证","slug":"other-docker-tls","date":"2020-04-03T02:10:10.000Z","updated":"2021-06-24T04:02:41.990Z","comments":true,"path":"2020/04/03/other-docker-tls/","link":"","permalink":"https://doubleray.top/2020/04/03/other-docker-tls/","excerpt":"我们利用Portainer来管理docker环境和用Jenkins来自动构建和部署docker时的远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。","text":"我们利用Portainer来管理docker环境和用Jenkins来自动构建和部署docker时的远程管理都会使用到Docker API，通常我们只是开启了没有安全保护的2375（通常）端口，这个比较危险，会导致远程劫持攻击。那么我们就需要配置TLS认证的2376（通常）端口。 下面我们针对CentOS系统进行配置： 一、利用系统自带的openssl生成相应的服务端和客户端证书具体过程可参考：https://docs.docker.com/engine/security/https/ 我们利用脚本自动生成，这样非常便捷，脚本（auto-tls-certs.sh）如下： script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/bin/bash# # -------------------------------------------------------------# 自动创建 Docker TLS 证书# -------------------------------------------------------------# 以下是配置信息# Config startIP=\"39.39.139.39\"PASSWORD=\"123456\"COUNTRY=\"CN\"STATE=\"Beijing\"CITY=\"Beijing\"ORGANIZATION=\"COM\"ORGANIZATIONAL_UNIT=\"Dev\"COMMON_NAME=\"$IP\"EMAIL=\"COM@china.cn\"# Config end# 生成 CA 密钥if [[ ! -f ca-key.pem ]]; then echo \" - 生成 CA 密钥\" openssl genrsa -aes256 -passout \"pass:$PASSWORD\" -out \"ca-key.pem\" 4096fi# 生成 CAif [[ ! -f ca.pem ]]; then echo \" - 生成 CA\" openssl req -new -x509 -days 365 -key \"ca-key.pem\" -sha256 -out \"ca.pem\" -passin \"pass:$PASSWORD\" -subj \"/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL\"fi# 生成服务器密钥 &amp; 服务器证书if [[ ! -f server-key.pem ]]; then echo \" - 生成服务器密钥\" openssl genrsa -out \"server-key.pem\" 4096fiif [[ ! -f server.csr ]]; then openssl req -subj \"/CN=$COMMON_NAME\" -sha256 -new -key \"server-key.pem\" -out server.csrfiif [[ ! -f server-cert.pem ]]; then echo \" - 生成服务器证书\" echo \"subjectAltName = IP:$IP,IP:127.0.0.1\" &gt;&gt; extfile.cnf echo \"extendedKeyUsage = serverAuth\" &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in server.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"server-cert.pem\" -extfile extfile.cnffirm -f extfile.cnf# 生成客户端证书if [[ ! -f key.pem ]]; then openssl genrsa -out \"key.pem\" 4096fiif [[ ! -f cert.pem ]]; then openssl req -subj '/CN=client' -new -key \"key.pem\" -out client.csr echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in client.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"cert.pem\" -extfile extfile.cnffichmod -v 0400 \"ca-key.pem\" \"key.pem\" \"server-key.pem\"chmod -v 0444 \"ca.pem\" \"server-cert.pem\" \"cert.pem\"# 打包客户端证书echo \" - 打包客户端证书为 tls-client-certs.tar.gz\"mkdir -p \"tls-client-certs\"cp -f \"ca.pem\" \"cert.pem\" \"key.pem\" \"tls-client-certs/\"cd \"tls-client-certs\"tar zcf \"tls-client-certs.tar.gz\" *mv \"tls-client-certs.tar.gz\" ../cd ..rm -rf \"tls-client-certs\"# 拷贝服务端证书mkdir -p /etc/docker/certs.dcp -f \"ca.pem\" \"server-cert.pem\" \"server-key.pem\" /etc/docker/certs.d/# 清理rm -vf client.csr server.csr extfile.cnf ca.srl server-cert.pem server-key.pem cert.pemecho \"Connect to server via docker-cli:\"echo \"docker -H $IP:2376 --tlsverify --tlscacert ~/.docker/ca.pem --tlscert ~/.docker/cert.pem --tlskey ~/.docker/key.pem ps -a\"# 客户端使用 cURL 连接echo \"Connect to server via curl:\"echo \"curl --cacert ~/.docker/ca.pem --cert ~/.docker/cert.pem --key ~/.docker/key.pem https://$IP:2376/containers/json\"echo -e \"\\e[1;32mAll be done.\\e[0m\" 执行脚本前可能由于脚本是在windows端写地，会报一个错 $’\\r’: command not found；所以先对脚本执行以下这个命令 ： dos2unix auto-tls-certs.sh 然后再执行命令 sh ./auto-tls.certs.sh 对脚本中的变量进行修改并执行后，自动会创建好tls证书，服务器的证书会自动move到/etc/docker/certs.d/目录下； 客户端的证书在运行脚本的目录下，同时还自动打好了一个.tar.gz的包，很方便，可以下载到本地，配置时直接对应上传即可。 二、配置Docker服务在 /usr/lib/systemd/system 目录下找到 文件 docker.service 原来的ExecStart项为： ExecStart=/usr/bin/dockerd -H fd:// –containerd=/run/containerd/containerd.sock 修改为： ExecStart=/usr/bin/dockerd -H fd:// –containerd=/run/containerd/containerd.sock -H unix:///var/run/docker.sock -D -H tcp://0.0.0.0:2376 –tlsverify –tlscacert=/etc/docker/certs.d/ca.pem –tlscert=/etc/docker/certs.d/server-cert.pem –tlskey=/etc/docker/certs.d/server-key.pem 然后执行命令重启docker服务： systemctl daemon-reloadsystemctl restart docker 成功重启后，服务端的配置就结束了(成功与否的检测方法在自动化脚本中有说明，也可以直接进行下一步)。 三、配置Portainer远程TLS连接 证书对应选择： TLS CA certificate：ca.pem TLS certificate：cert.pem TLS key：key.pem 这样就完成了。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://doubleray.top/categories/杂记/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doubleray.top/tags/Docker/"}]},{"title":"Harbor安装及使用","slug":"other-docker-harbor","date":"2020-03-05T08:10:10.000Z","updated":"2021-06-24T04:02:41.989Z","comments":true,"path":"2020/03/05/other-docker-harbor/","link":"","permalink":"https://doubleray.top/2020/03/05/other-docker-harbor/","excerpt":"","text":"参考： https://istone.dev/2019/07/19/harbor-install/ tar xvf harbor-offline-installer-v1.10.1.tgz cd harbor 修改配置文件 harbor.yml ./install.sh --with-notary --with-clair --with-chartmuseum 参数可选，分别对应三个扩展功能 完成后就可以访问了 将harbor加入开机自启，通过服务的形式 参考：https://www.cnblogs.com/kirito-c/p/11145881.html sudo systemctl enable harbor sudo systemctl start harbor systemctl status harbor.service -l 检查是否开启","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doubleray.top/tags/Docker/"}]},{"title":"Docker入门及实践","slug":"other-docker-know","date":"2020-02-25T10:10:10.000Z","updated":"2021-06-24T04:02:41.989Z","comments":true,"path":"2020/02/25/other-docker-know/","link":"","permalink":"https://doubleray.top/2020/02/25/other-docker-know/","excerpt":"Docker官方文档：https://docs.docker.com/get-started/ 腾讯云的中文文档：https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3 DockerInfo中文文档：http://www.dockerinfo.net/document Docker — 从入门到实践： https://vuepress.mirror.docker-practice.com/","text":"Docker官方文档：https://docs.docker.com/get-started/ 腾讯云的中文文档：https://cloud.tencent.com/developer/information/docker%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3 DockerInfo中文文档：http://www.dockerinfo.net/document Docker — 从入门到实践： https://vuepress.mirror.docker-practice.com/ 所有命令可参考：https://www.runoob.com/docker/docker-command-manual.html 列出本地已有镜像： docker images 移除镜像： docker rmi 或者 docker image rm [id|name] 注意：在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。可加参数 -f 强制删除。 生成镜像： docker build -t [repositoryName]:[tag] [Directory] 命令行参数参考：https://www.runoob.com/docker/docker-build-command.html “Directory” 是 Dockerfile 所在的路径一个镜像不能超过 127 层,编写Dockerfile时应注意 从镜像run容器：docker run -d -p 1202:3000 --name=&quot;quoted&quot; tmd.ictr.cn:89/web-server/quoted:1.0 命令行参数参考：https://www.runoob.com/docker/docker-run-command.html docker重启退出的容器 docker attach [container] docker ps: 查看当前运行的容器docker ps -a:查看所有容器，包括停止的。docker ps -l:查看最新创建的容器，只列出最后创建的。docker ps -n=2:-n=x选项，会列出最后创建的x个容器。 移除容器：docker rm [id] 查看日志： docker logs name","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doubleray.top/tags/Docker/"}]},{"title":"CentOS 8安装Node","slug":"other-Centos-node","date":"2020-02-23T04:10:10.000Z","updated":"2021-06-24T04:02:41.988Z","comments":true,"path":"2020/02/23/other-Centos-node/","link":"","permalink":"https://doubleray.top/2020/02/23/other-Centos-node/","excerpt":"","text":"wget下载源码在需要安装nodejs的目录中执行 wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz https://nodejs.org/dist 这个目录下可以找到各个版本的源码 解压xz -d node-v12.16.1-linux-x64.tar.xz tar -xvf node-v12.16.1-linux-x64.tar 配置软连接要想node能够在全局能够使用，需要添加软连接，配置完即可使用 ln -s /usr/local/node-v12.16.1-linux-x64/bin/node /usr/local/bin/node ln -s /usr/local/node-v12.16.1-linux-x64/bin/npm /usr/local/bin/npm 全局安装的包执行shell时找不到命令的解决方法https://blog.csdn.net/m0_37263637/article/details/81942435","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://doubleray.top/tags/Node/"}]},{"title":"CentOS 8安装Docker","slug":"other-CentOS8-Docker","date":"2020-02-17T02:10:10.000Z","updated":"2021-06-24T04:02:41.988Z","comments":true,"path":"2020/02/17/other-CentOS8-Docker/","link":"","permalink":"https://doubleray.top/2020/02/17/other-CentOS8-Docker/","excerpt":"CentOS 8安装Docker本文参考Docker 官方 CentOS 安装文档","text":"CentOS 8安装Docker本文参考Docker 官方 CentOS 安装文档 安装依赖yum install -y yum-utils device-mapper-persistent-data lvm2 yum options -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程） 更改yum源为国内源yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo更新 yum 软件源缓存yum makecache安装 docker-ceyum install docker-ce -y如果报错： Problem: package docker-ce-3:19.03.7-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of theproviders can be installed 问题的根源在于containerd.io的版本过低，这里通过安装较高版本的containerd.io即可解决问题。访问官网：https://containerd.io/downloads/，根据提示，直接安装二进制包： wget https://github.com/containerd/containerd/releases/download/v1.3.2/containerd-1.3.2.linux-amd64.tar.gz tar xvf containerd-1.3.2.linux-amd64.tar.gz这时候又有一个问题就是官网下载的网速奇慢，所以直接使用DNF工具从docker-ce的仓库（https://download.docker.com/linux/centos/7/x86_64/stable/Packages/）中下载： dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm yum install docker-ce -y docker --version （查看安装是否成功）###开启Docker服务 systemctl enable docker （开机自启） systemctl start docker （启动docker服务） systemctl restart docker 重启Docker加速https://blog.csdn.net/varyall/article/details/104266706 该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker pull node:12.16.1-alpine docker run -it --name node-test node:12.16.1-alpine 我们在doker容器中直接运行node服务，并且打印字符串。这里我们通过run指令，用node镜像创建的一个叫node-test的容器， -i(interactive,表示开启交互), -t(terminal, 表示终端)，-it是两个参数的简写，表示通过命令行的方式运行。还可以添加-d(deamon)表示在后台运行。退出控制台后，我们通过docker ps -a查看当前的所有容器. 接下来我们再次启动这个容器，并进入其中运行bash命令行: docker exec -it node-test sh 我们一般可能会在容器启动后进入容器，常用的是docker attach 镜像id，但是启动镜像的时候如果没有带 参数 -it的话，attach进去后可能是日志界面，并不能执行命令。所以我们会用 docker exec -it [镜像id] /bin/bash/ 平常的容器一般都可以执行/bin/bash，但是alpine没有，改成 docker exec -it [镜像id] sh 就好了。 安装docker-compose下载docker-compose二进制文件安装，因为github网速慢，所以改到了daocloud curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose添加可执行权限 chmod +x /usr/local/bin/docker-compose 测试安装结果 docker-compose --version","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://doubleray.top/tags/Docker/"}]},{"title":"Auto Polyfill","slug":"article-js-auto-polyfill","date":"2019-11-14T05:13:05.000Z","updated":"2021-06-24T04:02:41.963Z","comments":true,"path":"2019/11/14/article-js-auto-polyfill/","link":"","permalink":"https://doubleray.top/2019/11/14/article-js-auto-polyfill/","excerpt":"什么是补丁？ A polyfill, or polyfiller, is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape if you will. 我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁。","text":"什么是补丁？ A polyfill, or polyfiller, is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape if you will. 我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁。 如果你是一个 3 年陈 + 的前端，应该会有听说过 shim、sham、es5-shim 和 es6-shim 等等现在看起来很古老的补丁方式。 那么，shim 和 sham 是啥？又有什么区别？ shim 是能用的补丁 sham 顾名思义，是假的意思，所以 sham 是一些假的方法，只能使用保证不出错，但不能用。至于为啥会有 sham，因为有些方法的低端浏览器里根本实现不了 在 shim 和 sham 之后，还有一种补丁方式是引入包含所有语言层补丁的 babel-polyfill.js。 1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.2.5/polyfill.js\"&gt;&lt;/script&gt; @babel/preset-env + useBuiltins: entry + targets babel-polyfill 包含所有补丁，那我只需要支持某些浏览器的某些版本，是否有办法只包含这些浏览器的补丁？这就是 @babel/preset-env + useBuiltins: entry + targets 配置的方案。 我们先在入口文件里引入 @babel/polyfill， 1import '@babel/polyfill'; 然后配置 .babelrc，添加 preset @babel/preset-env，并设置 useBuiltIns 和 targets， 12345678&#123; \"presets\": [ [\"@babel/env\", &#123; useBuiltIns: 'entry', targets: &#123; chrome: 62 &#125; &#125;] ]&#125; useBuiltIns: entry 的含义是找到入口文件里引入的 @babel/polyfill，并替换为 targets 浏览器/环境需要的补丁列表。 替换后的内容，比如： 123import \"core-js/modules/es7.string.pad-start\";import \"core-js/modules/es7.string.pad-end\";//... 这样就只会引入 chrome@62 及以上所需要的补丁，什么 Promise 之类的都不会再打包引入。 这种方案存在的问题： 特性列表是按浏览器整理的，那怎么知道哪些特性我用了，哪些没有用到，没有用到的部分也引入了是不是也是冗余？@babel/preset-env 有提供 exclude 的配置，如果我配置了 exclude，后面是否得小心翼翼地确保不要用到 exclude 掉的特性 补丁是打包到静态文件的，如果我配置 targets 为 chrome: 62, ie: 9，那意味着 chrome 62 也得载入 ie 9 相关的补丁，这也是一份冗余 我们是基于 core-js 打的补丁，所以只会包含 ecmascript 规范里的内容，其他比如说 dom 里的补丁，就不在此列，应该如何处理？ 在线补丁，比如：polyfill.io目前最流行的应该就是 polyfill.io，提供的是 cdn 服务，有些站点在用，例如 https://spectrum.chat/。另外，polyfill.io 还开源了 polyfill-service 供我们自己搭建使用。 使用上，比如： 12&lt;script src=\"https://polyfill.io/v3/polyfill.min.js?features=default%2CPromise\"&gt;&lt;/script&gt;&lt;script src=\"https://polyfill.alicdn.com/polyfill.min.js?features=default,es5,es6,es7,RegeneratorRuntime\"&gt;&lt;/script&gt; 然后在 Chrome@71 下的输出是： /* Disable minification (remove .min from URL path) for more info */啥都没有，因为 Promsie 特性 Chrome@71 已经支持了。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"Polyfill","slug":"Polyfill","permalink":"https://doubleray.top/tags/Polyfill/"}]},{"title":"Vue3.0 Function API","slug":"article-vue3-function-api","date":"2019-07-07T05:13:05.000Z","updated":"2021-06-24T04:02:41.979Z","comments":true,"path":"2019/07/07/article-vue3-function-api/","link":"","permalink":"https://doubleray.top/2019/07/07/article-vue3-function-api/","excerpt":"1. 引言Vue 3.0 的发布引起了轩然大波，让我们解读下它的 function api RFC 详细了解一下 Vue 团队是怎么想的吧！","text":"1. 引言Vue 3.0 的发布引起了轩然大波，让我们解读下它的 function api RFC 详细了解一下 Vue 团队是怎么想的吧！ 首先官方回答了几个最受关注的问题： Vue 3.0 是否有 break change，就像 Python 3 / Angular 2 一样？ 不，100% 兼容 Vue 2.0，且暂未打算废弃任何 API（未来也不）。之前有草案试图这么做，但由于用户反馈太猛，被撤回了。 Vue 3.0 的设计盖棺定论了吗？ 没有呀，这次精读的稿子就是 RFC（Request For Comments），翻译成中文就是 “意见征求稿”，还在征求大家意见中哦。 这 RFC 咋这么复杂？ RFC 是写给贡献者/维护者的，要考虑许多边界情况与细节，所以当然会复杂很多喽！当然 Vue 本身使用起来还是很简单的。 Vue 本身 Mutable + Template 就注定了是个用起来简单（约定 + 自然），实现起来复杂（解析 + 双绑）的框架。 这次改动很像在模仿 React，为啥不直接用 React？ 首先 Template 机制还是没变，其次模仿的是 Hooks 而不是 React 全部，如果你不喜欢这个改动，那你更不会喜欢用 React。 PS: 问这个问题的人，一定没有同时理解 React 与 Vue，其实这两个框架到现在差别蛮大的，后面精读会详细说明。 下面正式进入 Vue 3.0 Function API 的介绍。 2. 概述Vue 函数式基本 Demo： 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;increment&quot;&gt;count++&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; value, computed, watch, onMounted &#125; from &apos;vue&apos;export default &#123; setup() &#123; // reactive state const count = value(0) // computed state const plusOne = computed(() =&gt; count.value + 1) // method const increment = () =&gt; &#123; count.value++ &#125; // watch watch(() =&gt; count.value * 2, val =&gt; &#123; console.log(`count * 2 is $&#123;val&#125;`) &#125;) // lifecycle onMounted(() =&gt; &#123; console.log(`mounted`) &#125;) // expose bindings on render context return &#123; count, plusOne, increment &#125; &#125;&#125;&lt;/script&gt; 函数式风格的入口是 setup 函数，采用了函数式风格后可以享受如下好处：类型自动推导、减少打包体积。 setup 函数返回值就是注入到页面模版的变量。我们也可以返回一个函数，通过使用 value 这个 API 产生属性并修改： 123456789101112131415import &#123; value &#125; from 'vue'const MyComponent = &#123; setup(props) &#123; const msg = value('hello') const appendName = () =&gt; &#123; msg.value = `hello $&#123;props.name&#125;` &#125; return &#123; msg, appendName &#125; &#125;, template: `&lt;div @click=\"appendName\"&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`&#125; 要注意的是，value() 返回的是一个对象，通过 .value 才能访问到其真实值。 为何 value() 返回的是 Wrappers 而非具体值呢？原因是 Vue 采用双向绑定，只有对象形式访问值才能保证访问到的是最终值，这一点类似 React 的 useRef() API 的 .current 规则。 那既然所有 value() 返回的值都是 Wrapper，那直接给模版使用时要不要调用 .value 呢？答案是否定的，直接使用即可，模版会自动 Unwrapping: 12345678const MyComponent = &#123; setup() &#123; return &#123; count: value(0) &#125; &#125;, template: `&lt;button @click=\"count++\"&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`&#125; 接下来是 Hooks，下面是一个使用 Hooks 实现获得鼠标实时位置的例子： 12345678910111213141516171819202122232425function useMouse() &#123; const x = value(0) const y = value(0) const update = e =&gt; &#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(() =&gt; &#123; window.addEventListener('mousemove', update) &#125;) onUnmounted(() =&gt; &#123; window.removeEventListener('mousemove', update) &#125;) return &#123; x, y &#125;&#125;// in consuming componentconst Component = &#123; setup() &#123; const &#123; x, y &#125; = useMouse() const &#123; z &#125; = useOtherLogic() return &#123; x, y, z &#125; &#125;, template: `&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`&#125; 可以看到，useMouse 将所有与 “处理鼠标位置” 相关的逻辑都封装了进去，乍一看与 React Hooks 很像，但是有两个区别： useMouse 函数内改变 x、y 后，不会重新触发 setup 执行。 x y 拿到的都是 Wrapper 而不是原始值，且这个值会动态变化。 另一个重要 API 就是 watch，它的作用类似 React Hooks 的 useEffect，但实现原理和调用时机其实完全不一样。 watch 的目的是监听某些变量变化后执行逻辑，比如当 id 变化后重新取数： 1234567891011const MyComponent = &#123; props: &#123; id: Number &#125;, setup(props) &#123; const data = value(null) watch(() =&gt; props.id, async (id) =&gt; &#123; data.value = await fetchData(id) &#125;) &#125;&#125; 之所以要 watch，因为在 Vue 中，setup 函数仅执行一次，所以不像 React Function Component，每次组件 props 变化都会重新执行，因此无论是在变量、props 变化时如果想做一些事情，都需要包裹在 watch 中。 后面还有 unwatching、生命周期函数、依赖注入，都是一些语法定义，感兴趣可以继续阅读原文，笔者就不赘述了。 Vue 与 React 逻辑结构React Function Component 与 Hooks，虽然在实现原理上，与 Vue3.0 存在 Immutable 与 Mutable、JSX 与 Template 的区别，但逻辑理解上有着相通之处。 1234567891011121314const MyComponent = &#123; setup(props) &#123; const x = value(0) const setXRandom = () =&gt; &#123; x.value = Math.random() &#125; return &#123; x, setXRandom &#125; &#125;, template: ` &lt;button @onClick=\"setXRandom\"/&gt;&#123;&#123;x&#125;&#125;&lt;/button&gt; `&#125; 虽然在 Vue 中，setup 函数仅执行一次，看上去与 React 函数完全不一样（React 函数每次都执行），但其实 Vue 将渲染层（Template）与数据层（setup）分开了，而 React 合在了一起。 我们可以利用 React Hooks 将数据层与渲染层完全隔离： 12345678910111213141516171819// 类似 vue 的 setup 函数function useMyComponentSetup(props) &#123; const [x, setX] = useState(0) const setXRandom = useCallback(() =&gt; &#123; setX(Math.random()) &#125;, [setX]) return &#123; x, setXRandom &#125;&#125;// 类似 vue 的 template 函数function MyComponent(props: &#123; name: String &#125;) &#123; const &#123; x, setXRandom &#125; = useMyComponentSetup(props) return ( &lt;button onClick=&#123;setXRandom&#125;&gt;&#123;x&#125;&lt;/button&gt; )&#125; 这源于 JSX 与 Template 的根本区别。JSX 使模版与 JS 可以写在一起，因此数据层与渲染层可以耦合在一起写（也可以拆分），但 Vue 采取的 Template 思路使数据层强制分离了，这也使代码分层更清晰了。 而实际上 Vue3.0 的 setup 函数也是可选的，再配合其支持的 TSX 功能，与 React 真的只有 Mutable 的区别了： 1234// 这是个 Vue 组件const MyComponent = createComponent((props: &#123; msg: string &#125;) =&gt; &#123; return () =&gt; h('div', props.msg)&#125;) 我们很难评价 Template 与 JSX 的好坏，但为了更透彻的理解 Vue 与 React，需要抛开 JSX&amp;Template，Mutable&amp;Immutable 去看，其实去掉这两个框架无关的技术选型，React@16 与 Vue@3 已经非常像了。 Vue3.0 的精髓是学习了 React Hooks 概念，因此正好可以用 Hooks 在 React 中模拟 Vue 的 setup 函数。 关于这两套技术选型，已经是相对完美的组合，不建议在 JSX 中再实现类似 Mutable + JSX 的花样来（因为喜欢 Mutable 可以用 Vue 呀）： Vue：Mutable + Template React：Immutable + JSX 真正影响编码习惯的就是 Mutable 与 Immutable，使用 Vue 就坚定使用 Mutable，使用 React 就坚定使用 Immutable，这样能最大程度发挥两套框架的价值。 Vue Hooks 与 React Hooks 的差异先看 React Hooks 的简单语法： 123const [ count, setCount ] = useState(0)const setToOne = () =&gt; setCount(1) Vue Hooks 的简单语法： 123const count = value(0)const setToOne = () =&gt; count.value = 1 之所以 React 返回的 count 是一个数字，是因为 Immutable 规则，而 Vue 返回的 count 是个对象，拥有 count.value 属性，也是因为 Vue Mutable 规则导致，这使得 Vue 定义的所有变量都类似 React 中 useRef 定义变量，因此不存 React capture value 的特性。 关于 capture value 更多信息，可以阅读 精读《Function VS Class 组件》 Capute Value 介绍 另外，对于 Hooks 的值变更机制也不同，我们看 Vue 的代码： 12345678const Component = &#123; setup() &#123; const &#123; x, y &#125; = useMouse() const &#123; z &#125; = useOtherLogic() return &#123; x, y, z &#125; &#125;, template: `&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`&#125; 由于 setup 函数仅执行一次，怎么做到当 useMouse 导致 x、y 值变化时，可以在 setup 中拿到最新的值？ 在 React 中，useMouse 如果修改了 x 的值，那么使用 useMouse 的函数就会被重新执行，以此拿到最新的 x，而在 Vue 中，将 Hooks 与 Mutable 深度结合，通过包装 x.value，使得当 x 变更时，引用保持不变，仅值发生了变化。所以 Vue 利用 Proxy 监听机制，可以做到 setup 函数不重新执行，但 Template 重新渲染的效果。 这就是 Mutable 的好处，Vue Hooks 中，不需要 useMemo useCallback useRef 等机制，仅需一个 value 函数，直观的 Mutable 修改，就可以实现 React 中一套 Immutable 性能优化后的效果，这个是 Mutable 的魅力所在。 Vue Hooks 的优势笔者对 RFC 中对 Vue、React Hooks 的对比做一个延展解释： 首先最大的不同：setup 仅执行一遍，而 React Function Component 每次渲染都会执行。 Vue 的代码使用更符合 JS 直觉。 这句话直截了当戳中了 JS 软肋，JS 并非是针对 Immutable 设计的语言，所以 Mutable 写法非常自然，而 Immutable 的写法就比较别扭。 当 Hooks 要更新值时，Vue 只要用等于号赋值即可，而 React Hooks 需要调用赋值函数，当对象类型复杂时，还需借助第三方库才能保证进行了正确的 Immutable 更新。 对 Hooks 使用顺序无要求，而且可以放在条件语句里。 对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。 而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 setup 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。 不会再每次渲染重复调用，减少 GC 压力。 这确实是 React Hooks 的一个问题，所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。 而 Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 setup 的执行，所以确实不会造成 GC 压力。 必须要总包裹 useCallback 函数确保不让子元素频繁重渲染。 React Hooks 有一个问题，就是完全依赖 Immutable 属性。而在 Function Component 内部创建函数时，每次都会创建一个全新的对象，这个对象如果传给子组件，必然导致子组件无法做性能优化。 因此 React 采取了 useCallback 作为优化方案： 1const fn = useCallback(() =&gt; /* .. */, []) 只有当第二个依赖参数变化时才返回新引用。但第二个依赖参数需要 lint 工具确保依赖总是正确的（关于为何要对依赖诚实，感兴趣可以移步 精读《Function Component 入门》 - 永远对依赖诚实）。 回到 Vue 3.0，由于 setup 仅执行一次，因此函数本身只会创建一次，不存在多实例问题，不需要 useCallback 的概念，更不需要使用 lint 插件 保证依赖书写正确，这对开发者是实实在在的友好。 不需要使用 useEffect useMemo 等进行性能优化，所有性能优化都是自动的。 这也是实在话，毕竟 Mutable + 依赖自动收集就可以做到最小粒度的精确更新，根本不会触发不必要的 Rerender，因此 useMemo 这个概念也不需要了。 而 useEffect 也需要传递第二个参数 “依赖项”，在 Vue 中根本不需要传递 “依赖项”，所以也不会存在用户不小心传错的问题，更不需要像 React 写一个 lint 插件保证依赖的正确性。（这也是笔者想对 React Hooks 吐槽的点，React 团队如何保障每个人都安装了 lint？就算装了 lint，如果 IDE 有 BUG，导致没有生效，随时可能写出依赖不正确的 “危险代码”，造成比如死循环等严重后果） 3. 总结通过对比 Vue Hooks 与 React Hooks 可以发现，Vue 3.0 将 Mutable 特性完美与 Hooks 结合，规避了一些 React Hooks 的硬伤。所以我们可以说 Vue 借鉴了 React Hooks 的思想，但创造出来的确实一个更精美的艺术品。 但 React Hooks 遵循的 Immutable 也有好的一面，就是每次渲染中状态被稳定的固化下来了，不用担心状态突然变更带来的影响（其实反而要注意状态用不变更带来的影响），对于数据记录、程序运行的稳定性都有较高的可预期性。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://doubleray.top/tags/Vue/"}]},{"title":"重新思考 Redux","slug":"article-react-redux-think","date":"2019-07-06T05:13:05.000Z","updated":"2021-06-24T04:02:41.978Z","comments":true,"path":"2019/07/06/article-react-redux-think/","link":"","permalink":"https://doubleray.top/2019/07/06/article-react-redux-think/","excerpt":"1 引言《重新思考 Redux》是 rematch 作者 Shawn McKay 写的一篇干货软文。 dva 之后，有许多基于 redux 的状态管理框架，但大部分都很局限，甚至是倒退。但直到看到了 rematch，总算觉得 redux 社区又进了一步。 这篇文章的宝贵之处在于，抛开 Mobx、RXjs 概念，仅针对 redux 做深入的重新思考，对大部分还在使用 redux 的工程场景非常有帮助。","text":"1 引言《重新思考 Redux》是 rematch 作者 Shawn McKay 写的一篇干货软文。 dva 之后，有许多基于 redux 的状态管理框架，但大部分都很局限，甚至是倒退。但直到看到了 rematch，总算觉得 redux 社区又进了一步。 这篇文章的宝贵之处在于，抛开 Mobx、RXjs 概念，仅针对 redux 做深入的重新思考，对大部分还在使用 redux 的工程场景非常有帮助。 2 概述比较新颖的是，作者给出一个公式，评价一个框架或工具的质量： 工具质量 = 工具节省的时间/使用工具消耗的时间 如果这样评估原生的 redux，我们会发现，使用 redux 需要额外花费的时间可能超过了其节省下来的时间，从这个角度看，redux 是会降低工作效率的。 但 redux 的数据管理思想是正确的，复杂的前端项目也确实需要这种理念，为了更有效率的使用 redux，我们需要使用基于 redux 的框架。作者从 6 个角度阐述了基于 redux 的框架需要解决什么问题。 简化初始化redux 初始化代码涉及的概念比较多，比如 compose thunk 等等，同时将 reducer、initialState、middlewares 这三个重要概念拆分成了函数方式调用，而不是更容易接受的配置方式： 1234567const store = preloadedState =&gt; &#123; return createStore( rootReducer, preloadedState, compose(applyMiddleware(thunk, api), DevTools.instrument()) );&#125;; 如果换成配置方式，理解成本会降低不少： 12345const store = new Redux.Store(&#123; instialState: &#123;&#125;, reducers: &#123; count &#125;, middlewares: [api, devTools]&#125;); 笔者注：redux 的初始化方式非常函数式，而下面的配置方式就更面向对象一些。相比之下，还是面向对象的方式更好理解，毕竟 store 是一个对象。instialState 也存在同样问题，相比显示申明，将 preloadedState 作为函数入参就比较抽象了，同时 redux 对初始 state 的赋值也比较隐蔽，createStore 时统一赋值比较别扭，因为 reducers 是分散的，如果在 reducers 中赋值，要利用 es 的默认参数特性，看起来更像业务思考，而不是 redux 提供的能力。 简化 Reducersredux 的 reducer 粒度太大，不但导致函数内手动匹配 type，还带来了 type、payload 等理解成本： 12345678910const countReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case INCREMENT: return state + action.payload; case DECREMENT: return state - action.payload; default: return state; &#125;&#125;; 如果用配置的方式设置 reducers，就像定义一个对象一样，会更清晰： 1234const countReducer = &#123; INCREMENT: (state, action) =&gt; state + action.payload, DECREMENT: (state, action) =&gt; state - action.payload&#125;; 支持 async/awaitredux 支持动态数据还是挺费劲的，需要理解高阶函数，理解中间件的使用方式，否则你不会知道为什么这样写是对的： 1234const incrementAsync = count =&gt; async dispatch =&gt; &#123; await delay(); dispatch(increment(count));&#125;; 为什么不抹掉理解成本，直接允许 async 类型的 action 呢？ 1234const incrementAsync = async count =&gt; &#123; await delay(); dispatch(increment(count));&#125;; 笔者注：我们发现 rematch 的方式，dispatch 是 import 进来的（全局变量），而 redux 的 dispatch 是注入进来的，乍一看似乎 redux 更合理，但其实我更推崇 rematch 的方案。经过长期实践，组件最好不要使用数据流，项目的数据流只用一个实例完全够用了，全局 dispatch 的设计其实更合理，而注入 dispatch 的设计看似追求技术极致，但忽略了业务使用场景，导致画蛇添足，增加了不必要的麻烦。 将 action + reducer 改为两种 actionredux 抽象的 action 与 reducer 的指责很清晰，action 负责改 store 以外所有事，而 reducer 负责改 store，偶尔用来做数据处理。这种概念其实比较模糊，因为往往不清楚数据处理放在 action 还是 reducer 里，同时过于简单的 reducer 又要写 action 与之匹配，感觉过于形式化，而且繁琐。 重新考虑这个问题，我们只有两类 action：reducer action 与 effect action。 reducer action：改变 store。 effect action：处理异步场景，能调用其他 action，不能修改 store。 同步的场景，一个 reducer 函数就能处理，只有异步场景需要 effect action 处理掉异步部分，同步部分依然交给 reducer 函数，这两种 action 职责更清晰。 不再显示申明 action type不要在用一个文件存储 Action 类型了，const ACTION_ONE = &#39;ACTION_ONE&#39; 其实重复写了一遍字符串，直接用对象的 key 表示 action 的值，再加上 store 的 name 为前缀保证唯一性即可。 同时 redux 建议使用 payload key 来传值，那为什么不强制使用 payload 作为入参，而要通过 action.payload 取值呢？直接使用 payload 不但视觉上减少代码数量，容易理解，同时也强制约束了代码风格，让建议真正落地。 Reducer 直接作为 ActionCreatorredux 调用 action 比较繁琐，使用 dispatch 或者将 reducer 经过 ActionCreator 函数包装。为什么不直接给 reducer 自动包装 ActionCreator 呢？减少样板代码，让每一行代码都有业务含义。 最后作者给出了一个 rematch 完整的例子： 12345678910111213141516171819202122import &#123; init, dispatch &#125; from \"@rematch/core\";import delay from \"./makeMeWait\";const count = &#123; state: 0, reducers: &#123; increment: (state, payload) =&gt; state + payload, decrement: (state, payload) =&gt; state - payload &#125;, effects: &#123; async incrementAsync(payload) &#123; await delay(); this.increment(payload); &#125; &#125;&#125;;const store = init(&#123; models: &#123; count &#125;&#125;);dispatch.count.incrementAsync(1); 3 精读我觉得本文基本上把 redux 存在的工程问题分析透彻了，同时还给出了一套非常好的实现。 细节的极致优化首先是直接使用 payload 而不是整个 action 作为入参，加强了约束同时简化代码复杂度: 1increment: (state, payload) =&gt; state + payload; 其次使用 async 在 effects 函数中，使用 this.increment 函数调用方式，取代 put({type: &quot;increment&quot;})（dva），在 typescript 中拥有了类型支持，不但可以用自动跳转代替字符串搜索，还能校验参数类型，在 redux 框架中非常难得。 最后在 dispatch 函数，也提供了两种调用方式： 12dispatch(&#123; type: \"count/increment\", payload: 1 &#125;);dispatch.count.increment(1); 如果为了更好的类型支持，或者屏蔽 payload 概念，可以使用第二种方案，再一次简化 redux 概念。 内置了比较多的插件rematch 将常用的 reselect、persist、immer 等都集成为了插件，相对比较强化插件生态的概念。数据流对数据缓存，性能优化，开发体验优化都有进一步施展的空间，拥抱插件生态是一个良好的发展方向。 比如 rematch-immer 插件，可以用 mutable 的方式修改 store： 123456789const count = &#123; state: 0, reducers: &#123; add(state) &#123; state += 1; return state; &#125; &#125;&#125;; 但是当 state 为非对象时，immer 将不起作用，所以最好能养成 return state 的习惯。 最后说一点瑕疵的地方，reducers 申明与调用参数不一致。 Reducers 申明与调用参数不一致比如下面的 reducers： 12345678910111213const count = &#123; state: 0, reducers: &#123; increment: (state, payload) =&gt; state + payload, decrement: (state, payload) =&gt; state - payload &#125;, effects: &#123; async incrementAsync(payload) &#123; await delay(); this.increment(payload); &#125; &#125;&#125;; 定义时 increment 是两个参数，而 incrementAsync 调用它时，只有一个参数，这样可能造成一些误导，笔者建议保持参数对应关系，将 state 放在 this 中： 12345678910111213const count = &#123; state: 0, reducers: &#123; increment: payload =&gt; this.state + payload, decrement: payload =&gt; this.state - payload &#125;, effects: &#123; async incrementAsync(payload) &#123; await delay(); this.increment(payload); &#125; &#125;&#125;; 当然 rematch 的方式保持了函数的无副作性质，可以看出是做了一些取舍。 4 总结重复一下作者提出工具质量的公式： 工具质量 = 工具节省的时间/使用工具消耗的时间 如果一个工具能节省开发时间，但本身带来了很大使用成本，在想清楚如何减少使用成本之前，不要急着用在项目中，这是我得到的最大启发。 最后感谢 rematch 作者精益求精的精神，给 redux 带来进一步的极致优化。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://doubleray.top/tags/Redux/"}]},{"title":"如何安全地使用 React context","slug":"article-react-c-context","date":"2019-06-22T05:13:05.000Z","updated":"2021-06-24T04:02:41.975Z","comments":true,"path":"2019/06/22/article-react-c-context/","link":"","permalink":"https://doubleray.top/2019/06/22/article-react-c-context/","excerpt":"1 引言在 React 源码中，context 始终存在，却在 React 0.14 的官方文档中才有所体现。在目前最新的官方文档中，仍不建议使用 context，也表明 context 是一个实验性的 API，在未来 React 版本中可能被更改。那么哪些场景下需要用到 context，而哪些情况下应该避免使用，context 又有什么坑呢？让我们一起来讨论一下。","text":"1 引言在 React 源码中，context 始终存在，却在 React 0.14 的官方文档中才有所体现。在目前最新的官方文档中，仍不建议使用 context，也表明 context 是一个实验性的 API，在未来 React 版本中可能被更改。那么哪些场景下需要用到 context，而哪些情况下应该避免使用，context 又有什么坑呢？让我们一起来讨论一下。 2 内容概要React context 可以把数据直接传递给组件树的底层组件，而无需中间组件的参与。Redux 作者 Dan Abramov 为 contenxt 的使用总结了一些注意事项： 如果你是一个库的作者，需要将信息传递给深层次组件时，context 在一些情况下可能无法更新成功。 如果是界面主题、本地化信息，context 被应用于不易改变的全局变量，可以提供一个高阶组件，以便在 API 更新时只需修改一处。 如果库需要你使用 context，请它提供高阶组件给你。 正如 Dan 第一条所述，在 React issue 中，经常能找到 React.PureComponent、shouldComponentUpdate 与包含 Context 的库结合后引发的一些问题。原因在于 shouldComponentUpdate 会切断子树的 rerender，当 state 或 props 没有发生变化时，可能意外中断上层 context 传播。也就是当 shouldComponentUpdate 返回 false 时，context 的变化是无法被底层所感知的。 因此，我们认为 context 应该是不变的，在构造时只接受 context 一次，使用 context，应类似于依赖注入系统来进行。结合精读文章的示例总结一下思路，不变的 context 中包含可变的元素，元素的变化触发自身的监听器实现底层组件的更新，从而绕过 shouldComponentUpdate。 最后作者提出了 Mobx 下的两种解决方案。context 中的可变元素可用 observable 来实现，从而避免上述事件监听器编写，因为 observable 会帮你完成元素改变后的响应。当然 Provider + inject 也可以完成，具体可参考精读文章中的代码。 3 精读本次提出独到观点的同学有：@monkingxue @alcat2008 @ascoders，精读由此归纳。 context 的使用场景 In some cases, you want to pass data through the component tree without having to pass the props down manually at every level. context 的本质在于为组件树提供一种跨层级通信的能力，原本在 React 只能通过 props 逐层传递数据，而 context 打破了这一层束缚。 context 虽然不被建议使用，但在一些流行库中却非常常见，例如：react-redux、react-router。究其原因，我认为是单一顶层与多样底层间不是单纯父子关系的结果。例如：react-redux 中的 Provider，react-router 中的 Router，均在顶层控制 store 信息与路由信息。而对于 Connect 与 Route 而言，它们在 view 中的层级是多样化的，通过 context 获取顶层 Provider 与 Router 中的相关信息再合适不过。 context 的坑 context 相当于一个全局变量，难以追溯数据源，很难找到是在哪个地方中对 context 进行了更新。 组件中依赖 context，会使组件耦合度提高，既不利于组件复用，也不利于组件测试。 当 props 改变或是 setState 被调用，getChildContext 也会被调用，生成新的 context，但 shouldComponentUpdate 返回的 false 会 block 住 context，导致没有更新，这也是精读文章的重点内容。 4 总结正如精读文章开头所说，context 是一个非常强大的，具有很多免责声明的特性，就像伊甸园中的禁果。的确，引入全局变量似乎是应用混乱的开始，而 context 与 props/state 相比也实属异类。在业务代码中，我们应抵制使用 context，而在框架和库中可结合场景适当使用，相信 context 也并非洪水猛兽。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React Hooks","slug":"article-react-hooks-intro","date":"2019-05-19T05:13:05.000Z","updated":"2021-06-24T04:02:41.977Z","comments":true,"path":"2019/05/19/article-react-hooks-intro/","link":"","permalink":"https://doubleray.top/2019/05/19/article-react-hooks-intro/","excerpt":"1 引言React Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 状态共享可能描述的不恰当，称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。 为了更快理解 React Hooks 是什么，先看下面一段 renderProps 代码： 12345678910function App() &#123; return ( &lt;Toggle initial=&#123;false&#125;&gt; &#123;(&#123; on, toggle &#125;) =&gt; ( &lt;Button type=&quot;primary&quot; onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt; &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt; )&#125; &lt;/Toggle&gt; )&#125; 恰巧，React Hooks 解决的也是这个问题： 123456789101112131415function App() &#123; const [open, setOpen] = useState(false); return ( &lt;&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setOpen(true)&#125;&gt; Open Modal &lt;/Button&gt; &lt;Modal visible=&#123;open&#125; onOk=&#123;() =&gt; setOpen(false)&#125; onCancel=&#123;() =&gt; setOpen(false)&#125; /&gt; &lt;/&gt; );&#125; 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，这个组件是没有状态的。","text":"1 引言React Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 状态共享可能描述的不恰当，称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。 为了更快理解 React Hooks 是什么，先看下面一段 renderProps 代码： 12345678910function App() &#123; return ( &lt;Toggle initial=&#123;false&#125;&gt; &#123;(&#123; on, toggle &#125;) =&gt; ( &lt;Button type=&quot;primary&quot; onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt; &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt; )&#125; &lt;/Toggle&gt; )&#125; 恰巧，React Hooks 解决的也是这个问题： 123456789101112131415function App() &#123; const [open, setOpen] = useState(false); return ( &lt;&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setOpen(true)&#125;&gt; Open Modal &lt;/Button&gt; &lt;Modal visible=&#123;open&#125; onOk=&#123;() =&gt; setOpen(false)&#125; onCancel=&#123;() =&gt; setOpen(false)&#125; /&gt; &lt;/&gt; );&#125; 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，这个组件是没有状态的。 2 概述React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性： 多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。 Hooks 可以引用其他 Hooks。 更容易将组件的 UI 与状态分离。 第二点展开说一下：Hooks 可以引用其他 Hooks，我们可以这么做： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; useState, useEffect &#125; from &quot;react&quot;;// 底层 Hooks, 返回布尔值：是否在线function useFriendStatusBoolean(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125;// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offlinefunction useFriendStatusString(props) &#123; const isOnline = useFriendStatusBoolean(props.friend.id); if (isOnline === null) &#123; return &quot;Loading...&quot;; &#125; return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;&#125;// 使用了底层 Hooks 的 UIfunction FriendListItem(props) &#123; const isOnline = useFriendStatusBoolean(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? &quot;green&quot; : &quot;black&quot; &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;/li&gt; );&#125;// 使用了上层 Hooks 的 UIfunction FriendListStatus(props) &#123; const status = useFriendStatusString(props); return &lt;li&gt;&#123;status&#125;&lt;/li&gt;;&#125; 这个例子中，有两个 Hooks：useFriendStatusBoolean 与 useFriendStatusString, useFriendStatusString 是利用 useFriendStatusBoolean 生成的新 Hook，这两个 Hook 可以给不同的 UI：FriendListItem、FriendListStatus 使用，而因为两个 Hooks 数据是联动的，因此两个 UI 的状态也是联动的。 顺带一提，这个例子也可以用来理解 对 React Hooks 的一些思考 一文的那句话：“有状态的组件没有渲染，有渲染的组件没有状态”： useFriendStatusBoolean 与 useFriendStatusString 是有状态的组件（使用 useState），没有渲染（返回非 UI 的值），这样就可以作为 Custom Hooks 被任何 UI 组件调用。 FriendListItem 与 FriendListStatus 是有渲染的组件（返回了 JSX），没有状态（没有使用 useState），这就是一个纯函数 UI 组件， 利用 useState 创建 ReduxRedux 的精髓就是 Reducer，而利用 React Hooks 可以轻松创建一个 Redux 机制： 1234567891011// 这就是 Reduxfunction useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; 这个自定义 Hook 的 value 部分当作 redux 的 state，setValue 部分当作 redux 的 dispatch，合起来就是一个 redux。而 react-redux 的 connect 部分做的事情与 Hook 调用一样： 1234567891011121314151617181920212223// 一个 Actionfunction useTodos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: &quot;add&quot;, text &#125;); &#125; return [todos, &#123; handleAddClick &#125;];&#125;// 绑定 Todos 的 UIfunction TodosUI() &#123; const [todos, actions] = useTodos(); return ( &lt;&gt; &#123;todos.map((todo, index) =&gt; ( &lt;div&gt;&#123;todo.text&#125;&lt;/div&gt; ))&#125; &lt;button onClick=&#123;actions.handleAddClick&#125;&gt;Add Todo&lt;/button&gt; &lt;/&gt; );&#125; useReducer 已经作为一个内置 Hooks 了，在这里可以查阅所有 内置 Hooks。 不过这里需要注意的是，每次 useReducer 或者自己的 Custom Hooks 都不会持久化数据，所以比如我们创建两个 App，App1 与 App2: 1234567891011121314151617181920function App1() &#123; const [todos, actions] = useTodos(); return &lt;span&gt;todo count: &#123;todos.length&#125;&lt;/span&gt;;&#125;function App2() &#123; const [todos, actions] = useTodos(); return &lt;span&gt;todo count: &#123;todos.length&#125;&lt;/span&gt;;&#125;function All() &#123; return ( &lt;&gt; &lt;App1 /&gt; &lt;App2 /&gt; &lt;/&gt; );&#125; 这两个实例同时渲染时，并不是共享一个 todos 列表，而是分别存在两个独立 todos 列表。也就是 React Hooks 只提供状态处理方法，不会持久化状态。 如果要真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 useReducer 都会访问到同一份数据，可以和 useContext 一起使用。 大体思路是利用 useContext 共享一份数据，作为 Custom Hooks 的数据源。具体实现可以参考 redux-react-hook。 利用 useEffect 代替一些生命周期在 useState 位置附近，可以使用 useEffect 处理副作用： 1234567useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // Clean up the subscription subscription.unsubscribe(); &#125;;&#125;); useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程： 1234567891011121314151617181920212223242526272829303132class Component extends React.PureComponent&lt;Props, State&gt; &#123; private chart: G2.Chart = null; private rootDomRef: React.ReactInstance = null; componentDidMount() &#123; this.rootDom = ReactDOM.findDOMNode(this.rootDomRef) as HTMLDivElement; this.chart = new G2.Chart(&#123; container: document.getElementById(&quot;chart&quot;), forceFit: true, height: 300 &#125;); this.freshChart(this.props); &#125; componentWillReceiveProps(nextProps: Props) &#123; this.freshChart(nextProps); &#125; componentWillUnmount() &#123; this.chart.destroy(); &#125; freshChart(props: Props) &#123; // do something this.chart.render(); &#125; render() &#123; return &lt;div ref=&#123;ref =&gt; (this.rootDomRef = ref)&#125; /&gt;; &#125;&#125; 用 React Hooks 可以这么做： 12345678910111213141516171819function App() &#123; const ref = React.useRef(null); let chart: G2.Chart = null; React.useEffect(() =&gt; &#123; chart = new G2.Chart(&#123; container: ReactDOM.findDOMNode(ref.current) as HTMLDivElement, width: 500, height: 500 &#125;); // do something chart.render(); return () =&gt; chart.destroy(); &#125;, []); return &lt;div ref=&#123;ref&#125; /&gt;;&#125; 可以看到将细碎的代码片段结合成了一个完整的代码块，更易维护。 现在介绍了 useState useContext useEffect useRef 等常用 hooks，更多可以查阅：内置 Hooks，相信不久的未来，这些 API 又会成为一套新的前端规范。 Hooks 带来的约定Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。 为什么不能用 condition 包裹 useHook 语句，详情可以见 官方文档，这里简单介绍一下。 React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。 虽然有 eslint-plugin-react-hooks 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的代码命名和顺序限制（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。 笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！” React 约定大于配置脚手架 nextjs umi 以及笔者的 pri 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，那么 React Hooks 就像代码级别的约定，大大降低了代码复杂度。 状态与 UI 的界限会越来越清晰因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。 不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。 1234function App() &#123; const [count, setCount] = useCount(); return &lt;span&gt;&#123;count&#125;&lt;/span&gt;;&#125; 我们知道 useCount 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了： 12345&lt;Count&gt;&#123;(count, setCount) =&gt; &lt;App count=&#123;count&#125; setCount=&#123;setCount&#125; /&gt;&#125;&lt;/Count&gt;;function App(props) &#123; return &lt;span&gt;&#123;props.count&#125;&lt;/span&gt;;&#125; 可以看到 App 组件是无状态的，输出完全由输入（Props）决定。 那么有状态无 UI 的组件就是 useCount 了： 1234function useCount() &#123; const [count, setCount] = useState(0); return [count, setCount];&#125; 有状态的地方应该指 useState(0) 这句，不过这句和无状态 UI 组件 App 的 useCount() 很像，既然 React 把 useCount 成为自定义 Hook，那么 useState 就是官方 Hook，具有一样的定义，因此可以认为 useCount 是无状态的，useState 也是一层 renderProps，最终的状态其实是 useState 这个 React 内置的组件。 我们看 renderProps 嵌套的表达： 123456789&lt;UseState&gt; &#123;(count, setCount) =&gt; ( &lt;UseCount&gt; &#123;&quot; &quot;&#125; &#123;/**虽然是透传，但给 count 做了去重，不可谓没有作用 */&#125; &#123;(count, setCount) =&gt; &lt;App count=&#123;count&#125; setCount=&#123;setCount&#125; /&gt;&#125; &lt;/UseCount&gt; )&#125;&lt;/UseState&gt; 能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。 3 总结把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React 高阶组件","slug":"article-react-hoc","date":"2019-05-18T05:13:05.000Z","updated":"2021-06-24T04:02:41.977Z","comments":true,"path":"2019/05/18/article-react-hoc/","link":"","permalink":"https://doubleray.top/2019/05/18/article-react-hoc/","excerpt":"1 引言高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。 高阶组件的概念其实并不难，我们能通过类比高阶函数迅速掌握。高阶函数是把函数作为参数传入到函数中并返回一个新的函数。这里我们把函数替换为组件，就是高阶组件了。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 当然了解高阶组件的概念只是万里长征第一步，精读文章在阐述其概念与实现外，也强调了其重要性与局限性，以及与其他方案的比较，让我们一起来领略吧。","text":"1 引言高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。 高阶组件的概念其实并不难，我们能通过类比高阶函数迅速掌握。高阶函数是把函数作为参数传入到函数中并返回一个新的函数。这里我们把函数替换为组件，就是高阶组件了。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 当然了解高阶组件的概念只是万里长征第一步，精读文章在阐述其概念与实现外，也强调了其重要性与局限性，以及与其他方案的比较，让我们一起来领略吧。 2 内容概要高阶组件常见有两种实现方式，一种是 Props Proxy，它能够对 WrappedComponent 的 props 进行操作，提取 WrappedComponent state 以及使用其他元素来包裹 WrappedComponent。Props Proxy 作为一层代理，具有隔离的作用，因此传入 WrappedComponent 的 ref 将无法访问到其本身，需要在 Props Proxy 内完成中转，具体可参考以下代码，react-redux 也是这样实现的。 此外各个 Props Proxy 的默认名称是相同的，需要根据 WrappedComponent 来进行不同命名。 12345678910111213141516171819202122232425262728293031323334353637383940414243function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; // 实现 HOC 不同的命名 static displayName = `HOC($&#123;WrappedComponent.displayName&#125;)`; getWrappedInstance() &#123; return this.wrappedInstance; &#125; // 实现 ref 的访问 setWrappedInstance(ref) &#123; this.wrappedInstance = ref; &#125; render() &#123; return &lt;WrappedComponent &#123; ...this.props, ref: this.setWrappedInstance.bind(this), &#125; /&gt; &#125; &#125;&#125;@ppHOCclass Example extends React.Component &#123; static displayName = 'Example'; handleClick() &#123; ... &#125; ...&#125;class App extends React.Component &#123; handleClick() &#123; this.refs.example.getWrappedInstance().handleClick(); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/button&gt; &lt;Example ref=\"example\" /&gt; &lt;/div&gt; ); &#125;&#125; 另一种是 Inheritance Inversion，HOC 类继承了 WrappedComponent，意味着可以访问到 WrappedComponent 的 state、props、生命周期和 render 等方法。如果在 HOC 中定义了与 WrappedComponent 同名方法，将会发生覆盖，就必须手动通过 super 进行调用了。通过完全操作 WrappedComponent 的 render 方法返回的元素树，可以真正实现渲染劫持。这种方案依然是继承的思想，对于 WrappedComponent 也有较强的侵入性，因此并不常见。 123456789101112131415function ppHOC(WrappedComponent) &#123; return class ExampleEnhance extends WrappedComponent &#123; ... componentDidMount() &#123; super.componentDidMount(); &#125; componentWillUnmount() &#123; super.componentWillUnmount(); &#125; render() &#123; ... return super.render(); &#125; &#125;&#125; 3 精读本次提出独到观点的同学有：@monkingxue @alcat2008 @淡苍 @camsong，精读由此归纳。 HOC 的适用范围对比 HOC 范式 compose(render)(state) 与父组件（Parent Component）的范式 render(render(state))，如果完全利用 HOC 来实现 React 的 implement，将操作与 view 分离，也未尝不可，但却不优雅。HOC 本质上是统一功能抽象，强调逻辑与 UI 分离。但在实际开发中，前端无法逃离 DOM ，而逻辑与 DOM 的相关性主要呈现 3 种关联形式： 与 DOM 相关，建议使用父组件，类似于原生 HTML 编写 与 DOM 不相关，如校验、权限、请求发送、数据转换这类，通过数据变化间接控制 DOM，可以使用 HOC 抽象 交叉的部分，DOM 相关，但可以做到完全内聚，即这些 DOM 不会和外部有关联，均可 DOM 的渲染适合使用父组件，这是 React JSX 原生支持的方式，清晰易懂。最好是能封装成木偶组件（Dumb Component）。HOC 适合做 DOM 不相关又是多个组件共性的操作。如 Form 中，validator 校验操作就是纯数据操作的，放到了 HOC 中。但 validator 信息没有放到 HOC 中。但如果能把 Error 信息展示这些逻辑能够完全隔离，也可以放到 HOC 中（可结合下一小节 Form 具体实践详细了解）。数据请求是另一类 DOM 不相关的场景，react-refetch 的实现就是使用了 HOC，做到了高效和优雅： 1234connect(props =&gt; (&#123; usersFetch: `/users?status=$&#123;props.status&#125;&amp;page=$&#123;props.page&#125;`, userStatsFetch: &#123; url: `/users/stats`, force: true &#125;&#125;))(UsersList) HOC 的具体实践HOC 在真实场景下的运行非常多，之前笔者在 基于Decorator的组件扩展实践 一文中也提过使用高阶组件将更细粒度的组件组合成 Selector 与 Search。结合精读文章，这次让我们通过 Form 组件的抽象来表现 HOC 具有的良好扩展机制。 Form 中会包含各种不同的组件，常见的有 Input、Selector、Checkbox 等等，也会有根据业务需求加入的自定义组件。Form 灵活多变，从功能上看，表单校验可能为单组件值校验，也可能为全表单值校验，可能为常规检验，比如：非空、输入限制，也可能需要与服务端配合，甚至需要根据业务特点进行定制。从 UI 上看，检验结果显示的位置，可能在组件下方，也可能是在组件右侧。 直接裸写 Form，无疑是机械而又重复的。将 Form 中组件的 value 经过 validator，把 value，validator 产生的 error 信息储存到 state 或 redux store 中，然后在 view 层完成显示。这条路大家都是相同的，可以进行复用，只是我们面对的是不同的组件，不同的 validator，不同的 view 而已。对于 Form 而言，既要满足通用，又要满足部分个性化的需求，以往单纯的配置化只会让使用愈加繁琐，我们所需要抽象的是 Form 功能而非 UI，因此通过 HOC 针对 Form 的功能进行提取就成为了必然。 至于 HOC 在 Form 上的具体实现，首先将表单中的组件（Input、Selector…）与相应 validator 与组件值回调函数名（trigger）传入 Decorator，将 validator 与 trigger 相绑定。Decorator 完成了各种不同组件与 Form 内置 Store 间 value 的传递、校验功能的抽象，即精读文章中提到 Props Proxy 方式的其中两种作用：提取state 与 操作props 12345678910111213141516171819202122232425262728function formFactoryFactory(&#123; validator, trigger = 'onChange', ...&#125;) &#123; return FormFactory(WrappedComponent) &#123; return class Decorator extends React.Component &#123; getBind(trigger, validator) &#123; ... &#125; render() &#123; const newProps = &#123; ...this.props, [trigger]: this.getBind(trigger, validator), ... &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt; &#125; &#125; &#125;&#125;// 调用formFactoryFactory(&#123; validator: (value) =&gt; &#123; return value !== ''; &#125;&#125;)(&lt;Input placeholder=\"请输入...\" /&gt;) 当然为了考虑个性化需求，Form Store 也向外暴露很多 API，可以直接获取和修改 value、error 的值。现在我们需要对一个表单的所有值提交到后端进行校验，根据后端返回，分别列出各项的校验错误信息，就需要借助相应项的 setError 去完成了。 这里主要参考了 rc-form 的实现方式，有兴趣的读者可以阅读其源码。 12345678910111213141516171819202122232425import &#123; createForm &#125; from 'rc-form';class Form extends React.Component &#123; submit = () =&gt; &#123; this.props.form.validateFields((error, value) =&gt; &#123; console.log(error, value); &#125;); &#125; render() &#123; const &#123; getFieldError, getFieldDecorator &#125; = this.props.form; const errors = getFieldError('required'); return ( &lt;div&gt; &#123;getFieldDecorator('required', &#123; rules: [&#123; required: true &#125;], &#125;)(&lt;Input /&gt;)&#125; &#123;errors ? errors.join(',') : null&#125; &lt;button onClick=&#123;this.submit&#125;&gt;submit&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export createForm()(Form); 4 总结React 始终强调组合优于继承的理念，期望通过复用小组件来构建大组件使得开发变得简单而又高效，与传统面向对象思想是截然不同的。高阶函数（HOC）的出现替代了原有 Mixin 侵入式的方案，对比隐式的 Mixin 或是继承，HOC 能够在 Devtools 中显示出来，满足抽象之余，也方便了开发与测试。当然，不可过度抽象是我们始终要秉持的原则。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"setState 做了什么","slug":"article-react-setstate","date":"2019-04-13T05:13:05.000Z","updated":"2021-06-24T04:02:41.978Z","comments":true,"path":"2019/04/13/article-react-setstate/","link":"","permalink":"https://doubleray.top/2019/04/13/article-react-setstate/","excerpt":"1 引言setState 是 React 框架最常用的命令，它是用来更新状态的，这也是 React 框架划时代的功能。 但是 setState 函数是 react 包导出的，他们又是如何与 react-dom react-native react-art 这些包结合的呢？","text":"1 引言setState 是 React 框架最常用的命令，它是用来更新状态的，这也是 React 框架划时代的功能。 但是 setState 函数是 react 包导出的，他们又是如何与 react-dom react-native react-art 这些包结合的呢？ 2 概述setState 函数是在 React.Component 组件中调用的，所以最自然的联想是，更新 DOM 的逻辑在 react 包中实现。 但是 react 却可以和 react-dom react-native react-art 这些包打配合，甚至与 react-dom/server 配合在服务端运行，那可以肯定 react 包中不含有 DOM 更新逻辑。 所以可以推断，平台相关的 UI 更新逻辑分布在平台相关的包里，react 包只做了代理。 React 引擎不在 react 包里从 react 0.14 版本之后，引擎代码就从 react 包中抽离了，react 包仅仅做通用接口抽象。 也就是说，react 包定义了标准的状态驱动模型的 API，而 react-dom react-native react-art 这些包是在各自平台的具体实现。 各平台具体的渲染引擎实现被称为 reconciler，通过这个链接可以看到 react-dom react-native react-art 这三个包的 reconciler 实现。 这说明了 react 包仅告诉你 React 拥有哪些语法，而并不关心如何实现他们，所以我们需要结合 react 包与 react-xxx 一起使用。 对于 context，react 包仅仅会做如下定义： 1234567891011121314151617// A bit simplifiedfunction createContext(defaultValue) &#123; let context = &#123; _currentValue: defaultValue, Provider: null, Consumer: null &#125;; context.Provider = &#123; $$typeof: Symbol.for(\"react.provider\"), _context: context &#125;; context.Consumer = &#123; $$typeof: Symbol.for(\"react.context\"), _context: context &#125;; return context;&#125; 具体用到时，由 react-dom 和 react-native 决定用何种方式实现 MyContext.Provider 这个 API。 这也说明了，如果你不同步升级 react 与 react-dom 版本的话，就可能碰到这样的报错：fail saying these types are invalid，原因是 API 定义与实现不匹配。 setState 怎么调用平台实现每个平台对 UI 更新逻辑的实现，会封装在 updater 函数里，所以不同平台代码会为组件添加各自的 updater 实现： 1234567891011121314// Inside React DOMconst inst = new YourComponent();inst.props = props;inst.updater = ReactDOMUpdater;// Inside React DOM Serverconst inst = new YourComponent();inst.props = props;inst.updater = ReactDOMServerUpdater;// Inside React Nativeconst inst = new YourComponent();inst.props = props;inst.updater = ReactNativeUpdater; 不同于 props, updater 无法被直接调用，因为这个 API 是由 react 引擎在 setState 时调用的： 12345// A bit simplifiedsetState(partialState, callback) &#123; // Use the `updater` field to talk back to the renderer! this.updater.enqueueSetState(this, partialState, callback);&#125; 关系可以这么描述：react -&gt; setState -&gt; updater &lt;- react-dom 等。 HooksHooks 的原理与 setState 类似，当调用 useState 或 useEffect 时，其内部调用如下： 1234567891011121314// In React (simplified a bit)const React = &#123; // Real property is hidden a bit deeper, see if you can find it! __currentDispatcher: null, useState(initialState) &#123; return React.__currentDispatcher.useState(initialState); &#125;, useEffect(initialState) &#123; return React.__currentDispatcher.useEffect(initialState); &#125; // ...&#125;; ReactDOM 提供了 __currentDispatcher（简化的说法）: 12345678910// In React DOMconst prevDispatcher = React.__currentDispatcher;React.__currentDispatcher = ReactDOMDispatcher;let result;try &#123; result = YourComponent(props);&#125; finally &#123; // Restore it back React.__currentDispatcher = prevDispatcher;&#125; 可以看到，Hooks 的原理与 setState 基本一致，但需要注意 react 与 react-dom 之间传递了 dispatch，虽然你看不到。但这个 dispatch 必须对应到唯一的 React 实例，这就是为什么 Hooks 不允许同时加载多个 React 实例的原因。 和 updater 一样，dispatch 也可以被各平台实现重写，比如 react-debug-hooks 就重写了 dispatcher。 由于需要同时实现 readContext, useCallback, useContext, useEffect, useImperativeMethods, useLayoutEffect, useMemo, useReducer, useRef, useState，工程量比较浩大，建议了解基本架构就足够了，除非你要深入参与 React 生态建设。 3 精读与其他 React 分析文章不同，本文并没有过于刨根问题的上来就剖析 reconciler 实现，而是问了一个最基本的疑问：为什么 setState 来自 react 包，但实现却在 react-dom 里？React 是如何实现这个 magic 的？ 通过这个疑问，我们了解了 React 更上层的抽象能力，如何用一个包制定规范，用 N 包去实现它。 接口的力量在日常编程中，接口也拥有的强大力量，下面举几个例子。 UI 组件跨三端的接口由于 RN、Weex、Flutter 的某些不足，越来越多的人选择 “一个思想三端实现” 的方式做跨三端的 UI 组件，这样既兼顾了性能，又可以照顾到平台差异性，对不同平台组件细节做定制优化。 要实施这个方案，最大问题就是接口约定。一定要保证三套实现遵循同一套 API 接口，业务代码才可以实现 “针对任意一个平台编写，自动移植到其他平台”。 比较常用的做法是，通过一套统一的 API 文件约束，固定组件的输入输出，不同平台的组件做平台具体实现。这个思想和 React 如出一辙。 当然 RN 这些框架本身也是同一接口在不同平台实现的典型，只是做的不够彻底，JS 与 Native 的通信导致了性能不如原生。 通用数据查询服务通用数据查询服务也比较流行，通过磨平各数据库语法，让用户通过一套 SQL 查询各种类型数据库的数据。 这个方案中，一套通用的查询语法就类似 React 定义的 API，执行阶段会转化为各数据库平台的 SQL 方言。 小程序融合方案现在这种方案很火。通过基于 template 或者 jsx 的语法，一键发布到各平台小程序应用。 这种方案一定会抽象一套通用语法，甚至几乎等价与 react 与 react-dom 的关系：所有符合规范的语法，转化为各小程序平台的实现。 4 总结这种分平台实现方案与跨平台方案还是有很大区别的，像 JAVA 虚拟机本质还是一套实现方案。而分平台的实现可以带来最原生的性能与体验，同样收到的约束也最大，应该其 API 应该是所有平台支持的一个子集。 另外，这种方案不仅可以用于 一套规范，不同平台的实现，甚至可以用在 “同一平台的实现”。 无论是公司还是开源节界，都有许多重复的轮子或者平台，如果通过技术委员会约定一套平台的实现规范，大家都遵循这个规范开发平台，那未来就比较好做收敛，或者说收敛的第一步都是先统一 API 规范。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React 的多态性","slug":"article-react-surprising-polymorphism","date":"2019-03-09T05:13:05.000Z","updated":"2021-06-24T04:02:41.979Z","comments":true,"path":"2019/03/09/article-react-surprising-polymorphism/","link":"","permalink":"https://doubleray.top/2019/03/09/article-react-surprising-polymorphism/","excerpt":"1 引言参考的文章是：surprising-polymorphism-in-react-applications，看看作者是如何解释这个多态性含义的。 读完文章才发现，文章标题改为 Redux 的多态性更妥当，因为整篇文章都在说 Redux，而 Redux 使用场景不局限于 React。","text":"1 引言参考的文章是：surprising-polymorphism-in-react-applications，看看作者是如何解释这个多态性含义的。 读完文章才发现，文章标题改为 Redux 的多态性更妥当，因为整篇文章都在说 Redux，而 Redux 使用场景不局限于 React。 2 概述Redux immutable 特性可能产生浏览器无法优化的性能问题，也就是浏览器无法做 shapes 优化，也就是上一篇精读《JS 引擎基础之 Shapes and Inline Caches》 里提到的。 先看看普通的 redux 的 reducer： 123456789101112131415161718192021const todo = (state = &#123;&#125;, action) =&gt; &#123; switch (action.type) &#123; case \"ADD_TODO\": return &#123; id: action.id, text: action.text, completed: false &#125;; case \"TOGGLE_TODO\": if (state.id !== action.id) &#123; return state; &#125; return Object.assign(&#123;&#125;, state, &#123; completed: !state.completed &#125;); default: return state; &#125;&#125;; 我们简化一下使用场景，假设基于这个 reducer todo，生成了两个新 store s1 s2： 12345678910111213const s1 = todo( &#123;&#125;, &#123; type: \"ADD_TODO\", id: 1, text: \"Finish blog post\" &#125;);const s2 = todo(s1, &#123; type: \"TOGGLE_TODO\", id: 1&#125;); 看上去很常见，也的确如此，我们每次 dispatch 都会根据 reducer 生成新的 store 树，而且是一个新的对象。然而对 js 引擎而言，这样的代码可能做不了 Shapes 优化（关于 Shapes 优化建议阅读上一期精读 Shapes 优化），也就是最需要做优化的全局 store，在生成新 store 时无法被浏览器优化，这个问题很容易被忽视，但的确影响不小。 至于为什么会阻止 js 引擎的 shapes 优化，看下面的代码： 1234567891011// transition-trees.jslet a = &#123;x:1, y:2, z:3&#125;;let b = &#123;&#125;;b.x = 1;b.y = 2;b.z = 3;console.log(\"a is\", a);console.log(\"b is\", b);console.log(\"a and b have same map:\", %HaveSameMap(a, b)); 通过 node --allow-natives-syntax test.js 执行，通过调用 node 原生函数 %HaveSameMap 判断这种情况下 a 与 b 是否共享一个 shape（v8 引擎的 Shape 实现称为 Map）。 结果是 false，也就是 js 引擎无法对 a b 做 Shapes 优化，这是因为 a 与 b 对象初始化的方式不同。 同样，在 Redux 代码中常用的 Object.assign 也有这个问题： 因为新的对象以 {} 空对象作为最初状态，js 引擎会为新对象创建 Empty Shape，这与原对象的 Shape 一定不同。 顺带一提 es6 的解构语法也存在同样的问题，因为 babel 将解构最终解析为 Object.assign： 对这种尴尬的情况，作者的建议是对所有对象赋值时都是用 Object.assign 以保证 js 引擎可以做 Shapes 优化： 1234567let a = Object.assign(&#123;&#125;, &#123;x:1, y:2, z:3&#125;);let b = Object.assign(&#123;&#125;, a);console.log(\"a is\", a);console.log(\"b is\", b);console.log(\"a and b have same map:\", %HaveSameMap(a, b)); // true 3 精读这篇文章需要与上一篇 精读《JS 引擎基础之 Shapes and Inline Caches》 连起来看容易理解。 作者描述的性能问题是引擎级别的 Shapes 优化问题，读过上篇精读就很容易知道，只有相同初始化方式的对象才被 js 引擎做优化，而 Redux 频繁生成的 immutable 全局 store 是否能被优化呢？答案是“往往不能”，因为 immutable 赋值问题，我们往往采用 Object.assign 或者解构方式赋值，这种方式产生的新对象与原对象的 Shape 不同，导致 Shape 无法复用。 这里解释一下疑惑，为什么说 immutable 对象之间也要优化呢？这不是两个不同的引用吗？这是因为 js 引擎级别的 Shapes 优化就是针对不同引用的对象，将对象的结构：Shape 与数据分离开，这样可以大幅优化存储效率，对数组也一样，上一篇精读有详细介绍。 所以笔者更推荐使用比如 immutable-js 这种库操作 immutable 对象，而不是 Object.assign，因为封装库内部是可能通过统一对象初始化方式利用 js 引擎进行优化的。 4 总结原文提到的多态是指多个相同结构对象，被拆分成了多个 Shape；而单态是指这些对象可以被一个 Shape 复用。 笔者以前也经历过从 Object.assign 到 Immutablejs 库，最后又回到解构新语法的经历，觉得在层级不深情况下解构语法可以代替 Immutablejs 库。 通过最近两篇精读的分析，我们需要重新思考这样做带来的优缺点，因为在 js 环境中，Object.assign 的优化效率比 Immutablejs 库更低。 最后，也完全没必要现在就开始重构，因为这只是 js 运行环境中很小一部分影响因素，比如为了引入 Immutablejs 让你的网络延时增加了 100%？所以仅在有必要的时候优化它。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React 八种条件渲染","slug":"article-react-condition-render","date":"2019-02-23T05:13:05.000Z","updated":"2021-06-24T04:02:41.977Z","comments":true,"path":"2019/02/23/article-react-condition-render/","link":"","permalink":"https://doubleray.top/2019/02/23/article-react-condition-render/","excerpt":"1 引言8 React conditional rendering methods 介绍了八种 React 条件渲染方式。 模板条件渲染非常常见，遇到的时候往往会随机选择一种方式使用，那么怎么写会有较好的维护性呢？先一起了解下有哪八种条件渲染方式吧！","text":"1 引言8 React conditional rendering methods 介绍了八种 React 条件渲染方式。 模板条件渲染非常常见，遇到的时候往往会随机选择一种方式使用，那么怎么写会有较好的维护性呢？先一起了解下有哪八种条件渲染方式吧！ 2 概述IF/ELSE既然 JSX 支持 js 与 html 混写，那么交替使用就能解决条件渲染的问题： 1234567function render() &#123; if (renderComponent1) &#123; return &lt;Component1 /&gt;; &#125; else &#123; return &lt;div /&gt;; &#125;&#125; return null如果不想渲染空元素，最好使用 null 代替空的 div： 1234567function render() &#123; if (renderComponent1) &#123; return &lt;Component1 /&gt;; &#125; else &#123; return null; &#125;&#125; 这样对 React 渲染效率有提升。 组件变量将组件赋值到变量，就可以在 return 前任意修改它了。 123456789function render() &#123; let component = null; if (renderComponent1) &#123; component = &lt;Component1 /&gt;; &#125; return component;&#125; 三元运算符三元运算符的语法如下： 1condition ? expr_if_true : expr_if_false 用在 JSX 上也很方便： 123function render() &#123; return renderComponent1 ? &lt;Component1 /&gt; : null;&#125; 但三元运算符产生嵌套时，理解成本会变得很高。 &amp;&amp;这个是最常用了，因为代码量最少。 123function render() &#123; return renderComponent1 &amp;&amp; &lt;Component1 /&gt;;&#125; IIFEIIFE 含义是立即执行函数，也就是如下代码： 123(function myFunction(/* arguments */) &#123; // ...&#125;)(/* arguments */); 当深陷 JSX 代码中，又想写一大块逻辑时，除了回到上方，还可以使用 IIFE： 12345678910111213function render() &#123; return ( &lt;div&gt; &#123;(() =&gt; &#123; if (renderComponent1) &#123; return &lt;Component1 /&gt;; &#125; else &#123; return &lt;div /&gt;; &#125; &#125;)()&#125; &lt;/div&gt; );&#125; 子组件这是 IIFE 的变种，也就是把这段立即执行函数替换成一个普通函数： 123456789101112131415function render() &#123; return ( &lt;div&gt; &lt;SubRender /&gt; &lt;/div&gt; );&#125;function SubRender() &#123; if (renderComponent1) &#123; return &lt;Component1 /&gt;; &#125; else &#123; return &lt;div /&gt;; &#125;&#125; IF 组件做一个条件渲染组件 IF 代替 js 函数的 if： 123&lt;If condition=&#123;true&#125;&gt; &lt;span&gt;Hi!&lt;/span&gt;&lt;/If&gt; 这个组件实现也很简单 1234567const If = props =&gt; &#123; const condition = props.condition || false; const positive = props.then || null; const negative = props.else || null; return condition ? positive : negative;&#125;; 高阶组件高阶组件，就是返回一个新组件的函数，并且接收一个组件作为参数。 那么我们就能在高阶组件里写条件语句，返回不同的组件即可： 123456789function higherOrderComponent(Component) &#123; return function EnhancedComponent(props) &#123; if (condition) &#123; return &lt;AnotherComponent &#123;...props&#125; /&gt;; &#125; return &lt;Component &#123;...props&#125; /&gt;; &#125;;&#125; 3 精读这么多方法都能实现条件渲染，那么重点在于可读性与可维护性。 比如通过调用函数实现组件渲染： 1&lt;div&gt;&#123;renderButton()&#125;&lt;/div&gt; 看上去还是比较冗余，如果使用 renderButton getter 定义，我们就可以这么写它： 1&lt;div&gt;&#123;button&#125;&lt;/div&gt; 其实我们想要的就是 button，而不是 renderButton。那么还可以进一步，干脆封装成 JSX 组件： 123&lt;div&gt; &lt;Button /&gt;&lt;/div&gt; 是否要付出这些努力，取决于应用的复杂度。如果应用复杂度非常高，那你应当尽量使用最后一种封装，让每个文件的逻辑尽量独立、简单。 如果应用复杂度比较低，那么注意不要过度封装，以免把自己绕进去。 所以看来这又是一个没有固定答案的问题，选择何种方式封装，取决于应用复杂度。 应用复杂度对任何代码封装，都会增加这段 连接逻辑 的复杂度。 假定无论如何代码的复杂度都是恒定不变的，下面这段代码，连接复杂度为 0，而对于 render 函数而言，逻辑复杂度是 100： 1234567function render() &#123; if (renderComponent) &#123; return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;; &#125; else &#123; return &lt;div /&gt;; &#125;&#125; 下面这段代码拆成了两个函数，逻辑复杂度对 render SubComponent 来说都是 50，但连接复杂度是 50： 1234567891011function render() &#123; if (renderComponent) &#123; return &lt;SubComponent&gt;; &#125; else &#123; return &lt;div /&gt;; &#125;&#125;function SubComponent() &#123; return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;&#125; 可以看到，我们通过函数拆分，降低了每个函数的逻辑复杂度，但却提高了连接复杂度。 下面来做一个比较，我们假设一个正常的程序员，可以一次性轻松记忆 10 个函数。如果再多，函数之间的调用关系就会让人摸不着头脑。 应用较小时在应用代码量比较小时，假设一共有 10 个函数，如果做了逻辑抽象，拆分出了 10 个子函数，那么总逻辑复杂度不变，函数变成了 20 个。 此时小王要修改此项目，他需要找到关键代码的位置。 如果没有做逻辑抽象，小王一下子就记住了 10 个函数，并且很快完成了需求。 如果应用做了逻辑抽象，他需要理解的逻辑复杂度是不变的，但是要读的函数变成了 20 个。小王需要像侦探一样在线索中不断跳转，他还是只找了 10 个关键函数，但一共也就 20 个函数，逻辑并不复杂，这值得吗？ 小王心里可能会嘀咕：简单的逻辑瞎抽象，害我文件找了半天！ 应用较大时此时应用代码量比较大，假设一共有 500 个函数，我们不考虑抽象后带来的复用好处，假设都无法复用，那么做了逻辑抽象后，那么总逻辑复杂度不变，函数变成了 1000 个。 此时小王接到了需求，终于维护了一个大项目。 小王知道这个项目很复杂，从一开始就没觉得能理解项目全貌，所以把自己当作一名侦探，准备一步步探索。 现在有两种选择，一种是在未做逻辑抽象时探索，一种是在做过逻辑抽象后探索。 如果没做逻辑抽象，小王需要面对 500 个这种函数： 1234567function render() &#123; if (renderComponent) &#123; return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;; &#125; else &#123; return isReady ? &lt;Component3 /&gt; : &lt;Component4 /&gt;; &#125;&#125; 如果做了逻辑抽象，小王需要面对 1000 个这种函数： 1234567function render() &#123; if (renderComponent) &#123; return &lt;Component1And2 /&gt;; &#125; else &#123; return &lt;Component3And4 /&gt;; &#125;&#125; 在项目庞大后，总函数数量并不会影响对线索的查找，而总线索深度也几乎总是固定的，一般在 5 层左右。 小王理解 5 个或 10 个函数成本都差不多，但没有做逻辑抽象时，这 5 个函数各自参杂了其他逻辑，反而影响对函数的理解。 这时做逻辑抽象是合适的。 4 总结所以总的来说，笔者更倾向使用子函数、子组件、IF 组件、高阶组件做条件渲染，因为这四种方式都能提高程序的抽象能力。 往往抽象后的代码会更具有复用性，单个函数逻辑更清晰，在切面编程时更利于理解。 当项目很简单时，整个项目的理解成本都很低，抽象带来的复杂度反而让项目变成了需要切面编程的时候，就得不偿失了。 总结一下： 当项目很简单，或者条件渲染的逻辑确认无法复用时，推荐在代码中用 &amp;&amp; 或者三元运算符、IIFE 等直接实现条件渲染。 当项目很复杂时，尽量都使用 子函数、子组件、IF 组件、高阶组件 等方式做更有抽象度的条件渲染。 在做逻辑抽象时，考虑下项目的复杂度，避免因为抽象带来的成本增加，让本可以整体理解的项目变得支离破碎。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React 代码整洁之道","slug":"article-react-clean","date":"2019-01-26T05:13:05.000Z","updated":"2021-06-24T04:02:41.976Z","comments":true,"path":"2019/01/26/article-react-clean/","link":"","permalink":"https://doubleray.top/2019/01/26/article-react-clean/","excerpt":"1 引言编程也是艺术行为，当我们思考代码复用、变量命名时，就是在进行艺术思考。 可能这篇文章没法提高面试能力、开发效率，因为涉及的内容都是 “软能力”。但如果与我一样，时常害怕自己代码不够优雅，那就在茶余饭后看看这篇文章，也许，可以解决一部分你心中的困惑。","text":"1 引言编程也是艺术行为，当我们思考代码复用、变量命名时，就是在进行艺术思考。 可能这篇文章没法提高面试能力、开发效率，因为涉及的内容都是 “软能力”。但如果与我一样，时常害怕自己代码不够优雅，那就在茶余饭后看看这篇文章，也许，可以解决一部分你心中的困惑。 2 内容概要作者整理了几个好的思维习惯，尝试认同它，再看看如何实践。 不冗余避免重复代码段，对 JSX 同理： jsx123456789101112131415161718// Dirtyconst MyComponent = () =&gt; ( &lt;div&gt; &lt;OtherComponent type=\"a\" className=\"colorful\" foo=&#123;123&#125; bar=&#123;456&#125; /&gt; &lt;OtherComponent type=\"b\" className=\"colorful\" foo=&#123;123&#125; bar=&#123;456&#125; /&gt; &lt;/div&gt;);// Cleanconst MyOtherComponent = (&#123; type &#125;) =&gt; ( &lt;OtherComponent type=&#123;type&#125; className=\"colorful\" foo=&#123;123&#125; bar=&#123;456&#125; /&gt;);const MyComponent = () =&gt; ( &lt;div&gt; &lt;MyOtherComponent type=\"a\" /&gt; &lt;MyOtherComponent type=\"b\" /&gt; &lt;/div&gt;); 但也不要过度优化，过度优化和搞破坏没什么区别。 可预测、可测试如果使用 Jest 测试，可以考虑截图测试插件：Jest Image Snapshot 自我解释尽可能减少代码中的注释。可以通过让变量名更语义化、只注释复杂、潜在逻辑，来减少注释量，同时也提高了可维护性，毕竟不用总在代码与注释之间同步了。 jsx12345678910111213// Dirtyconst fetchUser = (id) =&gt; ( fetch(buildUri`/users/$&#123;id&#125;`) // Get User DTO record from REST API .then(convertFormat) // Convert to snakeCase .then(validateUser) // Make sure the the user is valid);// Cleanconst fetchUser = (id) =&gt; ( fetch(buildUri`/users/$&#123;id&#125;`) .then(snakeToCamelCase) .then(validateUser)); 上面的例子，方法 convertFormat 含义是 “转换格式”，太过于笼统，以至于不得不添加注释。如果换成 snakeToCamelCase （转换为驼峰风格），这个名字就解释了自己的功能。 斟酌变量名 布尔值或者返回值是布尔类型的函数，命名以 is has should 开头： 1234// Dirtyconst done = current &gt;= goal;// Cleanconst isComplete = current &gt;= goal; 函数以其效果命名，而不是怎么做的来命名 12345678// Dirtyconst loadConfigFromServer = () =&gt; &#123; ...&#125;;// Cleanconst loadConfig = () =&gt; &#123; ...&#125;; 很多时候我也经常犯这种错误，毕竟写代码的时候总要考虑实现，一不小心就将实现的方式带入了函数名中。 遵循设计模式这里的设计模式，并不是指工程上的，而是更广泛的开发中的设计模式，比如 “你应该使用 tslint 校验代码格式” “typescript 开启 stricts 模式” “编写一个 React 函数，应当将 React 作为 peerDependency” 等等（当然，不要随意设置 peerDependency 也是一种江湖约定）。 对于 React，遵循以下几个最佳实践： 单一责任原则, 确保每个功能都完整完成一项功能，比如更细粒度的组件拆分，同时也更利于测试。 不要把组件的内部依赖强加给使用方。 lint 规则尽量严格。 根据我的体验，尤为痛恨违背第二条的组件，比如当 React 组件使用了数据流，但必须依赖项目初始化该数据流才能执行，如果不是被生活所迫，我才不会使用这种组件。 第三条也一样，如果你是一个知名轮子的作者，请毫不留情的使用最严格的 lint 规则。如果使用者的 lint 规则比你还严格，你的组件将无法使用。 考虑到以上几点并不会降低编码速度编写整洁的代码在开始一定会放慢开发速度，因为你需要转变自己的思维模式，但随着不断迭代，它的带来的效率提升会逐渐弥补前面的损失，并不断带来开发效率的提升。 写组件库也是同理，用脚写固然能快速完成，但后续往往要重构掉。我很羡慕函数式工作环境的开发者，他们几乎只要为每个功能写一遍，剩下的就是记住并调用它。 在 React 中的实践略过几个没意思的例子。。 在 React 使用 defaultProps 代替在代码中动态判断 显然，利用 React 组件的规则，将入参的默认值预先定义好是最高效的。但顺带一句，如果在 ts 最严格的 stricts 模式里，依然会报错：变量可能未定义。这是因为 defaultProps 依然是个约定，而不能通过强类型推导出，目前还没有更优雅的解决思路。 渲染与判断逻辑分开 jsx12345678910111213141516171819202122232425262728293031323334353637383940// Dirtyclass User extends Component &#123; state = &#123; loading: true &#125;; render() &#123; const &#123; loading, user &#125; = this.state; return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;div&gt; &lt;div&gt; First name: &#123;user.firstName&#125; &lt;/div&gt; &lt;div&gt; First name: &#123;user.lastName&#125; &lt;/div&gt; ... &lt;/div&gt;; &#125; componentDidMount() &#123; fetchUser(this.props.id) .then((user) =&gt; &#123; this.setState(&#123; loading: false, user &#125;)&#125;) &#125;&#125;// Cleanimport RenderUser from './RenderUser';class User extends Component &#123; state = &#123; loading: true &#125;; render() &#123; const &#123; loading, user &#125; = this.state; return loading ? &lt;Loading /&gt; : &lt;RenderUser user=&#123;user&#125; /&gt;; &#125; componentDidMount() &#123; fetchUser(this.props.id) .then(user =&gt; &#123; this.setState(&#123; loading: false, user &#125;)&#125;) &#125;&#125; 逻辑与渲染分离，便于维护，其次便于测试。 当然有人可能会问 “就算逻辑与渲染分离了，但组成的大组件不还是逻辑耦合的吗”，对，这就像函数单一指责一样，render 是过程代码，但过程中涉及到的逻辑，分配给单一指责的渲染组件渲染，如果把逻辑与渲染写在一起，就类似一个函数把功能全做完，这样做显然诸事不利。 提倡无状态组件jsx1234567891011121314151617// Dirtyclass TableRowWrapper extends Component &#123; render() &#123; return ( &lt;tr&gt; &#123;this.props.children&#125; &lt;/tr&gt; ); &#125;&#125;// Cleanconst TableRowWrapper = (&#123; children &#125;) =&gt; ( &lt;tr&gt; &#123;children&#125; &lt;/tr&gt;); 性能是一个原因，原文比较强调性能与代码量。我认为 stateless 重点在于阻碍了内部状态的使用，移除了生命周期，所以提高了组件的可控性，也就拓宽了组件的使用场景。 受控与非受控组件都有其适用场景，像非常基础的底层组件库，往往倾向提供两套机制，通过 value 与 defaultValue 决定是否受控。拥有这样能力的组件源码就没法通过 stateless 写，所以无状态组件的面向对象并不是基础底层组件，而且这些基础组件也没必要完全无状态，两者都提供是最好的选择。 说到这，也就是考虑到成本问题，那么无状态组件也就更适合上层具有业务含义的组件。页面级别组件状态太多，不适合，所以我认为无状态组件比较适合 Wrapper 层，也就是对基础组件包裹并增强业务能力这一层。 解构1234567// Dirtyconst splitLocale = locale.split('-');const language = splitLocale[0];const country = splitLocale[1];// Cleanconst [language, country] = locale.split('-'); ES6 新增的语法可以提升不少代码可读性，需要刻意训练去培养这个习惯。 3 精读本周精读已经融于内容概要中 ^_^。最后推荐在 typescript 中开启 strict 模式，强制使用良好的开发习惯。 12345678910111213// BadonChange(value =&gt; console.log(value.name))// DirtyonChange((value) =&gt; &#123; if (!value) &#123; value = &#123;&#125; &#125; console.log(value.name)&#125;)// CleanonChange((value = &#123;&#125;) =&gt; console.log(value.name))// CleanonChange(value =&gt; console.log(value?.name)) 不要信任任何回调函数给你的变量，它们随时可能是 undefined，使用初始值是个不错的选择，但有的时候初始值没什么意义，使用 ?. 语法可以安全的访问属性，是时候抛弃 _.get 了。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"那些入坑 React 前没有人会提醒你的事","slug":"article-react-cao-dian","date":"2018-12-15T13:13:05.000Z","updated":"2021-06-24T04:02:41.976Z","comments":true,"path":"2018/12/15/article-react-cao-dian/","link":"","permalink":"https://doubleray.top/2018/12/15/article-react-cao-dian/","excerpt":"1 引言站在 React 已经繁荣昌盛、无需四处布道宣传的今天，我们不妨冷静下来问问自己，React 真的是一个完美的框架吗？社区里一直不缺少吐槽的声音，这周我们就来看看，React 到底有哪些槽点。 针对以下两篇文章： 一篇是 Gianluca Guarini 写的 《Things nobody will tell you about React.js》，我将它译作 《那些入坑 React 前没有人会提醒你的事》，因为作者行文中明显带着对 React 的批判和失望。 另一篇则是 Facebook 员工，也是 Redux 作者的 Dan Abramov 针对上文的回复 《Hey, thanks for feedback!》。","text":"1 引言站在 React 已经繁荣昌盛、无需四处布道宣传的今天，我们不妨冷静下来问问自己，React 真的是一个完美的框架吗？社区里一直不缺少吐槽的声音，这周我们就来看看，React 到底有哪些槽点。 针对以下两篇文章： 一篇是 Gianluca Guarini 写的 《Things nobody will tell you about React.js》，我将它译作 《那些入坑 React 前没有人会提醒你的事》，因为作者行文中明显带着对 React 的批判和失望。 另一篇则是 Facebook 员工，也是 Redux 作者的 Dan Abramov 针对上文的回复 《Hey, thanks for feedback!》。 2 内容概要Gianluca Guarini 着重吐槽的点在于： React 项目文件组织规范不统一，社区中 Starter Kit 太多（100+），新手不知道该怎么组织文件 由于 React 只关心 View 层，开发者就要面临选择 mobx 还是 redux 的纠结，无论选择哪种都会带来一系列的问题（重新配置构建脚本，更新 eslint 规则等） 如果选了 mobx，会发现 mobx 无法保证自己的 store 不被外部更新（官方建议是加上特殊的前缀） 如果选了 redux，会发现要实现同样的功能需要写很多的重复代码（这也是为什么社区中有海量的 redux helper 存在） 路由用起来也很蛋疼，因为 React Router 几乎是社区中唯一的选择，但是这货版本更新太快，一不小心就用了废弃的 API 用 JSX 的时候总是要嵌很多没必要的 div 或 span 要上手一个 React 应用，要配置很多的构建工具和规则才能看到效果 … Dan Abramov 的回复： 「React 16.0 引入的 Fiber 架构会导致现有代码全部需要重构」的说法是不对的，因为新的架构做到了向后兼容，而且 Facebook 内部超过 3 万个组件都能无痛迁移到新架构上 缺少统一脚手架的问题，可以通过 create-react-app 解决 觉得 redux 和 mobx 繁琐的话，对于刚刚上手的小应用不建议使用 React Router 升级太频繁？2015 年发布的 1.0，2016 年 2 月发布的 2.0，2016 年 10 月发布的 3.0。虽然 4.0 紧接着 3.0 马上就发布了，但是 React Router 很早就已经公布了这样的升级计划。 … 3 精读本次提出独到观点的同学有：@rccoder @Turbe Xue @Pines-Cheng @An Yan @淡苍 @黄子毅 @宾彬 @cisen @Bobo 精读由此归纳。 很高兴能看到不少新同学积极参与到精读的讨论中来，每一个人的声音都是社区发展的一份力量。 React 上手困难很早之前我们去四处布道 React 的时候，都会强调 React 很简单，因为它的 public API 非常之少，React 完整的文档 1 个小时就能看完。 那么说「React 上手困难」又是从何谈起呢？参与精读的同学中有不少都有 Vue 的使用经验（包括本周吐槽文的作者），所以不免会把两个框架上手的难易程度放在心里做个对比。 都说没有对比就没有伤害，大家普遍的观点是 Vue 上手简单、文档清晰、构建工具完善、脚手架统一……再反观 React，虽然 Dan 在文章里做了不少解释，但引用 @An Yan 的原话，『他也只是在说「事情没有那么糟糕」』。 所以说，大家认为的 React 上手困难，很大程度上不是 React 本身，而是 React 附带的生态圈野蛮发展太快，导致新人再进入的时候普遍感觉无所适从。虽然官方的 create-react-app 缓解了这一问题，但还没有从根本程度上找到解法。 状态管理的迷思在今时今日的前端圈子里，说 React 不说 Redux 就像说 Ruby 却不说 Rails 一样，总感觉缺点儿什么。 因为 React 将自己定位成 View 层的解决方案，所以对于中大型业务来说一个合适的状态管理方案是不可或缺的。从最早的 Backbone Model，到 Flux，再到 reflux、Redux，再到 mobx 和 redux-observable，你不得不感叹 React 社区的活力是多么强大。 然而当你真正开始做新项目架构的时候，你到底是选 Redux 还是 Mobx，疑惑是封装解决方案如 dva 呢？ @淡苍 认为，Redux 与 MobX，React 两大状态管理方案，各有千秋，Redux 崇尚自由，扩展性好，却也带来了繁琐，一个简单的异步请求都必须引入中间件才能解决，MobX 上手容易，Reactive 避免不必要的渲染，带来性能提升，但相对封闭，不利于业务抽象，缺少最佳实践。至于如何选择？根据具体场景与需求判断。 不难看出，想要做好基于 React 的前端架构，你不仅需要对自己的业务了如指掌，还需要对各种解决方案的特性以及适合怎样的业务形态了如指掌。在 React 社区，永远没有标准解决方案。 Redux 亦非万能解Redux 在刚刚推出的时候凭借酷炫的 devtool 和时间旅行功能，瞬间俘获了不少工程师的心。 但当你真正开始使用 Redux 的时候，你会发现你不仅需要学习很多新的概念，如 reducer、store、dispatch、action 等，还有很多基础的问题都没有标准解法，最典型的例子就是异步 action。虽然 Redux 的 middleware 机制提供了实现异步 action 的可能性，但是对于小白来说去 dispatch 一个非 Object 类型的 action 之前需要先了解 thunk 的概念，还要给 Redux 添加一个 redux-thunk 中间件实属难题。 不仅如此，在前端工程中常见的表单处理，Redux 社区也一直没有给出完美的解法。前有简单的 util 工具 redux-form-utils，后有庞大复杂的 redux-form，还有 rc-component 实现的一套基于 HOC 的解决方案。若没有充分的了解和调研，你将如何选择？ 这还没有提到最近非常火热的 redux-saga 和 redux-observable，虽然 Dan 说如果你不需要的话完全可以不用了解，但是如果你不了解他们的话怎么知道自己需不需要呢？ React 与 Vue 之争Vue 之所以觉得入门简单，因为一开始就提供了 umd 的引入方式，这与传统 js 开发的习惯一致，以及 Avalon 多年布道的铺垫，大家可以很快接受一个不依赖于构建的 Vue。 React 因为引入了 JSX 概念，本可以以 umd 方式推广，但为了更好的 DX 所以上来就推荐大家使用 JSX，导致新手觉得门槛高。 React + Mobx 约等于一个复杂的 Vue，但这不是抛弃 React 的理由。为什么大家觉得 Vuex 比 Redux 更适合 Vue 呢？因为 Vuex 简单，而 Redux 麻烦，这已经将两个用户群划分开了。 一个简单的小公司，就是需要这种数据流简单，不需要编译，没有太多技术选型要考虑的框架，他们看中的是开发效率，可维护性并不是第一位，这点根本性的导致了这两类人永远也撮合不到一块。 而 Vue 就是解决了这个问题，帮助了那么多开发者，仅凭这点就非常值得称赞，而我们不应该从 React 维护性的角度去抨击谁好谁坏，因为站在我们的角度，大部分中小公司的开发者是不 care 的。 React 用户圈汇集了一批高端用户，他们不断探索技术选型，为开源社区迸发活力，如果大家都转向 Vue，这块摊子就死了，函数式、响应式编程的演进也会从框架的大统一而暂时终止，起码这是不利于技术进步的，也是不可能发生的。Vue 在自己的领域做好，将 React 敏捷思想借鉴过来，帮助更多适合场景的开发者，应该才是作者的目的。 小贴士：如何在开源社区优雅的撕逼开源社区撕逼常有，各种嘴炮也吃充斥在社区里，甚至有人在 Github 上维护了一份开源社区撕逼历史。虽然说做技术的人有争论很正常，但是撕的有理有据令人信服的案例却不多。这次 Facebook 的员工 Dan Abramov 就做出了很好的表率。面对咄咄逼人的文章，逐条回复，不回避、不扯淡且态度保持克制，实属难能可贵。 3 总结React 开发者们也不要因为产生了 Mobx 这种亲 Vue 派而产生焦虑，这也是对特定业务场景的权衡，未来更多更好的数据流方案还会继续诞生，技术社区对技术的优化永无止尽。 比如 mobx-state-tree 就是一种 redux 与 mobx 结合的大胆尝试，作者在很早之前也申明了，Mobx 一样可以做时间旅行，只要遵守一定的开发规范。 最后打个比方：安卓手机在不断进步，体验越来越逼近苹果，作为一个逼格高的用户，果断换苹果吧。但作为 java 开发人员的你，是否要为此换到 oc 流派呢？换，或者不换，其实都一样，安卓和苹果已经越来越像了。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"React学习总结","slug":"article-react-learn-sum","date":"2018-11-17T10:13:05.000Z","updated":"2021-06-24T04:02:41.978Z","comments":true,"path":"2018/11/17/article-react-learn-sum/","link":"","permalink":"https://doubleray.top/2018/11/17/article-react-learn-sum/","excerpt":"","text":"React开发步骤总结 UI拆分（单一职责原则） 构建静态版本（无state，无交互，可测试页面构成） 确定state（为了好维护：最小但完整） 某些可以根据props计算而来 或者 根据已有state和props计算而来的 不是必须state。 确定状态的位置 考虑涉及到同一state的组件有哪些，将该state放到所有关联组件的共同祖先组件 反向数据流 在确定好state之后，通过props向下传递，形成正向数据流；反向数据流就是事件响应等修改祖先组件中的state。 React基础知识总结 React只更新必需要更新的部分，即使render了整个react元素，也只更新需要更新的部分，不必纠结render执行的资源消耗，参见react diff JSX 可防止注入攻击，由于其在渲染前，所有数据会被转义成字符串处理；JSX本身可看作对象，即React元素，React会根据这些React元素来构建真正的DOM，并保持更新。 state状态更新可能是异步的，React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新，所以不能依赖他们的值计算下一个state(状态)； 组件的状态只能自身访问，组件外不能获取；一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)； 事件处理 (通过preventDefault来阻止默认行为)，注意事件处理函数的this绑定； 条件渲染： if + 变量，根据不同state或者props来返回不同组件； 在返回的组件JSX中使用 &amp;&amp; ，JSX中可使用任何表达式（内联）; 三元表达式（内联）； 组件属性 props.children 表示组件包裹的元素，可包裹JSX组件元素、字符串、{}包裹的js表达式、回调函数。false，null，undefined，和 true 都是有效的的 children(子元素)，但是并不会被渲染。 return null 可防止组件被渲染（可在函数组件中return null），从组件的 render 方法返回 null 不会影响组件生命周期方法的触发。 例如， componentWillUpdate 和 componentDidUpdate 仍将被调用； 列表渲染： 列表组件 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识；keys 在同辈元素中必须是唯一的，不需要全局唯一；key不会作为props传入组件内部，若想使用，可利用props传入相同的值； 表单（受控组件）(React元素中input、textare、select标签的value，onChange与selected属性都与HTML元素不同，都接受一个 value 属性来实现一个受控组件) 状态提升： React遵循单一数据流原则，即从上到下的数据流，通过将state转props进行父子通信，若需要组件间通信，则需要将组件的状态提升到最近的共同祖先组件； 当你看到 UI 中的错误，你可以使用 React 开发者工具来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头; 组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数; redux 学习记录中文文档 segmentfault 中文文档 GitBook redux 的来源与思想 来源：Redux 由 Flux 演变而来，但受 Elm （函数式编程语言）的启发，避开了 Flux 的复杂性。 思想：Web 应用是一个状态机，视图与状态是一一对应的。所有的状态，保存在一个对象里面。让 state 的变化变得可预测 。 三大原则： 单一数据源（整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中） State 是只读的（唯一改变 state 的方法就是触发 action） 使用纯函数来执行修改（通过 reducers 函数来修改 state tree） redux 的适用场景从应用的角度： 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件的角度： 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://doubleray.top/tags/React/"}]},{"title":"单页面 SEO 优化","slug":"other-SEO","date":"2018-10-10T02:10:10.000Z","updated":"2021-06-24T04:02:41.988Z","comments":true,"path":"2018/10/10/other-SEO/","link":"","permalink":"https://doubleray.top/2018/10/10/other-SEO/","excerpt":"","text":"通用方法 logo上加首页的地址，并且只将logo是放在h1标签中 外链优化，提高关键词排名，meta信息 对外联css,以及js使用了延迟加载以及dns-prefetch，preload 使用Robots.txt … 等等 服务端渲染(后端渲染SSR)可以使用Nuxt.js作为框架来处理项目的所有UI呈现 好处：前端耗时少（前端只负责将html进行展示），利于SEO 坏处：网络传输数据量大，占用（部分、少部分）服务器运算资源，response 出的数据量会（稍）大点，模板改了前端的交互和样式什么的一样得跟着联动修改 预渲染的方式(PreRender)vue-meta-info 动态设置meta信息，配合 prerender-spa-plugin 实现关键页面的预渲染。 需要路由使用history模式，使用hash模式会导致失效 缺点：不能很好地处理用户独特性路由，预渲染路由过多的话会增加编译时间。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://doubleray.top/categories/杂记/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"https://doubleray.top/tags/SEO/"}]},{"title":"学习 React","slug":"article-js-react","date":"2018-09-01T05:13:05.000Z","updated":"2021-06-24T04:02:41.970Z","comments":true,"path":"2018/09/01/article-js-react/","link":"","permalink":"https://doubleray.top/2018/09/01/article-js-react/","excerpt":"react众所周知的前端3大主流框架之一，由于出色的性能，完善的周边设施风头一时无两。本文就带大家一起掌握react。 以下内容参考学习 掌握react，这一篇就够了","text":"react众所周知的前端3大主流框架之一，由于出色的性能，完善的周边设施风头一时无两。本文就带大家一起掌握react。 以下内容参考学习 掌握react，这一篇就够了 jsx语法前端MVVM主流框架都有一套自己的模板处理方法，react则使用它独特的jsx语法。在组件中插入html类似的语法，简化创建view的流程。 下面让我们来认识一下构建的两种元素 原生元素12345ReactDOM.render(( &lt;div&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;/div&gt;), document.getElementById('root')) 通过简单的语法页面就会被插入一个div+一个h1标签。原生的html元素可以被直接使用。以上的语法并不是js支持的语法，需要被转换之后才能运行。 自定义元素react强大之处就在于可以组件的自定义，实现组件的复用。如果我们创建了一个组件。我们也可以通过jsx语法调用。 123456789101112131415import * as React from 'react'class Page extends React.Component &#123; render() &#123; return (&lt;div&gt; home111 &amp;copy; © \\ua9 &lt;/div&gt;) &#125;&#125;ReactDOM.render(( &lt;div&gt; &lt;Page/&gt; &lt;/div&gt;), document.getElementById('root')) 我们定义了一个Page组件，可以在jsx里面像调用html一样直接调用。 插入动态数据1234567let name = 'hi'ReactDOM.render(( &lt;div&gt; &#123;name&#125; &lt;/div&gt;), document.getElementById('root')) 使用{}就可以插入数据，但是{}中间的必须是js表达式，不能是语句。如果表达式的执行结果是一个数组，则会自动join。 注释jsx语法和html语法一样，也是可以插入注释，只不过写的时候有一些区别 子组件注释12345678let name = 'hi'ReactDOM.render(( &lt;div&gt; &#123;/* 注释 */&#125; &#123;name&#125; &lt;/div&gt;), document.getElementById('root')) 在子组件中插入注释，需要使用{}包裹起来，在/ /之间插入注释文字。 属性注释12345678910let name = 'hi'ReactDOM.render(( &lt;div&gt; &#123;name&#125; &lt;img /* 多行注释 */ src=\"1.jpg\"/&gt; &lt;/div&gt;), document.getElementById('root')) 在标签中间，可以插入一个多行注释，类似上面的代码。 属性props 可以向使用html的attr一样使用属性，就像下面img的src一样 1234567let name = 'hi'ReactDOM.render(( &lt;div&gt; &lt;img src=\"1.png\"/&gt; &lt;/div&gt;), document.getElementById('root')) 如果需要传递动态属性，使用{}，多个属性，使用展开运算符 1234567891011let props = &#123; src: '1.png', alt: '1图片'&#125;ReactDOM.render(( &lt;div&gt; &lt;img src=&#123;\"1.png\"&#125;/&gt; &lt;img &#123;...props&#125;/&gt; &lt;/div&gt;), document.getElementById('root')) 两个转换,class–&gt;className for–&gt;htmlFor 因为class和for是javascript关键字，所以这里需要用转换之后名称 12345ReactDOM.render(( &lt;div className=\"tab\"&gt; &lt;label htmlFor=\"name\"&gt;姓名:&lt;/label&gt;&lt;input id=\"name\"/&gt; &lt;/div&gt;), document.getElementById('root')) 布尔属性 如果一个属性的值是布尔值，当这个值是true的时候则可以省略=后面的值，只保留key。 123456ReactDOM.render(( &lt;div className=\"tab\"&gt; &lt;input type=\"text\" required/&gt; &lt;input type=\"text\" required=&#123;true&#125;/&gt; &lt;/div&gt;), document.getElementById('root')) 原生元素的自定义属性 react对元素属性做了校验，如果在原生属性上使用此元素不支持的属性，则不能编译成功。必须使用data-前缀 12345ReactDOM.render(( &lt;div className=\"tab\"&gt; &lt;input type=\"text\" data-init=\"22\"/&gt; &lt;/div&gt;), document.getElementById('root')) 插入html如果动态的插入html元素,react出于安全性考虑会自动帮我们转义。所以一定要动态的插入元素的话，使用dangerouslySetInnerHTML 12345ReactDOM.render(( &lt;div className=\"tab\"&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: '&lt;span&gt;test&lt;/span&gt;'&#125;&#125;&gt;&lt;/div&gt; &lt;/div&gt;), document.getElementById('root')) React组件创建React.createClass这是旧版本的api，使用React.createClass创建组件，配套的一些api，有getDefaultProps, getinitialstate。官方已经不建议使用了，使用下面新的api替代。 ES6 classes123456789import * as React from 'react'class Page extends React.Component &#123; render() &#123; return (&lt;div&gt; home &lt;/div&gt;) &#125;&#125; 这是一个实现了render方法的class。也是一个基本的react组件。 无状态函数12345678function Button(props, context) &#123; return ( &lt;button&gt; &lt;em&gt;&#123;props.text&#125;&lt;/em&gt; &lt;span&gt;&#123;context.name&#125;&lt;/span&gt; &lt;/button&gt; );&#125; 纯函数,不存在state，只接受props和state。纯函数有优点，优点就是易于测试，无副作用。 React数据流statestate是组件的内部状态，需要在视图里面用到的状态，才需要放到state里面去。如下，我们在类上创建一个state属性，在视图里面通过使用this.state.name去引用。而这里的state定义则代替的是getinitialstate方法。 12345678910111213import * as React from 'react'class Page extends React.Component &#123; state = &#123; name: '小明' &#125; render() &#123; return (&lt;div&gt; &#123;this&#125; &lt;/div&gt;) &#125;&#125; 如何更新state呢，直接更改state其实可以可以的，不过这样子无法触发组件视图的更新机制。所以使用setState()api。值得注意的是setState是异步的，原因是react内部需要对setState做优化，不是state变了立刻去更新视图，而是拦截一部分state的改变，等到合适的时机再去更新视图。 123456789101112131415import * as React from 'react'class Page extends React.Component &#123; state = &#123; name: '小明' &#125; render() &#123; setTimeout(() =&gt; this.setState(&#123;name: '小明儿子'&#125;)， 5000) return (&lt;div&gt; &#123;this.state.name&#125; &lt;/div&gt;) &#125;&#125; 真实开发中绝不要在render函数里面去更改state，以上只是为了演示 propsprops是组件之间传递数据的最主要api, react推崇的是自顶向下的数据流向，也就是组件的数据要从父组件传给子组件。如果子组件需要向父组件传递数据，则需要使用回调函数的方式。 1234567891011121314151617181920212223import * as React from 'react'class Child extends React.Component &#123; render() &#123; return (&lt;div&gt; &#123;this.props.parentName&#125; &lt;/div&gt;) &#125;&#125;class Parent extends React.Component &#123; state = &#123; name: '小明' &#125; render() &#123; setTimeout(() =&gt; this.setState(&#123;name: '小明儿子'&#125;)， 5000) return (&lt;div&gt; &lt;Child parentName=&#123;this.state.name&#125;/&gt; &lt;/div&gt;) &#125;&#125; 可以看到Child组件显示了父组件的name。当父组件状态更新了，子组件同步更新。那如何在子组件中更改父组件状态呢？答案是回调函数。 12345678910111213141516171819202122232425262728293031323334import * as React from 'react'class Child extends React.Component &#123; update() &#123; this.props.onChange('小明名字改了') &#125; render() &#123; return (&lt;div&gt; &#123;this.props.parentName&#125; &lt;button onClick=&#123;this.update.bind(this)&#125;&gt;更新&lt;/button&gt; &lt;/div&gt;) &#125;&#125;class Parent extends React.Component &#123; state = &#123; name: '小明' &#125; changeName(name) &#123; this.setState(&#123; name &#125;) &#125; render() &#123; setTimeout(() =&gt; this.setState(&#123;name: '小明儿子'&#125;)， 5000) return (&lt;div&gt; &lt;Child onChange=&#123;this.changeName.bind(this)&#125; parentName=&#123;this.state.name&#125;/&gt; &lt;/div&gt;) &#125;&#125; 注意哈：props是不可以更改的，这既不符合react单向数据流思想，也为维护带来灾难。 事件react里面的用户事件都是合成事件，被React封装过。内部使用的还是事件的委托机制。常用的事件有点击事件onClick，input的onChange事件等，官网都可以查到。 合成事件的this指向问题就像上文一样，我们绑定事件的方式很奇怪，使用了bind来显示绑定this的指向。因为传递到组件内部的只是一个函数，而脱离了当前对象的函数的this指向是不能指到当前组件的，需要显示指定。 通过bind 1&lt;button onClick=&#123;this.update.bind(this)&#125;&gt;更新&lt;/button&gt; 构造器内部指定 12345678910111213141516171819import * as React from 'react'class Child extends React.Component &#123; constructor(props) &#123; super(props) this.update = this.update.bind(this) &#125; update() &#123; this.props.onChange('小明名字改了') &#125; render() &#123; return (&lt;div&gt; &#123;this.props.parentName&#125; &lt;button onClick=&#123;this.update&#125;&gt;更新&lt;/button&gt; &lt;/div&gt;) &#125;&#125; 箭头函数 1234567891011121314import * as React from 'react'class Child extends React.Component &#123; update =&gt; e = &#123; this.props.onChange('小明名字改了') &#125; render() &#123; return (&lt;div&gt; &#123;this.props.parentName&#125; &lt;button onClick=&#123;this.update&#125;&gt;更新&lt;/button&gt; &lt;/div&gt;) &#125;&#125; 装饰器 12345678910111213141516171819import * as React from 'react'class Child extends React.Component &#123; constructor(props) &#123; super(props) &#125; @autoBind update() &#123; this.props.onChange('小明名字改了') &#125; render() &#123; return (&lt;div&gt; &#123;this.props.parentName&#125; &lt;button onClick=&#123;this.update&#125;&gt;更新&lt;/button&gt; &lt;/div&gt;) &#125;&#125; 装饰器是es7语法，如果需要使用需要安装对应的babel：present版本。而typescript则原生支持。 autoBind原理大概就是劫持get方法，get时改变this指向 如何获得evnt原生事件通过e.nativeEvent获取原生事件对象 123456789101112131415161718import * as React from 'react'class Child extends React.Component &#123; constructor(props) &#123; super(props) this.update = this.update.bind(this) &#125; update(e) &#123; console.log(e.nativeEvent) &#125; render() &#123; return (&lt;div&gt; &lt;button onClick=&#123;this.update&#125;&gt;更新&lt;/button&gt; &lt;/div&gt;) &#125;&#125; 解决冒泡和取消默认事件1e.preventDefault() //取消默认行为 1e.stopPropagation() //取消冒泡 这个和浏览器原生事件处理方案是一致的。问题是我们只可以调合成事件的e的方法，不可以通过e.nativeEvent方法做这些操作，原因是上文讲过的委托。 ReactDomref特殊的props，ref组件对象的引用，现在官方也不建议直接给ref赋值，需要通过函数来赋值。 12345ReactDOM.render(( &lt;div&gt; &lt;Calendar ref=&#123;ref =&gt; this.c = ref&#125; any-ss=\"text\"/&gt; &lt;/div&gt;), document.getElementById('root')) render顶层api,只有在根组件时候才需要使用。第一个参数是Component,第二个参数是dom节点 findDOMNode通过传入component实例获取此component根dom节点，在这里可以去dom节点进行操作了，虽然极其不建议这么做，但是你确实可以做。 unmountComponentAtNode卸载此组件，并销毁组件state和事件。接收组件的引用，也就是ref。仅仅是取消挂载，组件还在，如果需要彻底清除的话，需要手动删掉此dom。 表单onchange配合value与vue框架不同的是，react如果要实现表单元素变化，状态同步更新，必须要自己去监听表单事件。 123456789101112131415161718192021222324import * as React from 'react'class Child extends React.Component &#123; state = &#123; name: '小明' &#125; constructor(props) &#123; super(props) this.update = this.update.bind(this) &#125; update(e) &#123; this.setState(&#123; name: e.target.value &#125;) &#125; render() &#123; return (&lt;div&gt; &lt;input onChange=&#123;this.update&#125; value=&#123;this.state.name&#125;/&gt; &lt;/div&gt;) &#125;&#125; 受控组件和非受控组件受控组件和非受控组件这些都是指的表单组件，当一个表单的值是通过value改变的而不是通过defaultValue是受控组件，否则就是非受控组件。 下面组件中的input就是受控组件 123456789101112131415161718192021222324import * as React from 'react'class Child extends React.Component &#123; state = &#123; name: '小明' &#125; constructor(props) &#123; super(props) this.update = this.update.bind(this) &#125; update(e) &#123; this.setState(&#123; name: e.target.value &#125;) &#125; render() &#123; return (&lt;div&gt; &lt;input onChange=&#123;this.update&#125; value=&#123;this.state.name&#125;/&gt; &lt;/div&gt;) &#125;&#125; 下面组件中的input是非受控组件 123456789101112131415161718192021222324import * as React from 'react'class Child extends React.Component &#123; state = &#123; name: '小明' &#125; constructor(props) &#123; super(props) this.update = this.update.bind(this) &#125; update(e) &#123; this.setState(&#123; name: e.target.value &#125;) &#125; render() &#123; return (&lt;div&gt; &lt;input onChange=&#123;this.update&#125; defaultValue=&#123;this.state.name&#125;/&gt; &lt;/div&gt;) &#125;&#125; 组件之间通讯父子之间通讯父子之间通讯又分为父-&gt;子，子-&gt;父。 因为react单向数据流向的缘故，父-&gt;子通信的话直接通过props。父组件数据变动，直接传递给子组件。 子-&gt;父组件之间就要通过回调函数来通信了，父组件传递一个回调函数给子组件，子组件通过调用此函数的方式通知父组件通信。 跨级组件通信react为了实现祖先组件和后辈组件之间的通信问题，引入了contextApi。 12345678910111213141516171819202122232425262728293031323334353637383940class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;Button.contextTypes = &#123; color: React.PropTypes.string&#125;;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; render() &#123; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;MessageList.childContextTypes = &#123; color: React.PropTypes.string&#125;; MessageList中的color会自动更新到儿孙组件里面去，实现跨级啊通信。如果需要反过来通信，则需要借助其他工具，比如事件系统(Pub/Sub)。 没有嵌套关系组件之间通信组件之间通信最主流的两种方式脱胎于观察这模式和中介者模式这两种。 跨级之间通信现在最主流的方式就是观察这模式的实现Pub/Sub，react社区中的redux也是使用这种方式实现的。 vue2.X版本也去掉了跨组件通信的功能。那如何在2.x中做跨组件通信呢？如果不借助外力的话，是不是可以使用$parent和$childen的递归调用实现全局组件通信呢？比如我想广播一个事件，我就查找到所有的子组件，挨个触发$emit(xx)，上报一个事件也是同理，只不过需要查找所有的$parent。结合起来就可以实现组件之间的通信，只不过这种查找效率比较低，需要慎用和优化","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"ES6 Class 的继承","slug":"article-ES6-Class-extends","date":"2018-07-10T05:13:05.000Z","updated":"2021-06-24T04:02:41.951Z","comments":true,"path":"2018/07/10/article-ES6-Class-extends/","link":"","permalink":"https://doubleray.top/2018/07/10/article-ES6-Class-extends/","excerpt":"以下内容参考学习 ECMAScript 6 入门 简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","text":"以下内容参考学习 ECMAScript 6 入门 简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 1234let cp = new ColorPoint(25, 8, 'green');cp instanceof ColorPoint // truecp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 最后，父类的静态方法，也会被子类继承。 12345678910class A &#123; static hello() &#123; console.log('hello world'); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。 Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; 上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 1234567891011121314class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined 上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 1234567891011class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); 上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; static print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; static m() &#123; super.print(); &#125;&#125;B.x = 3;B.m() // 3 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12345678class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); // 报错 &#125;&#125; 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 12345678910class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); // true &#125;&#125;let b = new B(); 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 1234567var obj = &#123; toString() &#123; return \"MyObject: \" + super.toString(); &#125;&#125;;obj.toString(); // MyObject: [object Object] 类的 prototype 属性和__proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 12345678910111213class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 因此，就得到了上面的结果。 1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 123Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype; extends关键字后面可以跟多种类型的值。 12class B extends A &#123;&#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论两种情况。第一种，子类继承Object类。 12345class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种情况，不存在任何继承。 12345class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 实例的 __proto__ 属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName = function () &#123; console.log('Ha');&#125;;p1.printName() // \"Ha\" 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 123456789101112function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;); 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。 123456var colors = new MyArray();colors[0] = \"red\";colors.length // 0colors.length = 0;colors[0] // \"red\" 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。 1234567var e = &#123;&#125;;Object.getOwnPropertyNames(Error.call(e))// [ 'stack' ]Object.getOwnPropertyNames(e)// [] 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 1234567891011121314151617181920212223242526272829class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2] 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。 1234567891011121314151617181920212223class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError('ll');myerror.message // \"ll\"myerror instanceof Error // truemyerror.name // \"MyError\"myerror.stack// Error// at MyError.ExtendableError// ... 注意，继承Object的子类，有一个行为差异。 1234567class NewObj extends Object&#123; constructor()&#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);o.attr === true // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。 Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a = &#123; a: 'a'&#125;;const b = &#123; b: 'b'&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: 'a', b: 'b'&#125; 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。 12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix.prototype, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== \"constructor\" &amp;&amp; key !== \"prototype\" &amp;&amp; key !== \"name\" ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125;","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"}]},{"title":"自用正则手册","slug":"article-js-regex","date":"2018-06-06T05:13:05.000Z","updated":"2021-06-24T04:02:41.971Z","comments":true,"path":"2018/06/06/article-js-regex/","link":"","permalink":"https://doubleray.top/2018/06/06/article-js-regex/","excerpt":"正则表达式regex是用于匹配字符串中字符组合的模式，由参数pattern + 标志flags构成。 参考学习 MDN：正则表达式 参考学习 阮一峰：ES6正则的扩展 参考学习 菜鸟教程：正则表达式","text":"正则表达式regex是用于匹配字符串中字符组合的模式，由参数pattern + 标志flags构成。 参考学习 MDN：正则表达式 参考学习 阮一峰：ES6正则的扩展 参考学习 菜鸟教程：正则表达式 参数普通字符指所有字母、数字、符号等 非打印字符指换行、回车、空白等不会实际显示出来的字符 字符 说明 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 限定符指定匹配前面的子表达式必须要出现多少次才能满足 字符 说明 * 零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n &gt;= 0。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n &gt;= 0。至少匹配 n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m &gt;= n&gt;= 0。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。逗号和两个数之间不能有空格。 定位符描述字符串定边界 字符 说明 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 圆括号组，应用于限制多选结构的范围/分组/捕获文本/环视/特殊模式处理 字符说明(abc)匹配 'abc' 并且记住匹配项，括号被称为捕获括号。模式/(foo) (bar) \\1 \\2/中的 '(foo)' 和 '(bar)' 匹配并记住字符串 \"foo bar foo bar\" 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。(?:abc)匹配 'abc' 这样一组，但不记录，不保存到$变量中，否则可以通过$x取第几个括号所匹配到的项，比如：(aaa)(bbb)(ccc)(?:ddd)(eee)，可以用$1获取(aaa)匹配到的内容，而$3则获取到了(ccc)匹配到的内容，而$4则获取的是由(eee)匹配到的内容，因为前一对括号没有保存变量a(?=bbb)正向肯定查找，表示a后面必须紧跟3个连续的b。例如，\"Windows(?=95|98|NT|2000)\"能匹配\"Windows2000\"中的\"Windows\"，但不能匹配\"Windows3.1\"中的\"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。a(?!bbb)正向否定查找，表示a后面不能跟3个连续的b。例如\"Windows(?!95|98|NT|2000)\"能匹配\"Windows3.1\"中的\"Windows\"，但不能匹配\"Windows2000\"中的\"Windows\"。(?&lt;=bbb)a反向肯定查找，表示a前面必须紧跟3个连续的b。例如，\"(?&lt;=95|98|NT|2000)Windows\"能匹配\"2000Windows\"中的\"Windows\"，但不能匹配\"3.1Windows\"中的\"Windows\"。(?&lt;!bbb)a反向否定查找，表示a前面不能跟3个连续的b。例如\"(?&lt;!95|98|NT|2000)Windows\"能匹配\"3.1Windows\"中的\"Windows\"，但不能匹配\"2000Windows\"中的\"Windows\"。 中括号单个匹配，字符集/排除字符集/命名字符集 字符说明[xyz]字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。[^xyz]负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'、'l'、'i'、'n'。[a-z]字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。[^a-z]负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 其他特殊字符字符说明\\将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符，而 \"\\(\" 则匹配 \"(\"。?当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。.匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像\"(.|\\n)\"的模式。x|y匹配 x 或 y。例如，'z|food' 能匹配 \"z\" 或 \"food\"。'(z|f)ood' 则匹配 \"zood\" 或 \"food\"。\\d匹配一个数字字符。等价于 [0-9]。\\D匹配一个非数字字符。等价于 [^0-9]。\\w匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。\\W匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。\\xn匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' &amp; \"1\"。正则表达式中可以使用 ASCII 编码。\\num匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符\\n标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\\nm标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。\\nml如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\\un匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 标志有6个标志，可单独或一起使用 flags说明g全局搜索i不区分大小写搜索m多行搜索u正确处理四个字节的 UTF-16 编码y粘连搜索sdotAll模式，即点（dot）代表一切字符 创建有以下两种方式构建一个正则表达式： 字面量：由包含在斜杠之间的模式组成 格式： pattern/flags 优点：加载时编译，性能好 123const regex = /ab+c/;const regex = /hello/gi; 构造函数 格式：new RegExp(pattern [, flags]) 优点：运行时编译，可动态修改 1234567let regex = new RegExp(\"ab+c\");let regex = new RegExp(/hello/, \"gi\");let regex = new RegExp(/hello/gi);let regex = new RegExp(\"hello\", \"gi\"); 使用12let regex = /nn/;let str = 'runnobnnnbnn'; 方法说明示例返回值test测试是否匹配，返回true或falseregex.test(str)trueexec查找匹配的内容，有则返回一个数组，未匹配则返回nullregex.exec(str)[\"nn\", index: 2, input: \"runnobnnnbnn\", groups: undefined]match查找匹配的内容，有则返回一个数组，未匹配则返回nullstr.match(regex)[\"nn\", index: 2, input: \"runnobnnnbnn\", groups: undefined]search查找匹配的内容，有则返回位置索引，未匹配则返回-1str.match(regex)2replace查找匹配的内容，并且使用替换字符str1串替换掉匹配到的子字符串str.replace(regex, str1)ruccobnnnbnnsplit使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中str.split(regex)[\"ru\", \"ob\", \"nb\", \"\"] match：非全局匹配时，跟exec很相似；全局匹配时，就大不同了，上面的例子，在全局匹配时的返回值如下： 123regex.exec(str) // [\"nn\", index: 6, input: \"runnobnnnbnn\", groups: undefined]str.match(regex) // [\"nn\", \"nn\", \"nn\"]","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"jQuery API 替代的方法","slug":"article-js-jq-native","date":"2018-05-20T04:41:15.000Z","updated":"2021-06-24T04:02:41.967Z","comments":true,"path":"2018/05/20/article-js-jq-native/","link":"","permalink":"https://doubleray.top/2018/05/20/article-js-jq-native/","excerpt":"前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。","text":"前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 Query Selector常用的 class、id、属性 选择器都可以使用 document.querySelector 或 document.querySelectorAll 替代。区别是 document.querySelector 返回第一个匹配的 Element document.querySelectorAll 返回所有匹配的 Element 组成的 NodeList。它可以通过 [].slice.call() 把它转成 Array 如果匹配不到任何 Element，jQuery 返回空数组 []，但 document.querySelector 返回 null，注意空指针异常。当找不到时，也可以使用 || 设置默认的值，如 document.querySelectorAll(selector) || [] 注意：document.querySelector 和 document.querySelectorAll 性能很差。如果想提高性能，尽量使用 document.getElementById、document.getElementsByClassName 或 document.getElementsByTagName。 1.0 选择器查询 12345// jQuery$('selector');// Nativedocument.querySelectorAll('selector'); 1.1 class 查询 12345678// jQuery$('.class');// Nativedocument.querySelectorAll('.class');// ordocument.getElementsByClassName('class'); 1.2 id 查询 12345678// jQuery$('#id');// Nativedocument.querySelector('#id');// ordocument.getElementById('id'); 1.3 属性查询 12345// jQuery$('a[target=_blank]');// Nativedocument.querySelectorAll('a[target=_blank]'); 1.4 后代查询 12345// jQuery$el.find('li');// Nativeel.querySelectorAll('li'); 1.5 兄弟及上下元素 兄弟元素 123456789101112131415// jQuery$el.siblings();// Native - latest, Edge13+[...el.parentNode.children].filter((child) =&gt; child !== el);// Native (alternative) - latest, Edge13+Array.from(el.parentNode.children).filter((child) =&gt; child !== el);// Native - IE10+Array.prototype.filter.call(el.parentNode.children, (child) =&gt; child !== el); 上一个元素 12345// jQuery$el.prev();// Nativeel.previousElementSibling; 下一个元素 12345// next$el.next();// Nativeel.nextElementSibling; 1.6 Closest Closest 获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。 12345678910111213141516171819// jQuery$el.closest(queryString);// Native - Only latest, NO IEel.closest(selector);// Native - IE10+function closest(el, selector) &#123; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; while (el) &#123; if (matchesSelector.call(el, selector)) &#123; return el; &#125; else &#123; el = el.parentElement; &#125; &#125; return null;&#125; 1.7 Parents Until 获取当前每一个匹配元素集的祖先，不包括匹配元素的本身。 12345678910111213141516171819202122// jQuery$el.parentsUntil(selector, filter);// Nativefunction parentsUntil(el, selector, filter) &#123; const result = []; const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector; // match start from parent el = el.parentElement; while (el &amp;&amp; !matchesSelector.call(el, selector)) &#123; if (!filter) &#123; result.push(el); &#125; else &#123; if (matchesSelector.call(el, filter)) &#123; result.push(el); &#125; &#125; el = el.parentElement; &#125; return result;&#125; 1.8 Form Input/Textarea 12345// jQuery$('#my-input').val();// Nativedocument.querySelector('#my-input').value; 获取 e.currentTarget 在 .radio 中的数组索引 12345// jQuery$('.radio').index(e.currentTarget);// NativeArray.prototype.indexOf.call(document.querySelectorAll('.radio'), e.currentTarget); 1.9 Iframe Contents jQuery 对象的 iframe contents() 返回的是 iframe 内的 document Iframe contents 12345// jQuery$iframe.contents();// Nativeiframe.contentDocument; Iframe Query 12345// jQuery$iframe.contents().find('.css');// Nativeiframe.contentDocument.querySelectorAll('.css'); 1.10 获取 body 12345// jQuery$('body');// Nativedocument.body; 1.11 获取或设置属性 获取属性 12345// jQuery$el.attr('foo');// Nativeel.getAttribute('foo'); 设置属性 12345// jQuery, note that this works in memory without change the DOM$el.attr('foo', 'bar');// Nativeel.setAttribute('foo', 'bar'); 获取 data- 属性 12345678// jQuery$el.data('foo');// Native (use `getAttribute`)el.getAttribute('data-foo');// Native (use `dataset` if only need to support IE 11+)el.dataset['foo']; CSS &amp; Style 2.1 CSS Get style 123456789// jQuery$el.css(\"color\");// Native// 注意：此处为了解决当 style 值为 auto 时，返回 auto 的问题const win = el.ownerDocument.defaultView;// null 的意思是不返回伪类元素win.getComputedStyle(el, null).color; Set style 12345// jQuery$el.css(&#123; color: \"#ff0011\" &#125;);// Nativeel.style.color = '#ff0011'; Get/Set Styles 注意，如果想一次设置多个 style，可以参考 oui-dom-utils 中 setStyles 方法 Add class 12345// jQuery$el.addClass(className);// Nativeel.classList.add(className); Remove class 12345// jQuery$el.removeClass(className);// Nativeel.classList.remove(className); has class 12345// jQuery$el.hasClass(className);// Nativeel.classList.contains(className); Toggle class 12345// jQuery$el.toggleClass(className);// Nativeel.classList.toggle(className); 2.2 Width &amp; Height Width 与 Height 获取方法相同，下面以 Height 为例： Window height 12345678// window height$(window).height();// 含 scrollbarwindow.document.documentElement.clientHeight;// 不含 scrollbar，与 jQuery 行为一致window.innerHeight; Document height 12345678910111213// jQuery$(document).height();// Nativeconst body = document.body;const html = document.documentElement;const height = Math.max( body.offsetHeight, body.scrollHeight, html.clientHeight, html.offsetHeight, html.scrollHeight); Element height 12345678910111213141516171819// jQuery$el.height();// Nativefunction getHeight(el) &#123; const styles = this.getComputedStyle(el); const height = el.offsetHeight; const borderTopWidth = parseFloat(styles.borderTopWidth); const borderBottomWidth = parseFloat(styles.borderBottomWidth); const paddingTop = parseFloat(styles.paddingTop); const paddingBottom = parseFloat(styles.paddingBottom); return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;&#125;// 精确到整数（border-box 时为 height - border 值，content-box 时为 height + padding 值）el.clientHeight;// 精确到小数（border-box 时为 height 值，content-box 时为 height + padding + border 值）el.getBoundingClientRect().height; 2.3 Position &amp; Offset Position 获得匹配元素相对父元素的偏移 12345// jQuery$el.position();// Native&#123; left: el.offsetLeft, top: el.offsetTop &#125; Offset 获得匹配元素相对文档的偏移 123456789101112// jQuery$el.offset();// Nativefunction getOffset (el) &#123; const box = el.getBoundingClientRect(); return &#123; top: box.top + window.pageYOffset - document.documentElement.clientTop, left: box.left + window.pageXOffset - document.documentElement.clientLeft &#125;&#125; 2.4 Scroll Top 获取元素滚动条垂直位置。 12345// jQuery$(window).scrollTop();// Native(document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop; DOM Manipulation 3.1 Remove 从 DOM 中移除元素。 12345// jQuery$el.remove();// Nativeel.parentNode.removeChild(el); 3.2 Text Get text 返回指定元素及其后代的文本内容。 12345// jQuery$el.text();// Nativeel.textContent; Set text 设置元素的文本内容。 12345// jQuery$el.text(string);// Nativeel.textContent = string; 3.3 HTML Get HTML 12345// jQuery$el.html();// Nativeel.innerHTML; Set HTML 12345// jQuery$el.html(htmlString);// Nativeel.innerHTML = htmlString; 3.4 Append Append 插入到子节点的末尾 12345678// jQuery$el.append(\"&lt;div id='container'&gt;hello&lt;/div&gt;\");// Native (HTML string)el.insertAdjacentHTML('beforeend', '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)el.appendChild(newEl); 3.5 Prepend 12345678// jQuery$el.prepend(\"&lt;div id='container'&gt;hello&lt;/div&gt;\");// Native (HTML string)el.insertAdjacentHTML('afterbegin', '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)el.insertBefore(newEl, el.firstChild); 3.6 insertBefore 在选中元素前插入新节点 1234567891011// jQuery$newEl.insertBefore(queryString);// Native (HTML string)el.insertAdjacentHTML('beforebegin ', '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)const el = document.querySelector(selector);if (el.parentNode) &#123; el.parentNode.insertBefore(newEl, el);&#125; 3.7 insertAfter 在选中元素后插入新节点 1234567891011// jQuery$newEl.insertAfter(queryString);// Native (HTML string)el.insertAdjacentHTML('afterend', '&lt;div id=\"container\"&gt;Hello World&lt;/div&gt;');// Native (Element)const el = document.querySelector(selector);if (el.parentNode) &#123; el.parentNode.insertBefore(newEl, el.nextSibling);&#125; 3.8 is 如果匹配给定的选择器，返回true 12345// jQuery$el.is(selector);// Nativeel.matches(selector); 3.9 clone 深拷贝被选元素。（生成被选元素的副本，包含子节点、文本和属性。） 1234567//jQuery$el.clone();//Nativeel.cloneNode(); //深拷贝添加参数‘true’ 3.10 empty 移除所有子节点 12345//jQuery$el.empty();//Nativeel.innerHTML = ''; 3.11 wrap 把每个被选元素放置在指定的HTML结构中。 1234567891011//jQuery$(\".inner\").wrap('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;');//NativeArray.prototype.forEach.call(document.querySelector('.inner'), (el) =&gt; &#123; const wrapper = document.createElement('div'); wrapper.className = 'wrapper'; el.parentNode.insertBefore(wrapper, el); el.parentNode.removeChild(el); wrapper.appendChild(el);&#125;); 3.12 unwrap 移除被选元素的父元素的DOM结构 123456789101112// jQuery$('.inner').unwrap();// NativeArray.prototype.forEach.call(document.querySelectorAll('.inner'), (el) =&gt; &#123; let elParentNode = el.parentNode if(elParentNode !== document.body) &#123; elParentNode.parentNode.insertBefore(el, elParentNode) elParentNode.parentNode.removeChild(elParentNode) &#125;&#125;); 3.13 replaceWith 用指定的元素替换被选的元素 12345678910//jQuery$('.inner').replaceWith('&lt;div class=\"outer\"&gt;&lt;/div&gt;');//NativeArray.prototype.forEach.call(document.querySelectorAll('.inner'),(el) =&gt; &#123; const outer = document.createElement(\"div\"); outer.className = \"outer\"; el.parentNode.insertBefore(outer, el); el.parentNode.removeChild(el);&#125;); 3.14 simple parse 解析 HTML/SVG/XML 字符串 12345678910111213141516171819202122// jQuery$(`&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ol&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ol&gt;`);// Nativerange = document.createRange();parse = range.createContextualFragment.bind(range);parse(`&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ol&gt;&lt;ol&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ol&gt;`); AjaxFetch API 是用于替换 XMLHttpRequest 处理 ajax 的新标准，Chrome 和 Firefox 均支持，旧浏览器可以使用 polyfills 提供支持。 IE9+ 请使用 github/fetch，IE8+ 请使用 fetch-ie8，JSONP 请使用 fetch-jsonp。 4.1 从服务器读取数据并替换匹配元素的内容。 1234567// jQuery$(selector).load(url, completeCallback)// Nativefetch(url).then(data =&gt; data.text()).then(data =&gt; &#123; document.querySelector(selector).innerHTML = data&#125;).then(completeCallback) Events完整地替代命名空间和事件代理，链接到 https://github.com/oneuijs/oui-dom-events 5.0 Document ready by DOMContentLoaded 12345678910// jQuery$(document).ready(eventHandler);// Native// 检测 DOMContentLoaded 是否已完成if (document.readyState !== 'loading') &#123; eventHandler();&#125; else &#123; document.addEventListener('DOMContentLoaded', eventHandler);&#125; 5.1 使用 on 绑定事件 12345// jQuery$el.on(eventName, eventHandler);// Nativeel.addEventListener(eventName, eventHandler); 5.2 使用 off 解绑事件 12345// jQuery$el.off(eventName, eventHandler);// Nativeel.removeEventListener(eventName, eventHandler); 5.3 Trigger 123456789101112// jQuery$(el).trigger('custom-event', &#123;key1: 'data'&#125;);// Nativeif (window.CustomEvent) &#123; const event = new CustomEvent('custom-event', &#123;detail: &#123;key1: 'data'&#125;&#125;);&#125; else &#123; const event = document.createEvent('CustomEvent'); event.initCustomEvent('custom-event', true, true, &#123;key1: 'data'&#125;);&#125;el.dispatchEvent(event); Utilities大部分实用工具都能在 native API 中找到. 其他高级功能可以选用专注于该领域的稳定性和性能都更好的库来代替，推荐 lodash。 6.1 基本工具 isArray 检测参数是不是数组。 12345// jQuery$.isArray(range);// NativeArray.isArray(range); isWindow 检测参数是不是 window。 1234567// jQuery$.isWindow(obj);// Nativefunction isWindow(obj) &#123; return obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window;&#125; inArray 在数组中搜索指定值并返回索引 (找不到则返回 -1)。 12345678// jQuery$.inArray(item, array);// Nativearray.indexOf(item) &gt; -1;// ES6-wayarray.includes(item); isNumeric 检测传入的参数是不是数字。Use typeof to decide the type or the type example for better accuracy. 1234567// jQuery$.isNumeric(item);// Nativefunction isNumeric(n) &#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; isFunction 检测传入的参数是不是 JavaScript 函数对象。 1234567891011// jQuery$.isFunction(item);// Nativefunction isFunction(item) &#123; if (typeof item === 'function') &#123; return true; &#125; var type = Object.prototype.toString(item); return type === '[object Function]' || type === '[object GeneratorFunction]';&#125; isEmptyObject 检测对象是否为空 (包括不可枚举属性). 1234567// jQuery$.isEmptyObject(obj);// Nativefunction isEmptyObject(obj) &#123; return Object.keys(obj).length === 0;&#125; isPlainObject 检测是不是扁平对象 (使用 “{}” 或 “new Object” 创建). 12345678910111213141516// jQuery$.isPlainObject(obj);// Nativefunction isPlainObject(obj) &#123; if (typeof (obj) !== 'object' || obj.nodeType || obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window) &#123; return false; &#125; if (obj.constructor &amp;&amp; !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) &#123; return false; &#125; return true;&#125; extend 合并多个对象的内容到第一个对象。object.assign 是 ES6 API，也可以使用 polyfill。 12345// jQuery$.extend(&#123;&#125;, defaultOpts, opts);// NativeObject.assign(&#123;&#125;, defaultOpts, opts); trim 移除字符串头尾空白。 12345// jQuery$.trim(string);// Nativestring.trim(); map 将数组或对象转化为包含新内容的数组。 1234567// jQuery$.map(array, (value, index) =&gt; &#123;&#125;);// Nativearray.map((value, index) =&gt; &#123;&#125;); each 轮询函数，可用于平滑的轮询对象和数组。 1234567// jQuery$.each(array, (index, value) =&gt; &#123;&#125;);// Nativearray.forEach((value, index) =&gt; &#123;&#125;); grep 找到数组中符合过滤函数的元素。 1234567// jQuery$.grep(array, (value, index) =&gt; &#123;&#125;);// Nativearray.filter((value, index) =&gt; &#123;&#125;); type 检测对象的 JavaScript [Class] 内部类型。 12345678910// jQuery$.type(obj);// Nativefunction type(item) &#123; const reTypeOf = /(?:^\\[object\\s(.*?)\\]$)/; return Object.prototype.toString.call(item) .replace(reTypeOf, '$1') .toLowerCase();&#125; merge 合并第二个数组内容到第一个数组。 12345678910111213141516// jQuery$.merge(array1, array2);// Native// 使用 concat，不能去除重复值function merge(...args) &#123; return [].concat(...args)&#125;// ES6，同样不能去除重复值array1 = [...array1, ...array2]// 使用 Set，可以去除重复值function merge(...args) &#123; return Array.from(new Set([].concat(...args)))&#125; now 返回当前时间的数字呈现。 12345// jQuery$.now();// NativeDate.now(); proxy 传入函数并返回一个新函数，该函数绑定指定上下文。 12345// jQuery$.proxy(fn, context);// Nativefn.bind(context); makeArray 类数组对象转化为真正的 JavaScript 数组。 12345678// jQuery$.makeArray(arrayLike);// NativeArray.prototype.slice.call(arrayLike);// ES6-wayArray.from(arrayLike); 6.2 包含 检测 DOM 元素是不是其他 DOM 元素的后代. 12345// jQuery$.contains(el, child);// Nativeel !== child &amp;&amp; el.contains(child); 6.3 Globaleval 全局执行 JavaScript 代码。 12345678910111213// jQuery$.globaleval(code);// Nativefunction Globaleval(code) &#123; const script = document.createElement('script'); script.text = code; document.head.appendChild(script).parentNode.removeChild(script);&#125;// Use eval, but context of eval is current, context of $.Globaleval is global.eval(code); 6.4 解析 parseHTML 解析字符串为 DOM 节点数组. 12345678910111213141516// jQuery$.parseHTML(htmlString);// Nativefunction parseHTML(string) &#123; const context = document.implementation.createHTMLDocument(); // Set the base href for the created document so any parsed elements with URLs // are based on the document's URL const base = context.createElement('base'); base.href = document.location.href; context.head.appendChild(base); context.body.innerHTML = string; return context.body.children;&#125; parseJSON 传入格式正确的 JSON 字符串并返回 JavaScript 值. 12345// jQuery$.parseJSON(str);// NativeJSON.parse(str); PromisesPromise 代表异步操作的最终结果。jQuery 用它自己的方式处理 promises，原生 JavaScript 遵循 Promises/A+ 标准实现了最小 API 来处理 promises。 7.1 done, fail, always done 会在 promise 解决时调用，fail 会在 promise 拒绝时调用，always 总会调用。 12345// jQuery$promise.done(doneCallback).fail(failCallback).always(alwaysCallback)// Nativepromise.then(doneCallback, failCallback).then(alwaysCallback, alwaysCallback) 7.2 when when 用于处理多个 promises。当全部 promises 被解决时返回，当任一 promise 被拒绝时拒绝。 123456// jQuery$.when($promise1, $promise2).done((promise1Result, promise2Result) =&gt; &#123;&#125;);// NativePromise.all([$promise1, $promise2]).then([promise1Result, promise2Result] =&gt; &#123;&#125;); 7.3 Deferred Deferred 是创建 promises 的一种方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// jQueryfunction asyncFunc() &#123; const defer = new $.Deferred(); setTimeout(() =&gt; &#123; if(true) &#123; defer.resolve('some_value_computed_asynchronously'); &#125; else &#123; defer.reject('failed'); &#125; &#125;, 1000); return defer.promise();&#125;// Nativefunction asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (true) &#123; resolve('some_value_computed_asynchronously'); &#125; else &#123; reject('failed'); &#125; &#125;, 1000); &#125;);&#125;// Deferred wayfunction defer() &#123; const deferred = &#123;&#125;; const promise = new Promise((resolve, reject) =&gt; &#123; deferred.resolve = resolve; deferred.reject = reject; &#125;); deferred.promise = () =&gt; &#123; return promise; &#125;; return deferred;&#125;function asyncFunc() &#123; const defer = defer(); setTimeout(() =&gt; &#123; if(true) &#123; defer.resolve('some_value_computed_asynchronously'); &#125; else &#123; defer.reject('failed'); &#125; &#125;, 1000); return defer.promise();&#125; Animation 8.1 Show &amp; Hide 12345678// jQuery$el.show();$el.hide();// Native// 更多 show 方法的细节详见 https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L363el.style.display = ''|'inline'|'inline-block'|'inline-table'|'block';el.style.display = 'none'; 8.2 Toggle 显示或隐藏元素。 123456789// jQuery$el.toggle();// Nativeif (el.ownerDocument.defaultView.getComputedStyle(el, null).display === 'none') &#123; el.style.display = ''|'inline'|'inline-block'|'inline-table'|'block';&#125; else &#123; el.style.display = 'none';&#125; 8.3 FadeIn &amp; FadeOut 12345678910// jQuery$el.fadeIn(3000);$el.fadeOut(3000);// Nativeel.style.transition = 'opacity 3s';// fadeInel.style.opacity = '1';// fadeOutel.style.opacity = '0'; 8.4 FadeTo 调整元素透明度。 12345// jQuery$el.fadeTo('slow',0.15);// Nativeel.style.transition = 'opacity 3s'; // 假设 'slow' 等于 3 秒el.style.opacity = '0.15'; 8.5 FadeToggle 动画调整透明度用来显示或隐藏。 1234567891011// jQuery$el.fadeToggle();// Nativeel.style.transition = 'opacity 3s';const &#123; opacity &#125; = el.ownerDocument.defaultView.getComputedStyle(el, null);if (opacity === '1') &#123; el.style.opacity = '0';&#125; else &#123; el.style.opacity = '1';&#125; 8.6 SlideUp &amp; SlideDown 1234567891011// jQuery$el.slideUp();$el.slideDown();// Nativeconst originHeight = '100px';el.style.transition = 'height 3s';// slideUpel.style.height = '0px';// slideDownel.style.height = originHeight; 8.7 SlideToggle 滑动切换显示或隐藏。 12345678910111213// jQuery$el.slideToggle();// Nativeconst originHeight = '100px';el.style.transition = 'height 3s';const &#123; height &#125; = el.ownerDocument.defaultView.getComputedStyle(el, null);if (parseInt(height, 10) === 0) &#123; el.style.height = originHeight;&#125;else &#123; el.style.height = '0px';&#125; 8.8 Animate 执行一系列 CSS 属性动画。 12345678// jQuery$el.animate(&#123; params &#125;, speed);// Nativeel.style.transition = 'all ' + speed;Object.keys(params).forEach((key) =&gt; el.style[key] = params[key]) Alternatives 你可能不需要 jQuery (You Might Not Need jQuery) - 如何使用原生 JavaScript 实现通用事件，元素，ajax 等用法。 npm-dom 以及 webmodules - 在 NPM 上提供独立 DOM 模块的组织","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"ES6 的小技巧","slug":"daily-js-es6-skill","date":"2018-05-06T04:41:15.000Z","updated":"2021-06-24T04:02:41.986Z","comments":true,"path":"2018/05/06/daily-js-es6-skill/","link":"","permalink":"https://doubleray.top/2018/05/06/daily-js-es6-skill/","excerpt":"","text":"调试123const a=6,b=9,c=0;console.log(&#123;a,b,c&#125;);//输出 &#123;a:5,b:9,c:0&#125; 结构Async/Await1234const [grade,fee] = await Promise.all([ fetch('/grade'), fetch('/fee')]) 合并数据123const arr_1 = ['a','b','c']const arr_2 = [1,2,3]const result = [...arr_1,...arr_2] 深拷贝对象和数组123456789101112const object_1 = &#123; a:5, b:6, c:7&#125;,arr_1 = [1,2,3]const obj = &#123;...object_1&#125;const arr = [...arr_1]console.log(obj===object_1) //falseconsole.log(arr===arr_1) //false","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JavaScript 跳转页面","slug":"daily-js-location","date":"2018-04-16T04:41:15.000Z","updated":"2021-06-24T04:02:41.986Z","comments":true,"path":"2018/04/16/daily-js-location/","link":"","permalink":"https://doubleray.top/2018/04/16/daily-js-location/","excerpt":"","text":"JavaScript 如何跳转页面？也许你不知道有这么多解法 123456789101112// 跳转window.location.replace('https://www.awesomes.cn') // 不将被跳转页面加入浏览器记录window.location.assign('https://www.awesomes.cn')window.location.href = 'https://www.awesomes.cn'window.location = 'https://www.awesomes.cn'// 返回上一页window.history.back()window.history.go(-1)// 刷新当前页window.location.reload()","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"chrome 调试小技巧","slug":"article-js-mvvm-vue","date":"2018-04-01T11:41:15.000Z","updated":"2021-06-24T04:02:41.968Z","comments":true,"path":"2018/04/01/article-js-mvvm-vue/","link":"","permalink":"https://doubleray.top/2018/04/01/article-js-mvvm-vue/","excerpt":"","text":"Chrome F12 中有一个很多同学都不知道的功能，审查元素并切换到 Styles 面板中，按住 Ctrl 键，移到某个样式属性的值（出现下划线），然后点击即可导航到定义该样式属性的 CSS 文件中。 Chrome 开发者工具已支持在选中的元素上按下 h 键快速隐藏该元素（如果你不想按 Del 键直接删除该元素的话） Chrome 开发者工具的 Network 信息项头部右键即可选择要显示哪些请求信息","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://doubleray.top/tags/Debug/"}]},{"title":"ES6新特性 —— Class","slug":"article-ES6-class-know","date":"2018-03-14T11:41:15.000Z","updated":"2021-06-24T04:02:41.952Z","comments":true,"path":"2018/03/14/article-ES6-class-know/","link":"","permalink":"https://doubleray.top/2018/03/14/article-ES6-class-know/","excerpt":"前言类语法(class)是ES6中新增的一个亮点特性，下文简单对class的理解做一个简要的记录说明。","text":"前言类语法(class)是ES6中新增的一个亮点特性，下文简单对class的理解做一个简要的记录说明。 js传统模式实例化对象方法——prototype在JavaScript中，实例化一个对象的传统使用方法是通过构造函数。如下示例： 1234567891011function Count(num1,num2)&#123; this.num1 = num1; this.num2 = num2;&#125;//构造函数Count.prototype.number = function()&#123; console.log(this.num1,this.num2);&#125;//实例化对象var count = new Count(1,2);count.number(1,3); ES6新特性——使用Class（类）实例化对象ES6引入了Class(类)这一概念，可以通过class关键字，定义类。 如下示例： 123456789101112131415161718192021222324252627282930313233343536373839//定义类class Count&#123; //构造方法 constructor(x,y)&#123; //this表示实例对象 this.x = x; this.y = y; &#125; //非静态方法，可以直接用实例.方法名来访问 sum(x,y)&#123; let sum = x+y; console.log('sum is :',sum) &#125; //静态方法，需要通过构造器或者类才能访问的到 static sub(x,y)&#123; let sub = x - y; console.log('sub is :',sub); &#125;&#125;var count = new Count();//非静态方法，可以直接访问count.sum(1,2); // sum is :3//静态方法：//（1）实例对象.constructor.方法名count.constructor.sub(5,1); // sub is :4//（2）类名.方法名Count.sub(5,1); // sub is :4count.hasOwnProperty('x'); // 定义在this上，是实例对象自身的属性truecount.hasOwnProperty('y'); // truecount.hasOwnProperty('sum'); // 定义在原型对象上，falsecount._proto_.hasOwnProperty('sum'); // true 通过以上的小实例，总结下面几点: 定义“类”的方法时，不用加function关键字。 方法之间不要加逗号，加了会报错。 类中必须要有constructor方法，若没有显示定义，则一个空的会被添加。 类必须使用new调用。否则报错，这是类和构造函数的一个主要区别。 类中使用static关键字声明的方法，需要通过构造函数constructor或者使用类名才可以访问的到。 静态方法，实例对象不能直接访问。但是父类的静态方法，子类可以继承。 非静态方法，可以直接通过“实例对象.方法名”访问。 实例自身的属性，除非显示定义在this对象上，否则都是定义在原型上（即class上）。 其实，ES6的类，可以看作是构造函数的另外一种写法。 12345class B&#123;&#125;var b = new B();typeof B; //`function`typeof B === B.prototype.constructor //truetypeof b.constructor === B.prototype.constructor //true 对比ES6和ES5，有以下相同点 类的数据类型就是函数，类本身就指向构造函数。 在类的实例上调用方法，就是调用原型上的方法。 再来看ES6与ES5的不同点 由于类的方法都定义在prototype上面，那么我们可以使用Object.assign方法给类一次添加多个方法。prototype的constructor方法，直接指向“类”本身，这和ES5的行为是有区别的。另外，类内部所有定义的方法，都是不可枚举的，而ES5中，prototype上的方法都是可枚举的。 示例如下： 12345678910111213141516171819202122//ES5function Test()&#123;&#125;Test.prototype.log = function()&#123;&#125;var test = new Test();Object.keys(Test.prototype); //列举出给定对象自身可枚举属性(不包括原型上的属性) //['log']Object.getOwnPropertyNames(Test.prototype); //列举出给定对象所有自身属性的名称（包括不可枚举属性但不包括Symbol值作为名称的属性） //['prototype','log']//ES6class Test2&#123; toValue()&#123;&#125;&#125;var test2 = new Test2();Object.keys(Test2.prototype);//[]Object.getOwnPropertyNames(Test2.prototype);//['constructor','toValue']; Class的静态方法 类中所定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，那该静态方法不会被实例继承，而是直接通过类来调用的。 1234567891011121314class Foo&#123; static addMethod()&#123; console.log(this); console.log('hello class'); //this. &#125;&#125;//直接通过类来调用Foo.addMethod(); //Foo , hello class//实例不会继承静态方法，所以调用会报错var foo = new Foo();foo.addMethod(); //TypeError:foo.addMethod is not a function 注意： 如果static静态方法包含this关键字，这个this指的是类，而不是实例。 静态方法可以与非静态方法同名。 父类的静态方法，可以被子类继承。 静态方法可以从super对象上调用。","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"移动端滚动穿透问题","slug":"daily-mobile-scroll","date":"2018-03-06T01:41:15.000Z","updated":"2021-06-24T04:02:41.987Z","comments":true,"path":"2018/03/06/daily-mobile-scroll/","link":"","permalink":"https://doubleray.top/2018/03/06/daily-mobile-scroll/","excerpt":"滚动穿透是指在移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。网上整理了几种解决方案，但有些还是存在一定的问题。","text":"滚动穿透是指在移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容。网上整理了几种解决方案，但有些还是存在一定的问题。 设置overflow为hidden123456.modal-open &#123; &amp;, body &#123; overflow: hidden; height: 100% &#125;&#125; 即当弹出层弹出时在html上添加.modal-open,禁用 html 和 body 的滚动条,但实际用上就会发现： 由于 html 和 body的滚动条都被禁用，弹出层后页面的滚动位置会丢失，需要用 js 来计算原来滚动的位置，在弹出时保持滚动位置； 但是页面的背景还是能够有滚的动的效果。 js 之 touchmove + preventDefault123modal.addEventListener('touchmove', function(e) &#123; e.preventDefault();&#125;, false); 即通过阻止移动端touchmove事件，但实际用上会发现弹出层需要滚动时也会被阻止。 最后解决方案：position: fixed1234body.modal-open &#123; position: fixed; width: 100%;&#125; 这种方式同样当弹出层弹出时滚动条会丢失，所以还需要使用js来保存滚动条的位置，在关闭弹出层时将滚动位置还原； 1234567891011121314var ModalHelper = (function(bodyCls) &#123; var scrollTop; // 在闭包中定义一个用来保存滚动位置的变量 return &#123; afterOpen: function() &#123; //弹出之后记录保存滚动位置，并且给body添加.modal-open scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; //关闭时将.modal-open移除并还原之前保存滚动位置 document.body.classList.remove(bodyCls); document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal-open'); 这个方案比较完美的解决了移动端滚动穿透问题！","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"chorme浏览器记住密码后input黄色背景处理方法总结（三种）","slug":"daily-css-input","date":"2018-02-28T01:41:15.000Z","updated":"2021-06-24T04:02:41.983Z","comments":true,"path":"2018/02/28/daily-css-input/","link":"","permalink":"https://doubleray.top/2018/02/28/daily-css-input/","excerpt":"","text":"问题分析正常情况： 记住密码后访问： 解决方法方法1：阴影覆盖123input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0 1000px white inset !important;&#125; 注：由于是设置颜色覆盖，所以只对非透明的纯色背景有效； 方法2：修改chrome浏览器渲染黄色背景的时间（推荐）1234:-webkit-autofill &#123; -webkit-text-fill-color: #fff !important; transition: background-color 5000s ease-in-out 0s;&#125; 注：此方法适用于上图那种背景为透明色的输入框 方法3：jq方式去除123456789101112if (navigator.userAgent.toLowerCase().indexOf(\"chrome\") &gt;= 0)&#123; let _interval = window.setInterval(function () &#123; let autofills = $('input:-webkit-autofill'); if (autofills.length &gt; 0) &#123; window.clearInterval(_interval); // 停止轮询 autofills.each(function() &#123; let clone = $(this).clone(true, true); $(this).after(clone).remove(); &#125;); &#125; &#125;, 20);&#125;","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"JavaScript 箭头函数语法小结","slug":"daily-js-arrow-func","date":"2018-02-23T01:41:15.000Z","updated":"2021-06-24T04:02:41.986Z","comments":true,"path":"2018/02/23/daily-js-arrow-func/","link":"","permalink":"https://doubleray.top/2018/02/23/daily-js-arrow-func/","excerpt":"箭头函数的确与传统函数有不同之处，但仍存在共同的特点。 例如： 对箭头函数进行typeof操作会返回“function”。 箭头函数仍是Function的实例，故而instanceof的执行方式与传统函数一致。 call/apply/bind方法仍适用于箭头函数，但就算调用这些方法扩充当前作用域，this也依旧不会变化。 箭头函数与传统函数最大的不同之处在，禁用new操作","text":"箭头函数的确与传统函数有不同之处，但仍存在共同的特点。 例如： 对箭头函数进行typeof操作会返回“function”。 箭头函数仍是Function的实例，故而instanceof的执行方式与传统函数一致。 call/apply/bind方法仍适用于箭头函数，但就算调用这些方法扩充当前作用域，this也依旧不会变化。 箭头函数与传统函数最大的不同之处在，禁用new操作 没有参数时1var demo = function () &#123;&#125; 相当于： 1var demo = () =&gt; &#123;&#125; 只有一个参数时123var demo = function(a)&#123; return a;&#125; 相当于： 1var demo = a =&gt; a 多个参数需要用到小括号，参数间逗号间隔123var demo = function(a,b)&#123; return a+b;&#125; 相当于： 1var demo = (a,b) =&gt; a+b 函数体多条语句需要用到大括号1234567var demo = function(a,b)&#123;if(a&gt;b)&#123; return a-b;&#125; else&#123; return b-a; &#125;&#125; 相当于： 1234567var demo = (a,b) =&gt;&#123;if(a&gt;b)&#123; return a-b;&#125; else&#123; return b-a; &#125;&#125; 返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了123456var demo = (name,age) =&gt;&#123;return (&#123; name: name, age: age &#125;)&#125; 作为数组排序回调1234567var arr = [1, 9 , 2, 4, 3, 8].sort((a, b) =&gt; &#123; if (a - b &gt; 0 ) &#123; return 1 &#125; else &#123; return -1 &#125;&#125;)","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"Git 修改远程仓库地址","slug":"daily-git-remote-change","date":"2018-02-22T06:41:15.000Z","updated":"2021-06-24T04:02:41.984Z","comments":true,"path":"2018/02/22/daily-git-remote-change/","link":"","permalink":"https://doubleray.top/2018/02/22/daily-git-remote-change/","excerpt":"","text":"查看仓库地址 ： git remote -v 方法有三种： 1、 修改命令 1git remote set-url origin [url] 2、 先删后加 12git remote rm origingit remote add origin [url] 3、 直接修改config文件","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"git","slug":"git","permalink":"https://doubleray.top/tags/git/"}]},{"title":"JavaScript 的 in 和 for..in","slug":"daily-js-for-in","date":"2018-02-06T06:00:15.000Z","updated":"2021-06-24T04:02:41.986Z","comments":true,"path":"2018/02/06/daily-js-for-in/","link":"","permalink":"https://doubleray.top/2018/02/06/daily-js-for-in/","excerpt":"for...in... 遍历一个对象的属性，把属性名和属性值都提出来in 判断一个属性是否属于一个对象","text":"for...in... 遍历一个对象的属性，把属性名和属性值都提出来in 判断一个属性是否属于一个对象 for…infor…in 语句用于遍历数组或者对象的属性 对数组或者对象的属性进行循环操作 for … in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 语法: 123for (变量 in 对象)&#123; //todo&#125; 变量:用来指定变量，指定的变量可以是数组的属性，也可以是对象的属性 如果是数组属性默认为下标 实例: 12345678910111213141516171819202122232425262728//数组var mycars = [\"Saab\",\"Volvo\",\"BMW\"];for(var x in mycars)&#123; console.log(x); console.log(mycars[x]);&#125;//0//Saab//1//Volvo//2//BMW//对象var mycars = &#123; s:\"Saab\", v:\"Volvo\", b:\"BMW\"&#125;for(var x in mycars)&#123; console.log(x); console.log(mycars[x]);&#125;//s//Saab//v//Volvo//b//BMW 对于遍历的key是string类型,所以 typeof x == &quot;string&quot; 数组是特殊的对象 使用for-in进行循环也被称为“枚举” 如果数组/对象prototype的原型上添加一个函数如:Array.prototype.test=function(){}/Object.prototype.test=function(){},也会遍历出来,可以使用hasOwnProperty()获得本身的属性，排除原型链上的属性 由于以上的原因，尽量不要使用该方法遍历数组 在for-in中，属性列表的顺序（序列）是不能保证的,所以最好数组使用正常的for循环，对象使用for-in循环 inin操作符用来判断某个属性属于某个对象，可以是对象的直接属性，也可以是通过prototype继承的属性 对于一般的对象属性需要用字符串指定属性的名称: 1234567var mycar = &#123; make: \"Honda\", model: \"Accord\", year: 1998&#125;console.log(\"make\" in mycar); //trueconsole.log(\"makse\" in mycar); //false 对于数组属性需要指定数字形式的索引值来表示数组的属性名称（固有属性除外，如length） 1234567var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");0 in trees // returns true3 in trees // returns true6 in trees // returns false\"bay\" in trees // returns false (you must specify the index number, // not the value at that index)\"length\" in trees // returns true (length is an Array property) in的右边必须是一个对象,如：你可以指定一个用String构造器生成的，但是不能指定字符串直接量的形式： 1234var color1 = new String(\"green\");\"length\" in color1 // returns truevar color2 = \"coral\";\"length\" in color2 // Uncaught TypeError 如果你使用delete操作符删除了一个属性，再次用in检查时，会返回false 1234567var mycar = &#123;make: \"Honda\", model: \"Accord\", year: 1998&#125;;delete mycar.make;\"make\" in mycar; // 返回falsevar trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");delete trees[3];3 in trees; // 返回false 如果你把一个属性值设为undefined，但是没有使用delete操作符，使用in检查，会返回true 123var mycar = &#123;make: \"Honda\", model: \"Accord\", year: 1998&#125;;mycar.make = undefined;\"make\" in mycar; // 返回true 123var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");trees[3] = undefined;3 in trees; // 返回true 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。 1\"toString\" in &#123;&#125;; // 返回true","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"微信H5 Video 开发小结","slug":"daily-h5-video","date":"2018-02-01T06:41:15.000Z","updated":"2021-06-24T04:02:41.985Z","comments":true,"path":"2018/02/01/daily-h5-video/","link":"","permalink":"https://doubleray.top/2018/02/01/daily-h5-video/","excerpt":"最近开发公众号内H5网页过程中，为了达到“炫”的效果，有些特效采用了video展示，但是微信内的video展示着实太费神了，这里总结一些遇到的坑和解决的办法。","text":"最近开发公众号内H5网页过程中，为了达到“炫”的效果，有些特效采用了video展示，但是微信内的video展示着实太费神了，这里总结一些遇到的坑和解决的办法。 video的属性1234567891011121314&lt;video id=\"video\" src=\"video.mp4\" controls = \"true\" poster=\"images.jpg\" &lt;!--视频封面--&gt; preload=\"auto\" webkit-playsinline=\"true\" &lt;!--这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放 --&gt; playsinline=\"true\" &lt;!--IOS微信浏览器支持小窗内播放--&gt; x-webkit-airplay=\"allow\" x5-video-player-type=\"h5\" &lt;!--启用H5播放器,是wechat安卓版特性--&gt; x5-video-player-fullscreen=\"true\" &lt;!--全屏设置，设置为 true 是防止横屏--&gt; x5-video-orientation=\"portraint\" &lt;!--播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏--&gt; style=\"object-fit:fill\"&gt;&lt;/video&gt; src: 视频的地址 controls: 加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 poster: 属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。 preload: 属性规定在页面加载后载入视频。 webkit-playsinline和playsinline: 视频播放时局域播放，不脱离文档流。但是这个属性比较特别，需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback = YES，才能生效。换句话说，如果APP不设置，你页面中加了这标签也无效，这也就是为什么安卓手机WeChat 播放视频总是全屏，因为APP不支持playsinline，而IOS的WeChat却支持。这里就要补充下，如果是想做全屏直播或者全屏H5体验的用户，IOS需要设置删除 webkit-playsinline 标签，因为你设置 false 是不支持的 ，安卓则不需要，因为默认全屏。但这时候全屏是有播放控件的，无论你有没有设置control。 做直播的可能用得着播放控件，但是全屏H5是不需要的，那么去除全屏播放时候的控件，需要以下设置：同层播放 x-webkit-airplay=&quot;allow&quot; : 这个属性应该是使此视频支持ios的AirPlay功能。使用AirPlay可以直接从使用iOS的设备上的不同位置播放视频、音乐还有照片文件，也就是说通过AirPlay功能可以实现影音文件的无线播放，当然前提是播放的终端设备也要支持相应的功能 x5-video-player-type: 启用同层H5播放器，就是在视频全屏的时候，div可以呈现在视频层上，也是WeChat安卓版特有的属性。同层播放别名也叫做沉浸式播放，播放的时候看似全屏，但是已经除去了control和微信的导航栏，只留下”X”和”&lt;”两键。目前的同层播放器只在Android（包括微信）上生效，暂时不支持iOS。至于为什么同层播放只对安卓开放，是因为安卓不能像ISO一样局域播放，默认的全屏会使得一些界面操作被阻拦，如果是全屏H5还好，但是做直播的话，诸如弹幕那样的功能就无法实现了，所以这时候同层播放的概念就解决了这个问题。不过在测试的过程中发现，不同版本的IOS和安卓效果略有不同 x5-video-orientation: 声明播放器支持的方向，可选值landscape 横屏, portraint竖屏。默认值portraint。无论是直播还是全屏H5一般都是竖屏播放，但是这个属性需要x5-video-player-type开启H5模式 x5­-video­-player­-fullscreen:全屏设置。它又两个属性值，ture和false，true支持全屏播放，false不支持全屏播放。其实，IOS 微信浏览器是Chrome的内核，相关的属性都支持，也是为什么X5同层播放不支持的原因。安卓微信浏览器是X5内核，一些属性标签比如playsinline就不支持，所以始终全屏。 playsinline 属性在 iOS 10 之前需要写成 webkit-playsinline，它的浏览器厂商前缀在 iOS 10 中被移除。但是目前 iOS 微信还不支持去掉前缀的写法，两个属性最好都加上。 Media方法和属性HTMLVideoElement 和HTMLAudioElement 均继承自HTMLMediaElement 1234567891011121314151617181920212223242526272829303132333435363738394041//错误状态 Media.error; //null:正常 Media.error.code; //1.用户终止 2.网络错误 3.解码错误 4.URL无效 //网络状态 Media.currentSrc; //返回当前资源的URL Media.src = value; //返回或设置当前资源的URL Media.canPlayType(type); //是否能播放某种格式的资源 Media.networkState; //0.此元素未初始化 1.正常但没有使用网络 2.正在下载数据 3.没有找到资源 Media.load(); //重新加载src指定的资源 Media.buffered; //返回已缓冲区域，TimeRanges Media.preload; //none:不预载 metadata:预载资源信息 auto: //准备状态 Media.readyState; //1:HAVE_NOTHING 2:HAVE_METADATA 3.HAVE_CURRENT_DATA 4.HAVE_FUTURE_DATA 5.HAVE_ENOUGH_DATA Media.seeking; //是否正在seeking //回放状态 Media.currentTime = value; //当前播放的位置，赋值可改变位置 Media.startTime; //一般为0，如果为流媒体或者不从0开始的资源，则不为0 Media.duration; //当前资源长度 流返回无限 Media.paused; //是否暂停 Media.defaultPlaybackRate = value;//默认的回放速度，可以设置 Media.playbackRate = value;//当前播放速度，设置后马上改变 Media.played; //返回已经播放的区域，TimeRanges，关于此对象见下文 Media.seekable; //返回可以seek的区域 TimeRanges Media.ended; //是否结束 Media.autoPlay; //是否自动播放 Media.loop; //是否循环播放 Media.play(); //播放 Media.pause(); //暂停 //控制 Media.controls;//是否有默认控制条 Media.volume = value; //音量 Media.muted = value; //静音 //TimeRanges(区域)对象 TimeRanges.length; //区域段数 TimeRanges.start(index) //第index段区域的开始位置 TimeRanges.end(index) //第index段区域的结束位置 Media相关的事件123456789101112131415161718192021&quot;loadstart&quot;：客户端开始请求数据&quot;progress&quot;：客户端正在请求数据&quot;suspend&quot;：延迟下载&quot;abort&quot;：客户端主动终止下载（不是因为错误引起），&quot;error&quot;：请求数据时遇到错误&quot;stalled&quot;：网速失速&quot;play&quot;：play()和autoplay开始播放时触发&quot;pause&quot;：pause()触发&quot;loadedmetadata&quot;：成功获取资源长度&quot;loadeddata&quot;：&quot;waiting&quot;：等待数据，并非错误&quot;playing&quot;：开始回放&quot;canplay&quot;：可以播放，但中途可能因为加载而暂停&quot;canplaythrough&quot;：可以播放，歌曲全部加载完毕&quot;seeking&quot;：寻找中&quot;seeked&quot;：寻找完毕&quot;timeupdate&quot;：播放时间改变&quot;ended&quot;：播放结束&quot;ratechange&quot;：播放速率改变&quot;durationchange&quot;：资源长度改变&quot;volumechange&quot;：音量改变 事件、属性及展示效果使用常见问题预加载移动端原因， video 并不会主动去预加载用户未需求的资源，因此我们需要手动去触发 video 的预加载资源（安卓端下，滚动行为不归属在用户操作行为中） 1document.getElementById('my-video').play(); 这样就可以了吗？不，万恶的微信限制了必须用户行为才能播放媒体资源，因此我们只能再祭出万能 hack： 1&lt;script src=\"//res.wx.qq.com/open/js/jweixin-1.2.0.js\"&gt;&lt;/script&gt; 123456789101112131415document.addEventListener('DOMContentLoaded', function() &#123; var video = document.getElementById('my-video'); function preload() &#123; video.play(); setTimeout(function () &#123; video.pause(); &#125;, 200); &#125; document.addEventListener(\"WeixinJSBridgeReady\", preload, false); /*这一段调用会有内存问题，暂未找到原因*/ if (typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\") &#123; WeixinJSBridge.invoke(\"getNetworkType\", &#123;&#125;, preload); &#125; //preload(); &#125;); 全屏处理IOSios加playsinline属性，之前只带webkit前缀的在ios10以后，会吊起系统自带播放器，两个属性都加上基本ios端都可以保证内敛到浏览器webview里面了。如果仍有个别版本的ios会吊起播放器，还可以引用一个库iphone-inline-video（具体用法很简单看它 github，这里不介绍了，只需加js一句话，css加点），github地址加上playsinline webkit-playsinline这两个属性和这个库基本可以保证ios端没有问题了（不过亲测，只加这两个属性不引入库好像也是ok的，至今没有在ios端微信没有出现问题，如果你要兼容uc或者qq的浏览器建议带上这个库） androidx5-video-player-type=”h5”属性，腾讯x5内核系的android微信和手Q内置浏览器用的浏览器webview的内核，使用这个属性在微信中视频会有不同的表现，会呈现全屏状态，貌似播放控件剥去了，至少加了这个属性后视频上层可以有其他dom元素出现了（非腾讯白名单机制的一种处理措施）。 自动播放android始终不能自动播放，不多说。值得一提的是经测现在ios10后版本的safari和微信都不让视频自动播放了（顺带音频也不能自动播放了），但微信提供了一个事件WeixinJSBridgeReady，在微信嵌入webview全局的这个事件触发后，视频仍可以自动播放，这个应该是现在在ios端微信的视频自动播放的比较靠谱的方式，其他如手q或者其他浏览器，建议就引导用户出发触屏的行为操作出发比较好。 1234document.addEventListener(\"WeixinJSBridgeReady\", function ()&#123; video.play(); video.pause();&#125;, false) 播放控制对于video或者audio等媒体元素，有一些方法，常用的有play(),pause();也有一些事件，如&#39;loadstart&#39;,&#39;canplay&#39;,&#39;canplaythrough&#39;,&#39;ended&#39;,&#39;timeupdate&#39;.....等等。在移动端有一些坑需要注意，不要轻易使用媒体元素的除&#39;ended&#39;,&#39;timeupdate&#39;以外event事件，在不同的机子上可能有不同的情况产生，例如：ios下监听&#39;canplay&#39;和&#39;canplaythrough&#39;（是否已缓冲了足够的数据可以流畅播放）,当加载时是不会触发的，即使preload=&quot;auto&quot;也没用，但在pc的chrome调试器下和android下，是会在加载阶段就触发。ios需要播放后才会触发。总之就是现在的视频标准还不尽完善，有很多坑要注意，要使用前最好自己亲测一遍就是当第一次播放视频的时候ios端，如果网络慢，视频从开始播到能展现画面会有短暂的黑屏（处理视频源数据的时间），为了避免这个黑屏，可以在视频上加个div浮层（可以一个假的视频第一帧），然后用timeupdate方法监听，视屏播放及有画面的时候再移除浮层 1234567video.addEventListener('timeupdate',function ()&#123; //当视频的currentTime大于0.1时表示黑屏时间已过，已有视频画面，可以移除浮层（.pagestart的div元素） if ( !video.isPlayed &amp;&amp; this.currentTime&gt;0.1 )&#123; $('.pagestart').fadeOut(500); video.isPlayed = !0; &#125;&#125;) 隐藏播放控件据说腾讯的android团队的x5内核团队放开了视频播放的限制，视频不一定调用它们那个备受诟病的视频播放器了，x5-video-player-type=&quot;h5&quot;属性这个属性就有点那个意思，虽然体验还是有点…（导航栏也会清理）但至少播放器控件没有了，上层可以浮div或者其他元素了，这个还是值得一提。还有一点值得说的是，带播放器控件的隐藏. 123&lt;div class=\"videobox\" ontouchmove=\"return false;\"&gt; &lt;video id=\"mainvideo\" src=\"test.mp4\" x5-video-player-type=\"h5\" playsinline webkit-playsinline&gt;&lt;/video&gt;&lt;/div&gt; 比如这个videobox在android下隐藏，只用display：none貌似还是不行的，但加个z-index:-1，设置成-1就可以达到隐藏播放器控件的目的了。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://doubleray.top/tags/HTML/"}]},{"title":"JavaScript 深拷贝性能分析","slug":"article-js-deepcopy","date":"2018-01-21T06:41:15.000Z","updated":"2021-06-24T04:02:41.965Z","comments":true,"path":"2018/01/21/article-js-deepcopy/","link":"","permalink":"https://doubleray.top/2018/01/21/article-js-deepcopy/","excerpt":"原文：Deep-copying in JavaScript - DasSur.ma 如何在 JavaScript 中拷贝一个对象？对于这个很简单的问题，但是答案却不简单。","text":"原文：Deep-copying in JavaScript - DasSur.ma 如何在 JavaScript 中拷贝一个对象？对于这个很简单的问题，但是答案却不简单。 引用传值先看下面的例子： 1234567function mutate(obj) &#123; obj.a = true;&#125;const obj = &#123;a: false&#125;;mutate(obj)console.log(obj.a); // 输出 true 函数 mutate 改变了它的参数。在值传递的场景中，函数的形参只是实参的一个副本——a copy——当函数调用完成后，并不改变实参。但是在 JavaScript 这种引用传递的场景中，函数的形参和实参指向同一个对象，当参数内部改变形参的时候，函数外面的实参也被改变了。 因此在某些情况下，你需要保留原始对象，这时你需要把原始对象的一个拷贝传入到函数中，以防止函数改变原始对象。 浅拷贝：Object.assign()一个简单的获取对象拷贝的方式是使用 Object.assign(target, sources…)。它接受任意数量的源对象，枚举它们的所有属性并分配给target。如果我们使用一个新的空对象target，那么我们就可以实现对象的复制。 12const obj ='' /* ... */;const copy = Object.assign(&#123;&#125;, obj); 然而这只是一个浅副本。如果我们的对象包含其它对象作为自己的属性，它们将保持共享引用，这不是我们想要的： 12345678function mutateDeepObject(obj) &#123; obj.a.thing = true;&#125;const obj = &#123;a: &#123;thing: false&#125;&#125;;const copy = Object.assign(&#123;&#125;, obj);mutateDeepObject(copy)console.log(obj.a.thing); // prints true Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 所以现在怎么办？有几种方法可以创建一个对象的深拷贝。 注意：也许有人提到了对象解构运算，这也是浅拷贝。 JSON.parse创建对象副本的最古老方法之一是： 将该对象转换为其 JSON 字符串表示形式，然后将其解析回对象。这感觉有点压抑，但它确实有效： 12const obj = ''/* ... */;const copy = JSON.parse(JSON.stringify(obj)); 这里的缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。 1234const x = &#123;&#125;;const y = &#123;x&#125;;x.y = y; // Cycle: x.y.x.y.x.y.x.y.x...const copy = JSON.parse(JSON.stringify(x)); // throws! 另外，诸如 Maps, Sets, RegExps, Dates, ArrayBuffers 和其他内置类型在进行序列化时会丢失。 Structured Clone 结构化克隆算法Structured cloning 是一种现有的算法，用于将值从一个地方转移到另一地方。例如，每当您调用postMessage将消息发送到另一个窗口或 WebWorker 时，都会使用它。关于结构化克隆的好处在于它处理循环对象并支持大量的内置类型。问题是，在编写本文时，该算法并不能直接使用，只能作为其他 API 的一部分。 MessageChannel正如我所说的，只要你调用postMessage结构化克隆算法就可以使用。我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。 12345678910function structuralClone(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;const obj = ''/* ... */;const clone = await structuralClone(obj); 这种方法的缺点是它是异步的。虽然这并无大碍，但是有时候你需要使用同步的方式来深度拷贝一个对象。 History API如果你曾经使用history.pushState()写过 SPA，你就知道你可以提供一个状态对象来保存 URL。事实证明，这个状态对象使用结构化克隆 - 而且是同步的。我们必须小心使用，不要把程序逻辑使用的状态对象搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用history.replaceState()而不是history.pushState()。 12345678910function structuralClone(obj) &#123; const oldState = history.state; history.replaceState(obj, document.title); const copy = history.state; history.replaceState(oldState, document.title); return copy;&#125;const obj = ''/* ... */;const clone = structuralClone(obj); 然而，仅仅为了复制一个对象，而使用浏览器的引擎，感觉有点过分。另外，Safari 浏览器对replaceState调用的限制数量为 30 秒内 100 次。 Notification API第三种方法来利用结构化克隆：Notification API。 123456function structuralClone(obj) &#123; return new Notification('', &#123;data: obj, silent: true&#125;).data;&#125;const obj = ''/* ... */;const clone = structuralClone(obj); 短小，简洁。 但是，它需要浏览器内部的权限机制，所以我怀疑它是很慢的。由于某种原因，Safari 总是返回undefined。 结论 如果您没有循环对象，并且不需要保留内置类型，则可以使用跨浏览器的JSON.parse(JSON.stringify())获得最快的克隆性能，这让我感到非常惊讶。 如果你想要一个适当的结构化克隆，MessageChannel是你唯一可靠的跨浏览器的选择。 如果浏览器平台直接提供一个 structuredClone()函数，会不会更好？我当然这样认为，最新的 HTML 规范正在讨论这个 Synchronous clone = global.structuredClone(value, transfer = []) API · Issue #793 · whatwg/html。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"HTML5 Canvas属性和方法汇总","slug":"article-h5-canvas","date":"2018-01-16T13:21:15.000Z","updated":"2021-06-24T04:02:41.959Z","comments":true,"path":"2018/01/16/article-h5-canvas/","link":"","permalink":"https://doubleray.top/2018/01/16/article-h5-canvas/","excerpt":"Canvas画布是html5新增标签元素，主要用于通过脚本(通常是javascript)来绘制图像，而canvas元素本身并没有绘制能力(它仅仅是图形的容器)，必须使用脚本来完成实际的绘图任务getContext()方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性详细Canvas API请参考: //demo.luckyw.cn/src/canvas-api/","text":"Canvas画布是html5新增标签元素，主要用于通过脚本(通常是javascript)来绘制图像，而canvas元素本身并没有绘制能力(它仅仅是图形的容器)，必须使用脚本来完成实际的绘图任务getContext()方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性详细Canvas API请参考: //demo.luckyw.cn/src/canvas-api/ 浏览器支持IE9、Firefox、Opera、Chrome以及Safari均支持canvas及其属性和方法。 IE8以及更早的版本不支持canvas元素 颜色、样式和阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 方法 描述 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 线条样式 属性 描述 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 矩形 方法 描述 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 方法 描述 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 方法 描述 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 属性 描述 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 方法 描述 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 图像绘制 方法 描述 drawImage() 向画布上绘制图像、画布或视频 像素操作 属性 描述 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 方法 描述 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 合成 属性 描述 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 其他 方法 描述 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 createEvent() getContext() toDataURL()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://doubleray.top/tags/HTML/"}]},{"title":"高清适配方案中iPhone X全屏兼容","slug":"daily-css-rem-iphone-x","date":"2018-01-02T01:12:15.000Z","updated":"2021-06-24T04:02:41.984Z","comments":true,"path":"2018/01/02/daily-css-rem-iphone-x/","link":"","permalink":"https://doubleray.top/2018/01/02/daily-css-rem-iphone-x/","excerpt":"","text":"需要在viewport中添加 viewport-fit=cover，js 和 meta 标签中都要添加； 同时iPhone X屏幕底部圆弧区域占位高度使用 calc(constant(safe-area-inset-bottom) * 3) 作为padding-bottom， margin-bottom等高度属性的值。iPhone X上，高清适配方案中，此值等价于.34rem，即34逻辑像素。根据实际情况可以修改* 3这个系数来调整占位区域的高度，但一定要使用constant(safe-area-inset-bottom)。在ios11下，非iPhone X的设备此值为0，使用时需要注意样式覆盖的情况。","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"animationend 事件","slug":"article-css-animation-event","date":"2017-12-21T01:12:15.000Z","updated":"2021-06-24T04:02:41.955Z","comments":true,"path":"2017/12/21/article-css-animation-event/","link":"","permalink":"https://doubleray.top/2017/12/21/article-css-animation-event/","excerpt":"","text":"CSS动画事件 CSS 动画播放时，会发生以下三个事件： 123animationstart - CSS 动画开始后触发animationiteration - CSS 动画重复播放时触发animationend - CSS 动画完成后触发 注意标准语法都是小写，兼容大小写驼峰写法 123webkitAnimationStartwebkitAnimationIterationwebkitAnimationEnd 语法12object.addEventListener(\"webkitAnimationEnd\", myScript); // Chrome, Safari 和 Opera object.addEventListener(\"animationend\", myScript); // 标准语法 参考：http://www.runoob.com/jsref/event-animationend.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"webpack 3 入门指南","slug":"article-webpack-3-10-0","date":"2017-12-19T01:15:15.000Z","updated":"2021-06-24T04:02:41.981Z","comments":true,"path":"2017/12/19/article-webpack-3-10-0/","link":"","permalink":"https://doubleray.top/2017/12/19/article-webpack-3-10-0/","excerpt":"年初对webpack学习 webpack 入门指南，虽然基本概念变化不大，但是语法稍有变化。 现在重新学习记录一下令人困惑的地方，顺带搭建一套自用的 cli（正在测试中）。","text":"年初对webpack学习 webpack 入门指南，虽然基本概念变化不大，但是语法稍有变化。 现在重新学习记录一下令人困惑的地方，顺带搭建一套自用的 cli（正在测试中）。 Webpack的核心原理Webpack的两个最核心的原理分别是： 一切皆模块 正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载 传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 好了，下面来看看那些令人困惑的部分吧。 1. 开发模式和生产模式首先要知道的是Webpack有许许多多的特性，一些是”开发模式“下才有的，一些是”生产模式“下才有的，还有一些是两种模式下都有的。 通常使用到Webpack如此多特性的项目都会有两个比较大的Webpack配置文件 为了生成bundles文件你可能在package.json文件加入如下的scripts项： 123456\"scripts\": &#123; // 运行npm run build 来编译生成生产模式下的bundles \"build\": \"webpack --config webpack.config.prod.js\", // 运行npm run dev来生成开发模式下的bundles以及启动本地server \"dev\": \"webpack-dev-server\" &#125; 2. webpack CLI 和webpack-dev-server值得注意的是，Webpack作为模块打包工具，提供两种用户交互接口： Webpack CLI tool：默认的交互方式（已随Webpack本身安装到本地） webpack-dev-server：一个Node.js服务器（需要开发者从npm自行安装） Webpack CLI（有利于生产模式下打包）这种方式可以从命令行获取参数也可以从配置文件（默认叫webpack.config.js）获取，将获取到的参数传入Webpack来打包。 当然你也可以从命令行（CLI）开始学习Webpack，以后你可能主要在生产模式下使用到它。 用法： 12345678910111213141516方式1: // 全局模式安装webpacknpm install webpack --g// 在终端输入$ webpack // &lt;--使用webpack.config.js生成bundle方式 2 :// 费全局模式安装webpack然后添加到package.json依赖里边npm install webpack --save// 添加build命令到package.json的scripts配置项\"scripts\": &#123; \"build\": \"webpack --config webpack.config.prod.js -p\", ... &#125;// 用法：\"npm run build\" webpack-dev-server（有利于在开发模式下编译）这是一个基于Express.js框架开发的web server，默认监听8080端口。server内部调用Webpack，这样做的好处是提供了额外的功能如热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR）。 用法： 1234567891011121314151617方式 1:// 全局安装npm install webpack-dev-server --save// 终端输入$ webpack-dev-server --inline --hot用法 2:// 添加到package.json scripts\"scripts\": &#123; \"start\": \"webpack-dev-server --inline --hot\", ... &#125;// 运行： $ npm start// 浏览器预览：http://localhost:8080 Webpack VS Webpack-dev-server选项注意像inline和hot这些选项是Webpack-dev-server特有的，而另外的如hide-modules则是CLI模式特有的选项。 webpack-dev-server CLI选项和配置项另外值得注意的是你可以通过以下两种方式向webpack-dev-server传入参数： 通过webpack.config.js文件的”devServer”对象 通过CLI选项 1234567// 通过CLI传参webpack-dev-server --hot --inline// 通过webpack.config.js传参devServer: &#123; inline: true, hot:true&#125; 我发现有时devServer配置项（hot: true 和inline: true）不生效，我更偏向使用如下的方式向CLI传递参数： 1234// package.json&#123; \"scripts\": \"webpack-dev-server --hot --inline\"&#125; 注意：确定你没有同时传入hot:true和-hot webpack-dev-server的“hot” 和 “inline”选项“inline”选项会为入口页面添加“热加载”功能，“hot”选项则开启“热替换（Hot Module Reloading）”，即尝试重新加载组件改变的部分（而不是重新加载整个页面）。如果两个参数都传入，当资源改变时，webpack-dev-server将会先尝试HRM（即热替换），如果失败则重新加载整个入口页面。 12345678// 当资源发生改变，以下三种方式都会生成新的bundle，但是又有区别： // 1. 不会刷新浏览器$ webpack-dev-server//2. 刷新浏览器$ webpack-dev-server --inline//3. 重新加载改变的部分，HRM失败则刷新页面$ webpack-dev-server --inline --hot 3. “entry”：值分别是字符串、数组和对象的情况Enter配置项告诉Webpack应用的根模块或起始点在哪里，它的值可以是字符串、数组或对象。这看起来可能令人困惑，因为不同类型的值有着不同的目的。 像绝大多数app一样，倘若你的应用只有一个单一的入口，enter项的值你可以使用任意类型，最终输出的结果都是一样的。 enter：数组类型但是，如果你想添加多个彼此不互相依赖的文件，你可以使用数组格式的值。 例如，你可能在html文件里引用了“googleAnalytics.js”文件，可以告诉Webpack将其加到bundle.js的最后。 enter：对象现在，假设你的应用是多页面的（multi-page application）而不是SPA，有多个html文件（index.html和profile.html）。然后你通过一个对象告诉Webpack为每一个html生成一个bundle文件。 以下的配置将会生成两个js文件：indexEntry.js和profileEntry.js分别会在index.html和profile.html中被引用。 用法： 1234//profile.html&lt;script src=”dist/profileEntry.js”&gt;&lt;/script&gt;//index.html&lt;script src=”dist/indexEntry.js”&gt;&lt;/script&gt; 注意：文件名取自“entry”对象的键名。 enter：混合类型你也可以在enter对象里使用数组类型，例如下面的配置将会生成3个文件：vender.js（包含三个文件），index.js和profile.js文件。 4. output：“path”项和“publicPath”项output项告诉webpack怎样存储输出结果以及存储到哪里。output的两个配置项“path”和“publicPath”可能会造成困惑。 “path”仅仅告诉Webpack结果存储在哪里，然而“publicPath”项则被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。 例如，在localhost（译者注：即本地开发模式）里的css文件中边你可能用“./test.png”这样的url来加载图片，但是在生产模式下“test.png”文件可能会定位到CDN上并且你的Node.js服务器可能是运行在HeroKu上边的。这就意味着在生产环境你必须手动更新所有文件里的url为CDN的路径。 然而你也可以使用Webpack的“publicPath”选项和一些插件来在生产模式下编译输出文件时自动更新这些url。 12345678// 开发环境：Server和图片都是在localhost（域名）下.image &#123; background-image: url('./test.png'); &#125;// 生产环境：Server部署下HeroKu但是图片在CDN上.image &#123; background-image: url('https://someCDN/test.png'); &#125; 5. 模块加载和链式模块加载模块加载器是可自由添加的Node模块，用于将不同类型的文件“load”或“import”并转换成浏览器可以识别的类型，如js、Stylesheet等。更高级的模块加载器甚至可以支持使用ES6里边的“require”或“import”引入模块。 例如，你可以使用babel-loader来将使用ES6语法写成的文件转换成ES5： 123456module: &#123; loaders: [&#123; test: /\\.js$/, // 匹配.js文件，如果通过则使用下面的loader exclude: /node_modules/, // 排除node_modules文件夹 loader: 'babel' // 使用babel（babel-loader的简写）作为loader &#125;] 链式（管道式）的加载器（从右往左执行）多个loader可以用在同一个文件上并且被链式调用。链式调用时从右到左执行且loader之间用“!”来分割。 例如，假设我们有一个名为“myCssFile.css”的css文件，然后我们想将它的内容使用style标签内联到最终输出的html里边。我们可以使用css-loader和style-loader两个loader来达到目的。 123456module: &#123; loaders: [&#123; test: /\\.css$/, loader: 'style!css' //(short for style-loader!css-loader) &#125;] &#125; 这里展示它是如何工作的： Webpack在模块颞部搜索在css的依赖项，即Webpack检查js文件是否有“require(‘myCssFile.css’)”的引用，如果它发现有css的依赖，Webpack将css文件交给“css-loader”去处理 css-loader加载所有的css文件以及css自身的依赖（如，@import 其他css）到JSON对象里，Webpack然后将处理结果传给“style-loader” style-loader接受JSON值然后添加一个style标签并将其内嵌到html文件里 6. loader自身可以配置模块加载器（loader）自身可以根据传入不同的参数进行配置。 在下面的例子中，我们可以配置url-loader来将小于1024字节的图片使用DataUrl替换而大于1024字节的图片使用url，我们可以用如下两种方式通过传入“limit“参数来实现这一目的： 7. .babelrc 文件babal-loader使用”presets“配置项来标识如何将ES6语法转成ES5以及如何转换React的JSX成js文件。我们可以用如下的方式使用”query“参数传入配置： 123456789101112module: &#123; loaders: [ &#123; test: /\\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: &#123; presets: ['react', 'es2015'] &#125; &#125; ]&#125; 然而在很多项目里babel的配置可能比较大，因此你可以把babel-loader的配置项单独保存在一个名为”.babelrc“的文件中，在执行时babel-loader将会自动加载.babelrc文件。 所以在很多例子里，你可能会看到： 123456789101112131415//webpack.config.js module: &#123; loaders: [ &#123; test: /\\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel' &#125; ]&#125;//.bablerc&#123; presets: ['react', 'es2015']&#125; 8. 插件插件一般都是用于输出bundle的node模块。 例如，uglifyJSPlugin获取bundle.js然后压缩和混淆内容以减小文件体积。 类似的extract-text-webpack-plugin内部使用css-loader和style-loader来收集所有的css到一个地方最终将结果提取结果到一个独立的”styles.css“文件，并且在html里边引用style.css文件。 123456789101112//webpack.config.js// 获取所有的.css文件，合并它们的内容然后提取css内容到一个独立的”styles.css“里var ETP = require(\"extract-text-webpack-plugin\");module: &#123; loaders: [ &#123;test: /\\.css$/, loader:ETP.extract(\"style-loader\",\"css-loader\") &#125; ],plugins: [ new ExtractTextPlugin(\"styles.css\") //Extract to styles.css file ]&#125; 注意：如果你只是想把css使用style标签内联到html里，你不必使用extract-text-webpack-plugin，仅仅使用css loader和style loader即可： 12345module: &#123; loaders: [&#123; test: /\\.css$/, loader: 'style!css' // (short for style-loader!css-loader) &#125;] 9. 加载器（loader）和插件你可能已经意识到了，Loader处理单独的文件级别并且通常作用于包生成之前或生成的过程中。 而插件则是处理包（bundle）或者chunk级别，且通常是bundle生成的最后阶段。一些插件如commonschunkplugin甚至更直接修改bundle的生成方式。 10. 处理文件的扩展名很多Webpack的配置文件都有一个resolve属性，然后就像下面代码所示有一个空字符串的值。空字符串在此是为了resolve一些在import文件时不带文件扩展名的表达式，如require(&#39;./myJSFile&#39;)或者import myJSFile from &#39;./myJSFile&#39;（译者注：实际就是自动添加后缀，默认是当成js文件来查找路径） 12345&#123; resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;&#125;","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"webpack","slug":"webpack","permalink":"https://doubleray.top/tags/webpack/"}]},{"title":"使用 Flex 实现 5 种常用布局","slug":"article-css-flex-layout","date":"2017-12-14T01:12:15.000Z","updated":"2021-06-24T04:02:41.956Z","comments":true,"path":"2017/12/14/article-css-flex-layout/","link":"","permalink":"https://doubleray.top/2017/12/14/article-css-flex-layout/","excerpt":"flex 实现 5 种常用布局，学习一下! 参考：https://github.com/meikidd/flex-layout","text":"flex 实现 5 种常用布局，学习一下! 参考：https://github.com/meikidd/flex-layout Sticky Footer经典的上-中-下布局。 当页面内容高度小于可视区域高度时，footer 吸附在底部；当页面内容高度大于可视区域高度时，footer 被撑开排在 content 下方 12345&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 12345678body &#123; min-height: 100vh; display: flex; flex-direction: column;&#125;article &#123; flex: auto;&#125; Fixed-Width Sidebar在上-中-下布局的基础上，加了左侧定宽 sidebar。 12345678&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;div class=\"content\"&gt; &lt;aside&gt;ASIDE&lt;/aside&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;/div&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 123456789101112body &#123; min-height: 100vh; display: flex; flex-direction: column;&#125;.content &#123; flex: auto; display: flex;&#125;.content article &#123; flex: auto;&#125; Sidebar左边是定宽 sidebar，右边是上-中-下布局。 12345678&lt;body&gt; &lt;aside&gt;ASIDE&lt;/aside&gt; &lt;div class=\"content\"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415body &#123; min-height: 100vh; display: flex;&#125;aside &#123; flex: none;&#125;.content &#123; flex: auto; display: flex; flex-direction: column;&#125;.content article &#123; flex: auto;&#125; Sticky Header还是上-中-下布局，区别是 header 固定在顶部，不会随着页面滚动。 12345&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 123456789101112131415161718body &#123; min-height: 100vh; display: flex; flex-direction: column; padding-top: 60px;&#125;header &#123; height: 60px; position: fixed; top: 0; left: 0; right: 0; padding: 0;&#125;article &#123; flex: auto; height: 1000px;&#125; Sticky Sidebar左侧 sidebar 固定在左侧且与视窗同高，当内容超出视窗高度时，在 sidebar 内部出现滚动条。左右两侧滚动条互相独立。 1234567891011121314&lt;body&gt; &lt;aside&gt; ASIDE &lt;p&gt;item&lt;/p&gt; &lt;p&gt;item&lt;/p&gt; &lt;!-- many items --&gt; &lt;p&gt;item&lt;/p&gt; &lt;/aside&gt; &lt;div class=\"content\"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819body &#123; height: 100vh; display: flex;&#125;aside &#123; flex: none; width: 200px; overflow-y: auto; display: block;&#125;.content &#123; flex: auto; display: flex; flex-direction: column; overflow-y: auto;&#125;.content article &#123; flex: auto;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"https://doubleray.top/tags/Flex/"}]},{"title":"css-alt","slug":"daily-css-alt","date":"2017-11-14T06:41:15.000Z","updated":"2021-06-24T04:02:41.983Z","comments":true,"path":"2017/11/14/daily-css-alt/","link":"","permalink":"https://doubleray.top/2017/11/14/daily-css-alt/","excerpt":"","text":"为了增强可访问性，让自己不忘给图片标签加上 alt 属性，有人在项目中加入了如下的全局 CSS 样式，值得学习 123img[alt=\"\"],img:not([alt])&#123; border: 2px solid #c00;&#125;","categories":[{"name":"知识点","slug":"知识点","permalink":"https://doubleray.top/categories/知识点/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"JavaScript Promise启示录","slug":"article-js-promise","date":"2017-11-06T01:12:15.000Z","updated":"2021-06-24T04:02:41.969Z","comments":true,"path":"2017/11/06/article-js-promise/","link":"","permalink":"https://doubleray.top/2017/11/06/article-js-promise/","excerpt":"本篇，主要普及promise的用法。 一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。","text":"本篇，主要普及promise的用法。 一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样： 1234567loadImg('a.jpg', function() &#123; loadImg('b.jpg', function() &#123; loadImg('c.jpg', function() &#123; console.log('all done!'); &#125;); &#125;);&#125;); 这也就是我们常说的回调金字塔，当异步的任务很多的时候，维护大量的callback将是一场灾难。当今Node.js大热，好像很多团队都要用它来做点东西以沾沾“洋气”，曾经跟一个运维的同学聊天，他们也是打算使用Node.js做一些事情，可是一想到js的层层回调就望而却步。 好，扯淡完毕，下面进入正题。 Promise可能大家都不陌生，因为Promise规范已经出来好一段时间了，同时Promise也已经纳入了ES6，而且高版本的chrome、firefox浏览器都已经原生实现了Promise，只不过和现如今流行的类Promise类库相比少些API。 所谓Promise，字面上可以理解为“承诺”，就是说A调用B，B返回一个“承诺”给A，然后A就可以在写计划的时候这么写：当B返回结果给我的时候，A执行方案S1，反之如果B因为什么原因没有给到A想要的结果，那么A执行应急方案S2，这样一来，所有的潜在风险都在A的可控范围之内了。 上面这句话，翻译成代码类似： 12345var resB = B();var runA = function() &#123; resB.then(execS1, execS2);&#125;;runA(); 只看上面这行代码，好像看不出什么特别之处。但现实情况可能比这个复杂许多，A要完成一件事，可能要依赖不止B一个人的响应，可能需要同时向多个人询问，当收到所有的应答之后再执行下一步的方案。最终翻译成代码可能像这样： 1234567891011121314var resB = B();var resC = C();...var runA = function() &#123; reqB .then(resC, execS2) .then(resD, execS3) .then(resE, execS4) ... .then(execS1);&#125;;runA(); 在这里，当每一个被询问者做出不符合预期的应答时都用了不同的处理机制。事实上，Promise规范没有要求这样做，你甚至可以不做任何的处理（即不传入then的第二个参数）或者统一处理。 好了，下面我们来认识下Promise/A+规范： 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 可以看到，Promise规范的内容并不算多，大家可以试着自己实现以下Promise。 以下是笔者自己在参考许多类Promise库之后简单实现的一个Promise，代码请移步promiseA。 简单分析下思路： 构造函数Promise接受一个函数resolver，可以理解为传入一个异步任务，resolver接受两个参数，一个是成功时的回调，一个是失败时的回调，这两参数和通过then传入的参数是对等的。 其次是then的实现，由于Promise要求then必须返回一个promise，所以在then调用的时候会新生成一个promise，挂在当前promise的_next上，同一个promise多次调用都只会返回之前生成的_next。 由于then方法接受的两个参数都是可选的，而且类型也没限制，可以是函数，也可以是一个具体的值，还可以是另一个promise。下面是then的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839Promise.prototype.then = function(resolve, reject) &#123; var next = this._next || (this._next = Promise()); var status = this.status; var x; if('pending' === status) &#123; isFn(resolve) &amp;&amp; this._resolves.push(resolve); isFn(reject) &amp;&amp; this._rejects.push(reject); return next; &#125; if('resolved' === status) &#123; if(!isFn(resolve)) &#123; next.resolve(resolve); &#125; else &#123; try &#123; x = resolve(this.value); resolveX(next, x); &#125; catch(e) &#123; this.reject(e); &#125; &#125; return next; &#125; if('rejected' === status) &#123; if(!isFn(reject)) &#123; next.reject(reject); &#125; else &#123; try &#123; x = reject(this.reason); resolveX(next, x); &#125; catch(e) &#123; this.reject(e); &#125; &#125; return next; &#125;&#125;; 这里，then做了简化，其他promise类库的实现比这个要复杂得多，同时功能也更多，比如还有第三个参数——notify，表示promise当前的进度，这在设计文件上传等时很有用。对then的各种参数的处理是最复杂的部分，有兴趣的同学可以参看其他类Promise库的实现。 在then的基础上，应该还需要至少两个方法，分别是完成promise的状态从pending到resolved或rejected的转换，同时执行相应的回调队列，即resolve()和reject()方法。 到此，一个简单的promise就设计完成了，下面简单实现下两个promise化的函数： 12345678910111213141516171819202122232425262728function sleep(ms) &#123; return function(v) &#123; var p = Promise(); setTimeout(function() &#123; p.resolve(v); &#125;, ms); return p; &#125;;&#125;;function getImg(url) &#123; var p = Promise(); var img = new Image(); img.onload = function() &#123; p.resolve(this); &#125;; img.onerror = function(err) &#123; p.reject(err); &#125;; img.url = url; return p;&#125;; 由于Promise构造函数接受一个异步任务作为参数，所以getImg还可以这样调用： 123456789101112131415function getImg(url) &#123; return Promise(function(resolve, reject) &#123; var img = new Image(); img.onload = function() &#123; resolve(this); &#125;; img.onerror = function(err) &#123; reject(err); &#125;; img.url = url; &#125;);&#125;; 接下来（见证奇迹的时刻），假设有一个BT的需求要这么实现：异步获取一个json配置，解析json数据拿到里边的图片，然后按顺序队列加载图片，没张图片加载时给个loading效果 123456789101112131415161718192021222324252627282930313233function addImg(img) &#123; $('#list').find('&gt; li:last-child').html('').append(img);&#125;;function prepend() &#123; $('&lt;li&gt;') .html('loading...') .appendTo($('#list'));&#125;;function run() &#123; $('#done').hide(); getData('map.json') .then(function(data) &#123; $('h4').html(data.name); return data.list.reduce(function(promise, item) &#123; return promise .then(prepend) .then(sleep(1000)) .then(function() &#123; return getImg(item.url); &#125;) .then(addImg); &#125;, Promise.resolve()); &#125;) .then(sleep(300)) .then(function() &#123; $('#done').show(); &#125;);&#125;;$('#run').on('click', run); 这里的sleep只是为了看效果加的，可猛击查看demo！当然，Node.js的例子可查看这里。 在这里，Promise.resolve(v)静态方法只是简单返回一个以v为肯定结果的promise，v可不传入，也可以是一个函数或者是一个包含then方法的对象或函数（即thenable）。 类似的静态方法还有Promise.cast(promise)，生成一个以promise为肯定结果的promise； Promise.reject(reason)，生成一个以reason为否定结果的promise。 我们实际的使用场景可能很复杂，往往需要多个异步的任务穿插执行，并行或者串行同在。这时候，可以对Promise进行各种扩展，比如实现Promise.all()，接受promises队列并等待他们完成再继续，再比如Promise.any()，promises队列中有任何一个处于完成态时即触发下一步操作。 标准的Promise可参考html5rocks的这篇文章JavaScript Promises，目前高级浏览器如chrome、firefox都已经内置了Promise对象，提供更多的操作接口，比如Promise.all()，支持传入一个promises数组，当所有promises都完成时执行then，还有就是更加友好强大的异常捕获，应对日常的异步编程，应该足够了。 第三方库的Promise现今流行的各大js库，几乎都不同程度的实现了Promise，如dojo，jQuery、Zepto、when.js、Q等，只是暴露出来的大都是Deferred对象，以jQuery（Zepto类似）为例，实现上面的getImg()： 12345678910111213141516function getImg(url) &#123; var def = $.Deferred(); var img = new Image(); img.onload = function() &#123; def.resolve(this); &#125;; img.onerror = function(err) &#123; def.reject(err); &#125;; img.src = url; return def.promise();&#125;; 当然，jQuery中，很多的操作都返回的是Deferred或promise，如animate、ajax： 12345678910111213141516171819// animate$('.box') .animate(&#123;'opacity': 0&#125;, 1000) .promise() .then(function() &#123; console.log('done'); &#125;);// ajax$.ajax(options).then(success, fail);$.ajax(options).done(success).fail(fail);// ajax queue$.when($.ajax(options1), $.ajax(options2)) .then(function() &#123; console.log('all done.'); &#125;, function() &#123; console.error('There something wrong.'); &#125;); jQuery还实现了done()和fail()方法，其实都是then方法的shortcut。 处理promises队列，jQuery实现的是$.when()方法，用法和Promise.all()类似。 其他类库，这里值得一提的是when.js，本身代码不多，完整实现Promise，同时支持browser和Node.js，而且提供更加丰富的API，是个不错的选择。这里限于篇幅，不再展开。 尾声我们看到，不管Promise实现怎么复杂，但是它的用法却很简单，组织的代码很清晰，从此不用再受callback的折磨了。 最后，Promise是如此的优雅！但Promise也只是解决了回调的深层嵌套的问题，真正简化JavaScript异步编程的还是Generator，在Node.js端，建议考虑Generator。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"CSS 五种方式实现 Footer 置底","slug":"article-css-footer","date":"2017-10-04T06:41:15.000Z","updated":"2021-06-24T04:02:41.957Z","comments":true,"path":"2017/10/04/article-css-footer/","link":"","permalink":"https://doubleray.top/2017/10/04/article-css-footer/","excerpt":"页脚置底（Sticky footer）就是让网页的footer部分始终在浏览器窗口的底部。 当网页内容足够长以至超出浏览器可视高度时，页脚会随着内容被推到网页底部；但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。 原文链接 http://t.cn/RJ3nmhV","text":"页脚置底（Sticky footer）就是让网页的footer部分始终在浏览器窗口的底部。 当网页内容足够长以至超出浏览器可视高度时，页脚会随着内容被推到网页底部；但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。 原文链接 http://t.cn/RJ3nmhV 1. 将内容部分的底部外边距设为负数这是个比较主流的用法，把内容部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。 123456789&lt;body&gt; &lt;div class=\"wrapper\"&gt; content &lt;div class=\"push\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011121314html, body &#123; height: 100%; margin: 0;&#125;.wrapper &#123; min-height: 100%; /* 等于footer的高度 */ margin-bottom: -50px;&#125;.footer,.push &#123; height: 50px;&#125; 需要注意的是.wrapper的margin-bottom值需要和.footer的负的height值保持一致，这一点不太友好。 2. 将页脚的顶部外边距设为负数 既然能在容器上使用负的margin bottom，那能否使用负margin top吗？当然可以。 给内容外增加父元素，并让内容部分的底部内边距与页脚高度的值相等。 12345678&lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"content-inside\"&gt; content &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456789101112131415html, body &#123; height: 100%; margin: 0;&#125;.content &#123; min-height: 100%;&#125;.content-inside &#123; padding: 20px; padding-bottom: 50px;&#125;.footer &#123; height: 50px; margin-top: -50px;&#125; 不过这种方法和上一种一样，都需要额外添加不必要的html元素。 3. 使用calc()设置内容高度有一种方法不需要任何多余元素——使用CSS3新增的计算函数calc() 这样元素间就不会有重叠发生，也不需要控制内外边距了～ 123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456.content &#123; min-height: calc(100vh - 70px);&#125;.footer &#123; height: 50px;&#125; 可能你会疑惑内容高度calc()中为什么减去70px，而不是footer的高度50px，因为假设俩元素有20px的间距，所以70px=50px+20px 不过，你不必在意这些~ 4. 使用flexbox弹性盒布局以上三种方法的footer高度都是固定的，通常来说这不利于网页布局：内容会改变，它们都是弹性的，一旦内容超出固定高度就会破坏布局。所以给footer使用flexbox吧，让它的高度可以变大变小变漂亮~ 123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: flex; flex-direction: column;&#125;.content &#123; flex: 1;&#125; 你还可以在上面添加header或在下面添加更多元素。可从以下技巧选择其一： flex:1使内容（如：.content）高度可以自动伸缩 margin-top: auto 可参考Flex布局新旧混合写法详解 5. 使用Grid网格布局grid比flexbox还要新很多，并且更佳很简洁，可参考CSS：Grid布局 123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456789101112html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: grid; grid-template-rows: 1fr auto;&#125;.footer &#123; grid-row-start: 2; grid-row-end: 3;&#125; 遗憾的是，网格布局（Grid layout）目前仅支持Chrome Canary和Firefox Developer Edition版本。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"微信公众号文章编辑","slug":"article-wechat-edit","date":"2017-08-08T04:19:15.000Z","updated":"2021-06-24T04:02:41.982Z","comments":true,"path":"2017/08/08/article-wechat-edit/","link":"","permalink":"https://doubleray.top/2017/08/08/article-wechat-edit/","excerpt":"微信公众号发布内容过程小白教程，大神请无视！","text":"微信公众号发布内容过程小白教程，大神请无视！ 注册微信订阅号 注册地址：https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&amp;lang=zh_CN 根据需求，个人用户最好的是选择第一个 订阅号 ；然后根据提示一步步的填写注册需要的信息，注意选择类型这块选择 订阅号 ，选择之后是不可更改的。 信息登记的主题类型选择 个人； 选择个人后继续填写相关的登记信息，有一步是需要身份验证的，验证用的微信号将会是你以后登录管理该公众号的公众号管理员。 最后一步，填写公众号信息，包括公众号的名称和介绍。 信息提交成功后，前往 https://mp.weixin.qq.com/cgi-bin/home 进行公众号编辑 公众号基础设置 一图胜千言 文章编辑 在素材管理中心新建图文素材，所谓的图文素材就是你将来要发布在公众号中文章可以用到的已经写好的内容。 在首页中选择新建群发后 这里新建的文章只能进行简单的排版，写出效果平平的文章，若要写出排版比较优雅的文章，网上有好多工具。 这里我罗列一些常用的编辑器（功能都是大同小异） 135http://www.135editor.com/ i排版https://ipaiban.com/ 易点http://www.wxeditor.com/ 秀米https://xiumi.us/ 小蚂蚁http://www.xmyeditor.com/ 非找你http://editor.fzn.cc/ 96http://bj.96weixin.com/ 可参考 这里","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://doubleray.top/tags/Web/"},{"name":"WeChat","slug":"WeChat","permalink":"https://doubleray.top/tags/WeChat/"}]},{"title":"掌握Chrome开发工具","slug":"article-chrome-tools","date":"2017-07-31T05:13:05.000Z","updated":"2021-06-24T04:02:41.954Z","comments":true,"path":"2017/07/31/article-chrome-tools/","link":"","permalink":"https://doubleray.top/2017/07/31/article-chrome-tools/","excerpt":"你可能已经熟悉了Chrome开发工具的基本功能。: DOM检查器、样式面板和JavaScript控制台。 但也有一些不太为人所知的特性可以显著提高你调试或开发应用的速度。","text":"你可能已经熟悉了Chrome开发工具的基本功能。: DOM检查器、样式面板和JavaScript控制台。 但也有一些不太为人所知的特性可以显著提高你调试或开发应用的速度。 黑色主题 Chrome开发工具的内置了黑色主题。你可以通过点击开发工具窗口右上角的三点图标，之后点击进入设置页面，切换主题。 有时候我觉得黑色主题让我的眼睛更舒服,并且黑色主题显然看起来更酷一些！ 选择模式 Chrome开发者工具提供了很多选择元素的方法，其中最快捷的方法就是使用选择模式。 该功能通过点击调试面板左上角的按钮开启(或者通过组合键 ctrl + shift + c), 该模式下你只需单击页面上的元素就可以选中它。 一旦开启该模式，你可以将鼠标移动到页面来预览选定内容，然后单击来选择要检查的元素。 通过ctrl + shitf + c键，你可以直接打开调试工具并开启调试模式，来在页面上快速选择一个元素。 存储为全局变量 有时在控制台中查看一个复杂对象是一件很麻烦的事，因为他们可能有很多的键值或者一些很难手动解析的值。幸运的是，Chrome可以让检查这类JavaScript对象变得很容易。 你只需在控制台中右键点击对象后选择“存储为全局变量”，chrome就会将这个变量存储为一个名叫“temp1”的变量，之后你可以通过Javascript对其进行操作。 动画工具 最近，Chrome团队为调试和创建动画添加了一些新特性。 单击控制台左上角的下拉框中的“动画”开启动画调试工具，你可以通过它限制站点上所有动画的速度。 你也可以暂停所有动画。这对于一个充斥着动画内容的站点尤其有用。 动画查看器允许你单独控制每个属性的时间曲线！ 通过点击一个元素 transition 属性中的紫色曲线图表按钮，你可以看到动画的移动曲线，并且微调他的属性。此外，你还可以使用一些预置的时间曲线来应用到你的元素上。 模拟元素伪态 通过点击样式窗口右上角的:hover 图标，你可以打开元素状态模拟工具。 该工具可以让你模拟一个元素的hover,active,focused和visited伪态，并且看到不同伪态的相关样式与选择符。 如果要为这些伪态添加样式，可以添加一个新的选择器（使用“+”图标），并将:添加到选择器的结尾。 例如，如果我想要给一个logo类的li标签添加hover伪态样式，我需要构造一个新的伪类li.logo:hover，并且给他添加相关属性。 之后可以通过模拟hover状态来检查你的样式是否正确。 美化CSS和JavaScript 调试、浏览压缩后的JavaScript和CSS是一件非常困难的事情，好在调试工具让这件事情变得容易了一些。 在“Source”的标签栏打开了一个压缩的文档后，你可以点击左下角的花括号logo，之后调试工具就会将代码进行格式化处理。 尽管在压缩过程中丢失了一些信息（例如变量名）,该工具对调试CSS和JavaScript文件还是很有用的。 Alt + Up / Alt + Down 在调试CSS时，你可以选择一个属性然后使用上下箭头来调整它的值。默认情况下，上下箭头会将值加减1。但如果你按住了alt键，再通过上下箭头调整值时候，每次增减的值就会变成0.1，这在处理一些浮点类型的数值属性时非常有用。 相反的，你可以按住shift键一次将数值加减10; 保存日志 保存日志是一个复选框，它允许在页面刷新后仍然保存日志。这在调试需要刷新页面的网站问题时非常有用，因为默认情况下，所有控制台输出的信息在页面刷新后都会被清除。 启用此选项后，控制台中会出现一个新的“导航”日志，它指向了刷新或是导航到的页面。 网络 + 日志过滤 当调试具有大量网络请求或控制台日志的应用程序时，过滤特定类型的事件是很有用的。 Chrome有一种支持多种属性的过滤语言，以及类似于*的通配符。 如果你输入了“-”，Chrome会出现一个包含了可选过滤选项的提示框。你也可以打开“正则模式”来对每一行的数据进行正则匹配。 代码覆盖率 代码覆盖率可以在运行Web应用程序后针对每个JavaScript和CSS文件，查看哪些代码行运行了，哪些代码没有运行。这是很有用的，因为在处理复杂或长期项目时，很容易在项目中累积无用的代码。 如果想要使用这个功能的话，首先升级Chrome到59或更高版本，之后切换到“Coverage”页面。点击“record”，之后开始使用你的Web应用。当你使用结束后，Chrome将向你显示操作期间运行的具体代码。 调试用户遇到的问题通常来说调试工具只有在你自己的机器上才会生效。但如果你有兴趣了解用户在使用过程中遇到的的bug和性能问题，不妨尝试一下 LogRocket。 LogRocket 是一个前端日志记录工具，它可以让你重放问题，就像它们发生在你自己的浏览器中一样。 不是通过猜测错误发生的原因，或要求用户提供截图或者错误日志，logrocket可以让你通过重放快速了解到问题出在哪里。它的兼容性很好，无论在任何框架下都可以使用，并且LogRocket对于React、Angular、和Vue的提供了额外的日志插件。 LogRocket 会记录你应用程序中的日志信息、带有header和body的网络请求、浏览器的元数据、Redux的行为与状态、以及应用进行时间与性能。并且他还能记录页面的HTML和CSS样式，完美的还原页面。 LogRocket | JavaScript应用的日志记录和会话回放 _LogRocket帮助你理解那些影响用户的问题, 这样你就可以重新构建更好的的软件。 本文转载自：众成翻译 译者：一只叫做兰胖的食人魔魔法师 链接：http://www.zcfy.cc/article/3722 原文：https://medium.freecodecamp.com/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3ac0b6fe8a3","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://doubleray.top/tags/Debug/"}]},{"title":"gulp 常用插件的功能和用法","slug":"article-gulp-normal","date":"2017-06-30T04:13:05.000Z","updated":"2021-06-24T04:02:41.959Z","comments":true,"path":"2017/06/30/article-gulp-normal/","link":"","permalink":"https://doubleray.top/2017/06/30/article-gulp-normal/","excerpt":"gulp的官方定义非常简洁： 基于文件流的构建系统 。通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。","text":"gulp的官方定义非常简洁： 基于文件流的构建系统 。通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 匹配符 、*、！、{}1234gulp.src('./js/*.js') // * 匹配js文件夹下所有.js格式的文件gulp.src('./js/**/*.js') // ** 匹配js文件夹的0个或多个子文件夹gulp.src(['./js/*.js','!./js/index.js']) // ! 匹配除了index.js之外的所有js文件gulp.src('./js/**/&#123;omui,common&#125;.js') // &#123;&#125; 匹配&#123;&#125;里的文件名 文件操作del (替代gulp-clean)123var del = require('del');del('./dist'); // 删除整个dist文件夹 gulp-rename描述：重命名文件。 1234567891011121314var rename = require(\"gulp-rename\");gulp.src('./hello.txt') .pipe(rename('gb/goodbye.md')) // 直接修改文件名和路径 .pipe(gulp.dest('./dist'));gulp.src('./hello.txt') .pipe(rename(&#123; dirname: \"text\", // 路径名 basename: \"goodbye\", // 主文件名 prefix: \"pre-\", // 前缀 suffix: \"-min\", // 后缀 extname: \".html\" // 扩展名 &#125;)) .pipe(gulp.dest('./dist')); gulp-concat描述：合并文件。 12345678var concat = require('gulp-concat');gulp.src('./js/*.js') .pipe(concat('all.js')) // 合并all.js文件 .pipe(gulp.dest('./dist'));gulp.src(['./js/demo1.js','./js/demo2.js','./js/demo2.js']) .pipe(concat('all.js')) // 按照[]里的顺序合并文件 .pipe(gulp.dest('./dist')); gulp-filter描述：在虚拟文件流中过滤文件。 123456789101112var filter = require('gulp-filter');const f = filter(['**', '!*/index.js']);gulp.src('js/**/*.js') .pipe(f) // 过滤掉index.js这个文件 .pipe(gulp.dest('dist'));const f1 = filter(['**', '!*/index.js'], &#123;restore: true&#125;);gulp.src('js/**/*.js') .pipe(f1) // 过滤掉index.js这个文件 .pipe(uglify()) // 对其他文件进行压缩 .pipe(f1.restore) // 返回到未过滤执行的所有文件 .pipe(gulp.dest('dist')); // 再对所有文件操作，包括index.js 压缩gulp-uglify描述：压缩js文件大小。 12345678910111213var uglify = require(\"gulp-uglify\");gulp.src('./hello.js') .pipe(uglify()) // 直接压缩hello.js .pipe(gulp.dest('./dist')) gulp.src('./hello.js') .pipe(uglify(&#123; mangle: true, // 是否修改变量名，默认为 true compress: true, // 是否完全压缩，默认为 true preserveComments: 'all' // 保留所有注释 &#125;)) .pipe(gulp.dest('./dist')) gulp-csso描述：压缩优化css。 1234var csso = require('gulp-csso');gulp.src('./css/*.css') .pipe(csso()) .pipe(gulp.dest('./dist/css')) gulp-html-minify描述：压缩HTML。 1234var htmlminify = require('gulp-html-minify');gulp.src('index.html') .pipe(htmlminify()) .pipe(gulp.dest('./dist')) gulp-imagemin描述：压缩图片。 12345var imagemin = require('gulp-imagemin');gulp.src('./img/*.&#123;jpg,png,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('./dist/img')) gulp-zip描述：ZIP压缩文件。 12345var zip = require('gulp-zip');gulp.src('./src/*') .pipe(zip('all.zip')) // 压缩成all.zip文件 .pipe(gulp.dest('./dist')) JS/CSS自动注入gulp-autoprefixer描述：自动为css添加浏览器前缀。 1234567891011121314var autoprefixer = require('gulp-autoprefixer');gulp.src('./css/*.css') .pipe(autoprefixer()) // 直接添加前缀 .pipe(gulp.dest('dist'))gulp.src('./css/*.css') .pipe(autoprefixer(&#123; browsers: ['last 2 versions'], // 浏览器版本 cascade：true // 美化属性，默认true add: true // 是否添加前缀，默认true remove: true // 删除过时前缀，默认true flexbox: true // 为flexbox属性添加前缀，默认true &#125;)) .pipe(gulp.dest('./dist')) 查看更多配置：options 更多浏览器版本：browsers gulp-useref描述：解析构建块在HTML文件来代替引用未经优化的脚本和样式表。 12345678910// index.html&lt;!-- build:css /css/all.css --&gt;&lt;link rel=\"stylesheet\" href=\"css/normalize.css\"&gt;&lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;!-- endbuild --&gt;// gulpfile.jsvar useref = require('gulp-useref');gulp.src('index.html') .pipe(useref()) .pipe(gulp.dest('./dist')) 替换之后的index.html中就会变成： 1&lt;link rel=\"stylesheet\" href=\"css/all.css\"&gt; // 之前的两个&lt;link&gt;替换成一个了 gulp-rev描述：给静态资源文件名添加hash值:unicorn.css =&gt; unicorn-d41d8cd98f.css 12345var rev = require('gulp-rev');gulp.src('./css/*.css') .pipe(rev()) .pipe(gulp.dest('./dist/css')) gulp-rev-replace描述：重写被gulp-rev重命名的文件名。 12345678var rev = require('gulp-rev');var revReplace = require('gulp-rev-replace');var useref = require('gulp-useref');gulp.src('index.html') .pipe(useref()) // 替换HTML中引用的css和js .pipe(rev()) // 给css,js,html加上hash版本号 .pipe(revReplace()) // 把引用的css和js替换成有版本号的名字 .pipe(gulp.dest('./dist')) gulp-html-replace描述：替换html中的构建块。 123456789101112131415// index.html&lt;!-- build:css --&gt; // css是buildName,可以自己定义&lt;link rel=\"stylesheet\" href=\"css/normalize.css\"&gt;&lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;!-- endbuild --&gt;// gulpfile.jsvar htmlreplace = require('gulp-html-replace');gulp.src('index.html') .pipe(htmlreplace(&#123; 'css':'all.css' // css是index.html中定义的buildName &#125;)) .pipe(gulp.dest('./dist'))替换之后的index.html中就会变成：&lt;link rel=\"stylesheet\" href=\"all.css\"&gt; // 之前的两个&lt;link&gt;替换成一个了 工具gulp-load-plugins描述：从包的依赖和附件里加载gulp插件到一个对象里给你选择。 1234567891011121314// package.json\"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-concat\": \"^2.6.1\", \"gulp-rename\": \"^1.2.2\", \"gulp-uglify\": \"^2.0.1\"&#125;// gulpfile.jsvar $ = require('gulp-load-plugins')(); // $ 是一个对象,加载了依赖里的插件gulp.src('./**/*.js') .pipe($.concat('all.js')) // 使用插件就可以用$.PluginsName() .pipe($.uglify()) .pipe($.rename('all.min.js')) .pipe(gulp.dest('./dist')) gulp-sass描述：编译sass。 12345678var sass = require('gulp-sass');gulp.src('./sass/**/*.scss') .pipe(sass(&#123; outputStyle: 'compressed' // 配置输出方式,默认为nested &#125;)) .pipe(gulp.dest('./dist/css'));gulp.watch('./sass/**/*.scss', ['sass']); // 实时监听sass文件变动,执行sass任务 gulp-babel描述：将ES6代码编译成ES5。 1234567var babel = require('gulp-babel');gulp.src('./js/index.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(gulp.dest('./dist'))","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://doubleray.top/tags/gulp/"}]},{"title":"5种你未必知道的JavaScript和CSS交互的方法","slug":"article-ways-css-javascript","date":"2017-06-24T05:13:05.000Z","updated":"2021-06-24T04:02:41.980Z","comments":true,"path":"2017/06/24/article-ways-css-javascript/","link":"","permalink":"https://doubleray.top/2017/06/24/article-ways-css-javascript/","excerpt":"随着浏览器不断的升级改进，CSS和JavaScript之间的界限越来越模糊。本来它们是负责着完全不同的功能，但最终，它们都属于网页前端技术，它们需要相互密切的合作。我们的网页中都有.js文件和.css文件，但这并不意味着CSS和js是独立不能交互的。下面要讲的这五种JavaScript和CSS共同合作的方法你也许未必知道！","text":"随着浏览器不断的升级改进，CSS和JavaScript之间的界限越来越模糊。本来它们是负责着完全不同的功能，但最终，它们都属于网页前端技术，它们需要相互密切的合作。我们的网页中都有.js文件和.css文件，但这并不意味着CSS和js是独立不能交互的。下面要讲的这五种JavaScript和CSS共同合作的方法你也许未必知道！ 用JavaScript获取伪元素(pseudo-element)属性大家都知道如何通过一个元素的style属性获取它的CSS样式值，但能获取伪元素(pseudo-element)的属性值吗？可以的，使用JavaScript也可以访问页面中的伪元素。 123456789// Get the color value of .element:beforevar color = window.getComputedStyle( document.querySelector('.element'), ':before').getPropertyValue('color');// Get the content value of .element:beforevar content = window.getComputedStyle( document.querySelector('.element'), ':before').getPropertyValue('content'); 看见了吗，我能访问伪元素里的content属性值。如果你想创建一个动态的，风格别致的网站，这是一种非常有用的技术！ classList API很多的JavaScript工具库里都有addClass，removeClass和toggleClass等方法。为了对老式浏览器的兼容，这些类库采用的方法都是先搜索元素的className，追加和删除这个类，然后更新className。其实有一个新型的API提供了添加，删除和反转CSS类属性的方法，叫做classList： 12345myDiv.classList.add('myCssClass'); // Adds a classmyDiv.classList.remove('myCssClass'); // Removes a classmyDiv.classList.toggle('myCssClass'); // Toggles a class 大多数的浏览器里很早就实现了classListAPI，而且最终 IE10 里也实现了它。 直接对样式表进行添加和删除样式规则我们都非常熟悉使用element.style.propertyName来修改样式，使用JavaScript能帮助我们做到这些，但你知道如何新增或修一个现有的CSS样式规则吗？其实非常的简单。 1234567891011function addCSSRule(sheet, selector, rules, index) &#123; if(sheet.insertRule) &#123; sheet.insertRule(selector + \"&#123;\" + rules + \"&#125;\", index); &#125; else &#123; sheet.addRule(selector, rules, index); &#125;&#125;// Use it!addCSSRule(document.styleSheets[0], \"header\", \"float: left\"); 这种方法通常是用来创建一个新的样式规则，但如果你想修改一个现有的规则，也可以这样做。 加载CSS文件延迟加载图片、JSON、脚本等是用来加快页面显示速度的好方法。我们可以使用curl.js等这样JavaScript加载器来延迟加载这些外部资源，可你知道CSS样式表也可以延迟加载吗，而且在加载成功后回调函数会给予通知。 12345678910curl( [ \"namespace/MyWidget\", \"css!namespace/resources/MyWidget.css\" ], function(MyWidget) &#123; // 你可以对MyWidget进行操作 // 这里没有对这个CSS文件引用，因为不需要; // 我们只需要它已经加载到页面上了 &#125;); 原文站点 使用的PrismJS语法高亮脚本就是延迟加载的。当所有的资源都加载后，回调函数就会触发，可在回调函数里加载它。据说非常有用（还未尝试）！ CSS鼠标指针事件CSS鼠标指针事件pointer-events属性非常的有趣，它的功效非常像JavaScript，当你把这个属性设置为none时，它能有效的阻止禁止这个元素，你也许会说“这又如何？”，但事实上，它是禁止了这个元素上的任何JavaScript事件或回调函数！ 1.disabled &#123; pointer-events: none; &#125; 点击这个元素，你会发现任何你放置在这个元素上的监听器都不会触发任何事件。一个神奇的功能，真的——你不在需要为了防止某个事件会被触发而去检查某个css类是否存在。 原文5 Ways that CSS and JavaScript Interact That You May Not Know About.","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"5个数组的高效方法","slug":"article-s-array","date":"2017-05-21T05:13:05.000Z","updated":"2021-06-24T04:02:41.979Z","comments":true,"path":"2017/05/21/article-s-array/","link":"","permalink":"https://doubleray.top/2017/05/21/article-s-array/","excerpt":"今天学习到了JavaScript里关于数组的比较高效的5个原生方法，这5个方法可以说是每个想要高效的进行JavaScript编程的程序员必须知道的。","text":"今天学习到了JavaScript里关于数组的比较高效的5个原生方法，这5个方法可以说是每个想要高效的进行JavaScript编程的程序员必须知道的。 Array.forEach().forEach() 方法能够方便的让你 遍历数组里的每个元素，你可以在回调函数里对每个元素进行操作。.forEach()方法没有返回值，你不需要在回调函数里写return，这是无意义的。 12345var animals = ['dog', 'cat', 'mouse'];animals.forEach(function(item)&#123; console.log(item);&#125;); Array.map().map() 方法能够遍历整个数组，然后 返回一个新数组，这个新数组里的元素是经过了指定的回调函数处理过的。 如果你想修改数组里的每个元素，然后将修改后的数组存入新的数组，那使用 .map() 方法最方便。 1234567var numbers = [2, 4, 6, 8];var doubleNums = numbers.map(function(element) &#123; return element * 2;&#125;);console.log('doubleNums: ', doubleNums) Array.filter().filter() 方法能够 过滤掉数组中的某些元素，你可以在回调函数里设定条件，不符合条件的元素都会排除在外。 1234567891011var scores = [3, 12, 5, 23, 19, 7];var topScores = scores.filter(function(item)&#123; if (item &gt; 10)&#123; return true; &#125; else &#123; return false; &#125;&#125;);console.log('topScores: ', topScores); Array.indexOf().indexOf() 能够告诉你 某个元素在数组中的位置，它返回的是索引值，如果数组里有重复的元素，它会返回第一个元素的位置。 1234567891011var a = [2, 9, 9, 18];var i = a.indexOf(9);console.log('i: ', i);/*if (a.indexOf(7) === -1) &#123; // 数组中没有这个元素&#125;*/ Array.every().every() 方法的作用是用指定的回调函数去检查数组中的每个元素，如果对于每个元素，这个回调函数都返回true，则.every()``返回true。否则，.every() 返回false。 如果你想知道数组中的所有元素都是否符合某种条件，使用 .every() 最方便。 1234567var ages = [23, 19, 32, 44];var olderThan18 = ages.every(function(element) &#123; return element &gt; 18;&#125;);console.log('olderThan18: ', olderThan18); 上面的这5个方法只是很多JavaScript方法中关于数组的最重要的几个，还有很多关于数组的方法、工具包(lodash.js and underscore.js)等都非常的有用。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"移动端 H5 踩坑记录","slug":"article-mobile-summarize","date":"2017-04-28T04:19:15.000Z","updated":"2021-06-24T04:02:41.974Z","comments":true,"path":"2017/04/28/article-mobile-summarize/","link":"","permalink":"https://doubleray.top/2017/04/28/article-mobile-summarize/","excerpt":"这里收集了许多移动端上遇到的各种坑与相对解决方案！","text":"这里收集了许多移动端上遇到的各种坑与相对解决方案！ 工具类网站 HTML5 与 CSS3 技术应用评估 各种奇妙的hack 几乎所有设备的屏幕尺寸与像素密度表 移动设备参数表 ios端移动设备参数速查 浏览器兼容表 移动设备查询器 移动设备适配库 移动设备适配库2 viewport与设备尺寸在线检测器 html5 移动端兼容性速查 在线转换字体 css3 选择器测试 兼容性速查表 浏览器的一些独特参数 各种各样的媒体查询收集 css3 动画在线制作器 css3 渐变在线制作器 移动端手势表 webkit独有的样式分析 HTML5 Cross Browser Polyfills HTML5 POLYFILLS iphone6的那些事iPhone 6 屏幕揭秘 响应式测试工具Firefox 浏览器内置了 自定义设计视图 的功能，可以通过 Firefox-&gt;Web 开发者-&gt;自定义设计视图（或者摁下 Shift + Ctrl + m ）。相比网络工具，运行更加流畅，无需联网。 判断 iPad 和 iPhone 的版本和状态的 CSS 媒体查询代码 Viewport Resizer http://beta.screenqueri.es/ http://responsivepx.com http://www.responsinator.com/ http://resizemybrowser.com/ https://quirktools.com/screenfly/ 媒体查询常用样式表： 12&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt; // 竖放加载&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\"href=\"landscape.css\"&gt; // 横放加载 竖屏时使用的样式123&lt;style media=\"all and (orientation:portrait)\" type=\"text/css\"&gt; #landscape &#123; display: none; &#125;&lt;/style&gt; //横屏时使用的样式123&lt;style media=\"all and (orientation:landscape)\" type=\"text/css\"&gt; #portrait &#123; display: none; &#125;&lt;/style&gt; Web app 开发的最佳实践与中文总结It’s not a web app. It’s an app you install from the web. 当前 WEB APP 开发的最佳实践 如何自适应网页屏幕以及配套的解决方案 来自maxzhang的一些移动端经验总结干货 移动Web单页应用开发实践——页面结构化 移动Web产品前端开发口诀——“快” 移动Web开发，4行代码检测浏览器是否支持position:fixed 使用border-image实现类似iOS7的1px底边 移动端web页面使用position:fixed问题总结 移动Web开发实践——解决position:fixed自适应BUG 移动手机浏览器m3u8格式视频流播放支持程度测试 指尖下的js ——多触式web前端开发之一：对于Touch的处理 指尖下的js ——多触式web前端开发之二：处理简单手势 指尖下的js —— 多触式web前端开发之三：处理复杂手势 基础知识meta标签meta标签大全 http://segmentfault.com/blog/ciaocc/1190000002407912 meta标签，这些meta标签在开发webapp时起到非常重要的作用 1234&lt;meta content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0\" name=\"viewport\" /&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\" /&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；尤其要注意的是content里多个属性的设置一定要用分号+空格来隔开，如果不规范将不会起作用。 注意根据 public_00 提供的资料补充，content 使用分号作为分隔，在老的浏览器是支持的，但不是规范写法。 规范的写法应该是使用逗号分隔，参考 Safari HTML Reference - Supported Meta Tags 和 Android - Supporting Different Screens in Web Apps 其中： width - viewport的宽度 height - viewport的高度 initial-scale - 初始的缩放比例 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放 第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览；第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式；第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码 在设置了initial-scale=1 之后，我们终于可以以1:1 的比例进行页面设计了。关于viewport，还有一个很重要的概念是：iphone 的safari 浏览器完全没有滚动条，而且不是简单的“隐藏滚动条”，是根本没有这个功能。iphone 的safari 浏览器实际上从一开始就完整显示了这个网页，然后用viewport 查看其中的一部分。当你用手指拖动时，其实拖的不是页面，而是viewport。浏览器行为的改变不止是滚动条，交互事件也跟普通桌面不一样。(请参考：指尖的下JS 系列文章) 更详细的 viewport 相关的知识也可以参考 此像素非彼像素 移动开发事件手机浏览器常用手势动作监听封装 手势事件 touchstart //当手指接触屏幕时触发 touchmove //当已经接触屏幕的手指开始移动后触发 touchend //当手指离开屏幕时触发 touchcancel 触摸事件 gesturestart //当两个手指接触屏幕时触发 gesturechange //当两个手指接触屏幕后开始移动时触发 gestureend 屏幕旋转事件 onorientationchange 检测触摸屏幕的手指何时改变方向 orientationchange touch事件支持的相关属性 touches targetTouches changedTouches clientX // X coordinate of touch relative to the viewport (excludes scroll offset) clientY // Y coordinate of touch relative to the viewport (excludes scroll offset) screenX // Relative to the screen screenY // Relative to the screen pageX // Relative to the full page (includes scrolling) pageY // Relative to the full page (includes scrolling) target // Node the touch event originated from identifier // An identifying number, unique to each touch event 屏幕旋转事件：onorientationchange 判断屏幕是否旋转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 function orientationChange() &#123; switch(window.orientation) &#123; case 0: alert(\"肖像模式 0,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case -90: alert(\"左旋 -90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 90: alert(\"右旋 90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 180: alert(\"风景模式 180,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; &#125;;&#125;; addEventListener('load', function()&#123; orientationChange(); window.onorientationchange = orientationChange; &#125;);``` ### JS 单击延迟click 事件因为要等待单击确认，会有 300ms 的延迟，体验并不是很好。开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 [Creating Fast Buttons for Mobile Web Applications](https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE \"article5\") [Eliminate 300ms delay on click events in mobile Safari](http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari \"article5\")## WebKit CSS:[携程 UED 整理的 Webkit CSS 文档](http://ued.ctrip.com/blog/wp-content/webkitcss/index.html) ，全面、方便查询，下面为常用属性。①“盒模型”的具体描述性质的包围盒块内容，包括边界，填充等等。```css -webkit-border-bottom-left-radius: radius; -webkit-border-top-left-radius: horizontal_radius vertical_radius; -webkit-border-radius: radius; //容器圆角 -webkit-box-sizing: sizing_model; 边框常量值：border-box/content-box -webkit-box-shadow: hoff voff blur color; /*容器阴影（参数分别为：水平X 方向偏移量；垂直Y方向偏移量；高斯模糊半径值；阴影颜色值）*/ -webkit-margin-bottom-collapse: collapse_behavior; /*常量值：collapse/discard/separate*/ -webkit-margin-start: width; -webkit-padding-start: width; -webkit-border-image: url(borderimg.gif) 25 25 25 25 round/stretch round/stretch; -webkit-appearance: push-button; /*内置的CSS 表现，暂时只支持push-button*/ ②“视觉格式化模型”描述性质，确定了位置和大小的块元素。 direction: rtl unicode-bidi: bidi-override; 常量：bidi-override/embed/normal③“视觉效果”描述属性，调整的视觉效果块内容，包括溢出行为，调整行为，能见度，动画，变换，和过渡。 clip: rect(10px, 5px, 10px, 5px) resize: auto; 常量：auto/both/horizontal/none/vertical visibility: visible; 常量: collapse/hidden/visible -webkit-transition: opacity 1s linear; 动画效果 ease/linear/ease-in/ease-out/ease-in-out -webkit-backface-visibility: visibler; 常量：visible(默认值)/hidden -webkit-box-reflect: right 1px; 镜向反转 -webkit-box-reflect: below 4px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0.5, transparent), to(white)); -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)));; //CSS 遮罩/蒙板效果 -webkit-mask-attachment: fixed; 常量：fixed/scroll -webkit-perspective: value; 常量：none(默认) -webkit-perspective-origin: left top; -webkit-transform: rotate(5deg); -webkit-transform-style: preserve-3d; 常量：flat/preserve-3d; (2D 与3D)④“生成的内容，自动编号，并列出”描述属性，允许您更改内容的一个组成部分，创建自动编号的章节和标题，和操纵的风格清单的内容。 content: “Item” counter(section) ” “; This resets the counter. First section &gt;two section three section counter-increment: section 1; counter-reset: section;⑤“分页媒体”描述性能与外观的属性，控制印刷版本的网页，如分页符的行为。 page-break-after: auto; 常量：always/auto/avoid/left/right page-break-before: auto; 常量：always/auto/avoid/left/right page-break-inside: auto; 常量：auto/avoid⑥“颜色和背景”描述属性控制背景下的块级元素和颜色的文本内容的组成部分。 -webkit-background-clip: content; 常量：border/content/padding/text -webkit-background-origin: padding; 常量：border/content/padding/text -webkit-background-size: 55px; 常量：length/length_x/length_y⑦ “字型”的具体描述性质的文字字体的选择范围内的一个因素。报告还描述属性用于下载字体定义。 unicode-range: U+00-FF, U+980-9FF;⑧“文本”描述属性的特定文字样式，间距和自动滚屏。 text-shadow: #00FFFC 10px 10px 5px; text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase word-wrap: break-word; 常量：break-word/normal -webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度); -webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up -webkit-marquee-incrementt: 1-n/infinite(无穷次) -webkit-marquee-speed: fast/normal/slow -webkit-marquee-style: alternate/none/scroll/slide -webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase -webkit-text-security: circle; 常量：circle/disc/none/square -webkit-text-size-adjust: none; 常量:auto/none; -webkit-text-stroke: 15px #fff; -webkit-line-break: after-white-space; 常量：normal/after-white-space -webkit-appearance: caps-lock-indicator; -webkit-nbsp-mode: space; 常量： normal/space -webkit-rtl-ordering: logical; 常量：visual/logical -webkit-user-drag: element; 常量：element/auto/none -webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only -webkit-user-select: text; 常量：text/auto/none⑨“表格”描述的布局和设计性能表的具体内容。 -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; -webkit-column-break-after: right; 常量：always/auto/avoid/left/right -webkit-column-break-before: right; 常量：always/auto/avoid/left/right –webkit-column-break-inside: logical; 常量：avoid/auto -webkit-column-count: 3; //分栏 -webkit-column-rule: 1px solid #fff; style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid⑩“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸目标，如在iPhone上的链接。 -webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch -webkit-box-direction: normal;常量：normal/reverse -webkit-box-flex: flex_valuet -webkit-box-flex-group: group_number -webkit-box-lines: multiple; 常量：multiple/single -webkit-box-ordinal-group: group_number -webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation –webkit-box-pack: alignment; 常量：center/end/justify/start动画过渡这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。 -webkit-animation: title infinite ease-in-out 3s; animation 有这几个属性： -webkit-animation-name： //属性名，就是我们定义的keyframes -webkit-animation-duration：3s //持续时间 -webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier -webkit-animation-delay：10ms //动画延迟(默认0) -webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限 -webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放)这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。 -webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate） scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , *) rotate(*deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , *) Skew(*deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , *) translate(*,*) 坐标移动。translateX 和translateY，可简写为：translate(* , *)。页面描述&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;http://www.xxx.com/App_icon_72.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt;这个属性是当用户把连接保存到手机桌面时使用的图标，如果不设置，则会用网页的截图。有了这，就可以让你的网页像APP一样存在手机里了 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/img/startup.png&quot; /&gt;这个是APP启动画面图片，用途和上面的类似，如果不设置，启动画面就是白屏，图片像素就是手机全屏的像素 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;这个描述是表示打开的web app的最上面的时间、信号栏是黑色的，当然也可以设置其它参数，详细参数说明请参照：Safari HTML Reference - Supported Meta Tags &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;常见的 iPhone 和 Android 屏幕参数。 设备 分辨率 设备像素比率 Android LDPI 320×240 0.75 Iphone 3 &amp; Android MDPI 320×480 1 Android HDPI 480×800 1.5 Iphone 4 960×640 2.0 iPhone 4的一个 CSS 像素实际上表现为一块 2×2 的像素。所以图片像是被放大2倍一样，模糊不清晰。 解决办法： 1、页面引用 &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 0.75)&quot; href=&quot;ldpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 1.0)&quot; href=&quot;mdpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 1.5)&quot; href=&quot;hdpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 2.0)&quot; href=&quot;retina.css&quot; /&gt;2、CSS文件里 #header { background:url(mdpi/bg.png); } @media screen and (-webkit-device-pixel-ratio: 1.5) { /*CSS for high-density screens*/ #header { background:url(hdpi/bg.png); } }移动 Web 开发经验技巧点击与click事件对于a标记的点击导航，默认是在onclick事件中处理的。而移动客户端对onclick的响应相比PC浏览器有着明显的几百毫秒延迟。 在移动浏览器中对触摸事件的响应顺序应当是： ontouchstart -&gt; ontouchmove -&gt; ontouchend -&gt; onclick因此，如果确实要加快对点击事件的响应，就应当绑定ontouchend事件。 使用click会出现绑定点击区域闪一下的情况，解决：给该元素一个样式如下 -webkit-tap-highlight-color: rgba(0,0,0,0);如果不使用click，也不能简单的用touchstart或touchend替代，需要用touchstart的模拟一个click事件，并且不能发生touchmove事件，或者用zepto中的tap（轻击）事件。 body { -webkit-overflow-scrolling: touch; }用iphone或ipad浏览很长的网页滚动时的滑动效果很不错吧？不过如果是一个div，然后设置 height:200px;overflow:auto;的话，可以滚动但是完全没有那滑动效果，很郁闷吧？ 我看到很多网站为了实现这一效果，用了第三方类库，最常用的是iscroll（包括新浪手机页，百度等）我一开始也使用，不过自从用了-webkit-overflow-scrolling: touch;样式后，就完全可以抛弃第三方类库了，把它加在body{}区域，所有的overflow需要滚动的都可以生效了。 另外有一篇比较全的移动端点击解决方案 http://www.zhihu.com/question/28979857 锁定 viewportontouchmove=&quot;event.preventDefault()&quot; //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。利用 Media Query监听Media Query 相信大部分人已经使用过了。其实 JavaScript可以配合 Media Query这么用： var mql = window.matchMedia(&quot;(orientation: portrait)&quot;); mql.addListener(handleOrientationChange); handleOrientationChange(mql); function handleOrientationChange(mql) { if (mql.matches) { alert(&apos;The device is currently in portrait orientation &apos;) } else { alert(&apos;The device is currently in landscape orientation&apos;) }}借助了 Media Query 接口做的事件监听，所以很强大！ 也可以通过获取 CSS 值来使用 Media Query 判断设备情况，详情请看：JavaScript 依据 CSS Media Queries 判断设备的方法。 rem最佳实践rem是非常好用的一个属性，可以根据html来设定基准值，而且兼容性也很不错。不过有的时候还是需要对一些莫名其妙的浏览器优雅降级。以下是两个实践 http://jsbin.com/vaqexuge/4/edit 这有个demo，发现chrome当font-size小于12时，rem会按照12来计算。因此设置基准值要考虑这一点 可以用以下的代码片段保证在低端浏览器下也不会出问题 html { font-size: 62.5%; } body { font-size: 14px; font-size: 1.4rem; } /* =14px */ h1 { font-size: 24px; font-size: 2.4rem; } /* =24px */被点击元素的外观变化，可以使用样式来设定：-webkit-tap-highlight-color: 颜色检测判断 iPhone/iPod开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。 if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) { if (document.cookie.indexOf(&quot;iphone_redirect=false&quot;) == -1) { window.location = &quot;http://m.example.com&quot;; } }虽然Javascript是可以在水果设备上运行的，但是用户还是可以禁用。它也会造成客户端刷新和额外的数据传输，所以下面是服务器端侦测和转向： if(strstr($_SERVER[&apos;HTTP_USER_AGENT&apos;],&apos;iPhone&apos;) || strstr($_SERVER[&apos;HTTP_USER_AGENT&apos;],&apos;iPod&apos;)) { header(&apos;Location: http://yoursite.com/iphone&apos;); exit(); }阻止旋转屏幕时自动调整字体大小html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}模拟:hover伪类因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript： var myLinks = document.getElementsByTagName(&apos;a&apos;); for(var i = 0; i &lt; myLinks.length; i++){ myLinks[i].addEventListener(’touchstart’, function(){this.className = “hover”;}, false); myLinks[i].addEventListener(’touchend’, function(){this.className = “”;}, false); }然后用CSS增加hover效果： a:hover, a.hover { /* 你的hover效果 */ }这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。 Flexbox 布局 Flex 模板和实例 深入了解 Flexbox 伸缩盒模型 CSS Flexbox Intro http://www.w3.org/TR/css3-flexbox/ 居中问题居中是移动端跟pc端共同的噩梦。这里有两种兼容性比较好的新方案。 table布局法 .box{ text-align:center; display:table-cell; vertical-align:middle; } 老版本flex布局法 .box{ display:-webkit-box; -webkit-box-pack: center; -webkit-box-align: center; text-align:center; } 以上两种其实分别是retchat跟ionic的布局基石。 这里有更详细的更多的选择http://www.zhouwenbin.com/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/ 来自周文彬的博客 移动端实现标题文字截断http://www.75team.com/archives/611 处理 Retina 双倍屏幕 （经典）Using CSS Sprites to optimize your website for Retina Displays 使用CSS3的background-size优化苹果的Retina屏幕的图像显示 使用 CSS sprites 来优化你的网站在 Retina 屏幕下显示 （案例）CSS IMAGE SPRITES FOR RETINA (HIRES) DEVICES input类型为date情况下不支持placeholder（来自于江水）这其实是浏览器自己的处理。因为浏览器会针对此类型 input 增加 datepicker 模块。 对 input type date 使用 placeholder 的目的是为了让用户更准确的输入日期格式，iOS 上会有 datepicker 不会显示 placeholder 文字，但是为了统一表单外观，往往需要显示。Android 部分机型没有 datepicker 也不会显示 placeholder 文字。 桌面端（Mac） Safari 不支持 datepicker，placeholder 正常显示。 Firefox 不支持 datepicker，placeholder 正常显示。 Chrome 支持 datepicker，显示 年、月、日 格式，忽略 placeholder。 移动端 iPhone5 iOS7 有 datepicker 功能，但是不显示 placeholder。 Andorid 4.0.4 无 datepicker 功能，不显示 placeholder 解决方法： &lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot; id=&quot;date&quot;&gt; 因为text是支持placeholder的。因此当用户focus的时候自动把type类型改变为date，这样既有placeholder也有datepicker了 判断照片的横竖排列有这样一种需求，需要判断用户照片是横着拍出来的还是竖着拍出来的，这里需要使用照片得exif信息： $(&quot;input&quot;).change(function() { var file = this.files[0]; fr = new FileReader; fr.onloadend = function() { var exif = EXIF.readFromBinaryFile(new BinaryFile(this.result)); alert(exif.Orientation); }; fr.readAsBinaryString(file); });可以使用这两个库 来取exif信息http://www.nihilogic.dk/labs/binaryajax/binaryajax.js http://www.nihilogic.dk/labs/exif/exif.js Android上当viewport的width大于device-width时出现文字无故折行的解决办法http://www.iunbug.com/archives/2013/04/23/798.html ###白屏解决与优化方案 当前很多无线页面都使用前端模板进行数据渲染，那么在糟糕的网速情况下，一进去页面，看到的不是白屏就是 loading，这成为白屏问题。 此问题发生的原因基本可以归结为网速跟静态资源 1、css文件加载需要一些时间，在加载的过程中页面是空白的。 解决：可以考虑将css代码前置和内联。2、首屏无实际的数据内容，等待异步加载数据再渲染页面导致白屏。 解决：在首屏直接同步渲染html，后续的滚屏等再采用异步请求数据和渲染html。3、首屏内联js的执行会阻塞页面的渲染。 解决：尽量不在首屏html代码中放置内联脚本。（来自翔歌） 解决方案 根本原因是客户端渲染的无力，因此最简单的方法是在服务器端，使用模板引擎渲染所有页面。同时 1减少文件加载体积，如html压缩，js压缩 2加快js执行速度 比如常见的无限滚动的页面，可以使用js先渲染一个屏幕范围内的东西 3提供一些友好的交互，比如提供一些假的滚动条 4使用本地存储处理静态文件。 如何实现打开已安装的app，若未安装则引导用户安装?来自 http://gallery.kissyui.com/redirectToNative/1.2/guide/index.html kissy mobile通过iframe src发送请求打开app自定义url scheme，如taobao://home（淘宝首页） 、etao://scan（一淘扫描）);如果安装了客户端则会直接唤起，直接唤起后，之前浏览器窗口（或者扫码工具的webview）推入后台；如果在指定的时间内客户端没有被唤起，则js重定向到app下载地址。大概实现代码如下 goToNative:function(){ if(!body) { setTimeout(function(){ doc.body.appendChild(iframe); }, 0); } else { body.appendChild(iframe); } setTimeout(function() { doc.body.removeChild(iframe); gotoDownload(startTime);//去下载，下载链接一般是itunes app store或者apk文件链接 /** * 测试时间设置小于800ms时，在android下的UC浏览器会打开native app时并下载apk， * 测试android+UC下打开native的时间最好大于800ms; */ }, 800); }需要注意的是 如果是android chrome 25版本以后，在iframe src不会发送请求，原因如下https://developers.google.com/chrome/mobile/docs/intents ，通过location href使用intent机制拉起客户端可行并且当前页面不跳转。 window.location = &apos;intent://&apos; + schemeUrl + &apos;#Intent;scheme=&apos; + scheme + &apos;;package=&apos; + self.package + &apos;;end&apos;;补充一个来自三水清的详细讲解 http://js8.in/2013/12/16/ios%E4%BD%BF%E7%94%A8schema%E5%8D%8F%E8%AE%AE%E8%B0%83%E8%B5%B7app/ active的兼容(来自薛端阳)今天发现，要让a链接的CSS active伪类生效，只需要给这个a链接的touch系列的任意事件touchstart/touchend绑定一个空的匿名方法即可hack成功 &lt;style&gt; a { color: #000; } a:active { color: #fff; } &lt;/style&gt; &lt;a herf=”asdasd”&gt;asdasd&lt;/a&gt; &lt;script&gt; var a=document.getElementsByTagName(‘a’); for(var i=0;i&lt;a.length;i++){ a[i].addEventListener(‘touchstart’,function(){},false); } &lt;/script&gt;消除transition闪屏两个方法：使用css3动画的时尽量利用3D加速，从而使得动画变得流畅。动画过程中的动画闪白可以通过 backface-visibility 隐藏。 -webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-backface-visibility: hidden; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/测试是否支持svg图片document.implementation.hasFeature(&quot;http:// www.w3.org/TR/SVG11/feature#Image&quot;, &quot;1.1&quot;)考虑兼容“隐私模式”(from http://blog.youyo.name/archives/smarty-phones-webapp-deverlop-advance.html)ios的safari提供一种“隐私模式”，如果你的webapp考虑兼容这个模式，那么在使用html5的本地存储的一种————localStorage时，可能因为“隐私模式”下没有权限读写localstorge而使代码抛出错误，导致后续的js代码都无法运行了。 既然在safari的“隐私模式”下，没有调用localStorage的权限，首先想到的是先判断是否支持localStorage，代码如下： if(&apos;localStorage&apos; in window){ //需要使用localStorage的代码写在这 }else{ //不支持的提示和向下兼容代码 }测试发现，即使在safari的“隐私模式”下，’localStorage’ in window的返回值依然为true，也就是说，if代码块内部的代码依然会运行，问题没有得到解决。接下来只能相当使用try catch了，虽然这是一个不太推荐被使用的方法，使用try catch捕获错误，使后续的js代码可以继续运行，代码如下： try{ if(&apos;localStorage&apos; in window){ //需要使用localStorage的代码写在这 }else{ //不支持的提示和向下兼容代码 } }catch(e){ // 隐私模式相关提示代码和不支持的提示和向下兼容代码 }所以，提醒大家注意，在需要兼容ios的safari的“隐私模式”的情况下，本地存储相关的代码需要使用try catch包裹并降级兼容。 安卓手机点击锁定页面效果问题有些安卓手机，页面点击时会停止页面的javascript，css3动画等的执行，这个比较蛋疼。不过可以用阻止默认事件解决。详细见http://stackoverflow.com/questions/10246305/android-browser-touch-events-stop-display-being-updated-inc-canvas-elements-h function touchHandlerDummy(e) { e.preventDefault(); return false; } document.addEventListener(&quot;touchstart&quot;, touchHandlerDummy, false); document.addEventListener(&quot;touchmove&quot;, touchHandlerDummy, false); document.addEventListener(&quot;touchend&quot;, touchHandlerDummy, false);消除ie10里面的那个叉号IE Pseudo-elements input:-ms-clear{display:none;}关于ios与os端字体的优化(横竖屏会出现字体加粗不一致等)mac下网页中文字体优化 UIWebView font is thinner in portrait than landscape 判断用户是否是“将网页添加到主屏后，再从主屏幕打开这个网页”的navigator.standalone隐藏地址栏 &amp; 处理事件的时候，防止滚动条出现：// 隐藏地址栏 &amp; 处理事件的时候 ，防止滚动条出现 addEventListener(&apos;load&apos;, function(){ setTimeout(function(){ window.scrollTo(0, 1); }, 100); });ios7 可以通过meta标签的minimal来隐藏地址栏了http://darkblue.sdf.org/weblog/ios-7-dot-1-mobile-safari-minimal-ui.html 判断是否为iPhone：// 判断是否为 iPhone ： function isAppleMobile() { return (navigator.platform.indexOf(&apos;iPhone&apos;) != -1); };localStorage:var v = localStorage.getItem(&apos;n&apos;) ? localStorage.getItem(&apos;n&apos;) : &quot;&quot;; // 如果名称是 n 的数据存在 ，则将其读出 ，赋予变量 v 。 localStorage.setItem(&apos;n&apos;, v); // 写入名称为 n、值为 v 的数据 localStorage.removeItem(&apos;n&apos;); // 删除名称为 n 的数据使用特殊链接：如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 , &lt;a href=&quot;tel:12345654321&quot;&gt;打电话给我&lt;/a&gt; &lt;a href=&quot;sms:12345654321&quot;&gt;发短信&lt;/a&gt;或用于单元格： &lt;td onclick=&quot;location.href=&apos;tel:122&apos;&quot;&gt;自动大写与自动修正要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项： &lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;不让 Android 识别邮箱&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;禁止 iOS 弹出各种操作窗口-webkit-touch-callout:none禁止用户选中文字-webkit-user-select:none动画效果中，使用 translate 比使用定位性能高Why Moving Elements With Translate() Is Better Than Pos:abs Top/left 拿到滚动条window.scrollY window.scrollX 比如要绑定一个touchmove的事件，正常的情况下类似这样(来自呼吸二氧化碳) $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ //.….code {});而如果中间的code需要处理的东西多的话，fps就会下降影响程序顺滑度，而如果改成这样 $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ setTimeout(function(){ //.….code },0); {});把代码放在setTimeout中，会发现程序变快. 关于 iOS 系统中，Web APP 启动图片在不同设备上的适应性设置http://stackoverflow.com/questions/4687698/mulitple-apple-touch-startup-image-resolutions-for-ios-web-app-esp-for-ipad/10011893#10011893 position:sticky与position:fixed布局http://www.zhouwenbin.com/positionsticky-%E7%B2%98%E6%80%A7%E5%B8%83%E5%B1%80/http://www.zhouwenbin.com/sticky%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98/ 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉 this.value = this.value.replace(/\\u2006/g, &apos;&apos;);关于android webview中，input元素输入时出现的怪异情况见下图 Android Web 视图,至少在 HTC EVO 和三星的 Galaxy Nexus 中，文本输入框在输入时表现的就像占位符。情况为一个类似水印的东西在用户输入区域，一旦用户开始输入便会消失(见图片)。 在 Android 的默认样式下当输入框获得焦点后，若存在一个绝对定位或者 fixed 的元素，布局会被破坏，其他元素与系统输入字段会发生重叠(如搜索图标将消失为搜索字段)，可以观察到布局与原始输入字段有偏差(见截图)。 这是一个相当复杂的问题，以下简单布局可以重现这个问题: &lt;label for=&quot;phone&quot;&gt;Phone: *&lt;/label&gt; &lt;input type=&quot;tel&quot; name=&quot;phone&quot; id=&quot;phone&quot; minlength=&quot;10&quot; maxlength=&quot;10&quot; inputmode=&quot;latin digits&quot; required=&quot;required&quot; /&gt;解决方法 -webkit-user-modify: read-write-plaintext-only详细参考http://www.bielousov.com/2012/android-label-text-appears-in-input-field-as-a-placeholder/注意，该属性会导致中文不能输入词组，只能单个字。感谢鬼哥与飞（游勇飞）贡献此问题与解决方案 另外，在position:fixed后的元素里，尽量不要使用输入框。更多的bug可参考http://www.cosdiv.com/page/M0/S882/882353.html 依旧无法解决（摩托罗拉ME863手机），则使用input:text类型而非password类型，并设置其设置 -webkit-text-security: disc; 隐藏输入密码从而解决。 JS动态生成的select下拉菜单在Android2.x版本的默认浏览器里不起作用解决方法删除了overflow-x:hidden; 然后在JS生成下来菜单之后focus聚焦，这两步操作之后解决了问题。(来自岛都-小Qi) 参考http://stackoverflow.com/questions/4697908/html-select-control-disabled-in-android-webview-in-emulator Andriod 上去掉语音输入按钮input::-webkit-input-speech-button {display: none}IE10 的特殊鼠标事件IE10 事件监听 iOS 输入框最佳实践Mobile-friendly input of a digits + spaces string (a credit card number) HTML5 input type number vs tel iPhone: numeric keyboard for text input Text Programming Guide for iOS - Managing the Keyboard HTML5 inputs and attribute support 往返缓存问题点击浏览器的回退，有时候不会自动执行js，特别是在mobilesafari中。这与往返缓存(bfcache)有关系。有很多hack的处理方法，可以参考 http://stackoverflow.com/questions/24046/the-safari-back-button-problem http://stackoverflow.com/questions/11979156/mobile-safari-back-button 不暂停的计时器（safari的进程冻结）https://www.imququ.com/post/ios-none-freeze-timer.html或者可以用postmessage方式:主页面: // 解决ios safari tab在后台会遭遇进程冻结问题 // http://www.apple.com/safari/#gallery-icloud-tabs // Safari takes advantage of power-saving technologies such as App Nap, which puts background Safari tabs into a low-power state until you start using them again. In addition, Safari Power Saver conserves battery life by intelligently pausing web videos and other plug‑in content when they’re not front and center on the web pages you visit. All told, Safari on OS X Mavericks lets you browse up to an hour longer than with Chrome or Firefox.1 var work; function startWorker() { if (typeof(Worker) !== &quot;undefined&quot;) { if (typeof(work) == &quot;undefined&quot;) { work = new Worker(&quot;/workers.js&quot;); } work.onmessage = function(event) { // document.getElementById(&quot;result-count&quot;).innerHTML = event.data.count; // document.getElementById(&quot;result-url&quot;).innerHTML = event.data.targetURL; if (target &amp;&amp; event.data.targetURL != &quot;&quot;) target.location.href = event.data.targetURL; }; } else { console.log(&apos;does not support Web Workers...&apos;); } } function stopWorker() { work.terminate(); } startWorker();worker: // 解决ios safari tab在后台会遭遇进程冻结问题 // http://www.apple.com/safari/#gallery-icloud-tabs // Safari takes advantage of power-saving technologies such as App Nap, which puts background Safari tabs into a low-power state until you start using them again. In addition, Safari Power Saver conserves battery life by intelligently pausing web videos and other plug‑in content when they’re not front and center on the web pages you visit. All told, Safari on OS X Mavericks lets you browse up to an hour longer than with Chrome or Firefox.1 importScripts(&apos;/socket.io/socket.io.js&apos;); var count = 0, targetURL = &apos;&apos; ; var socket = io.connect(&apos;/&apos;); socket.on(&apos;navigate&apos;, function (data) { count = count++; postMessage({targetURL:data.url,count:count}); });Web移动端Fixed布局的解决方案http://efe.baidu.com/blog/mobile-fixed-layout/ ios上background-attachment:fixed不能正常工作参考 http://stackoverflow.com/questions/20443574/fixed-background-image-with-ios7 如何让音频跟视频在ios跟android上自动播放&lt;audio autoplay &gt;&lt;source src=&quot;audio/alarm1.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt;系统默认情况下 audio的autoplay属性是无法生效的，这也是手机为节省用户流量做的考虑。如果必须要自动播放，有两种方式可以解决。 1.捕捉一次用户输入后，让音频加载，下次即可播放。 //play and pause it once document.addEventListener(&apos;touchstart&apos;, function () { document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause(); });这种方法需要捕获一次用户的点击事件来促使音频跟视频加载。当加载后，你就可以用javascript控制音频的播放了，如调用audio.play() 2.利用iframe加载资源 var ifr=document.createElement(&quot;iframe&quot;); ifr.setAttribute(&apos;src&apos;, &quot;http://mysite.com/myvideo.mp4&quot;); ifr.setAttribute(&apos;width&apos;, &apos;1px&apos;); ifr.setAttribute(&apos;height&apos;, &apos;1px&apos;); ifr.setAttribute(&apos;scrolling&apos;, &apos;no&apos;); ifr.style.border=&quot;0px&quot;; document.body.appendChild(ifr);这种方式其实跟第一种原理是一样的。当资源加载了你就可以控制播放了，但是这里使用iframe来加载，相当于直接触发资源加载。注意，使用创建audio标签并让其加载的方式是不可行的。慎用这种方法，会对用户造成很糟糕的影响。。 iOS 6 跟 iPhone 5 的那些事IP5 的媒体查询@media (device-height: 568px) and (-webkit-min-device-pixel-ratio: 2) { /* iPhone 5 or iPod Touch 5th generation */ }使用媒体查询，提供不同的启动图片：&lt;link href=&quot;startup-568h.png&quot; rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-height: 568px)&quot;&gt; &lt;link href=&quot;startup.png&quot; rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x920&quot; media=&quot;(device-height: 480px)&quot;&gt;拍照上传&lt;input type=file accept=&quot;video/*&quot;&gt; &lt;input type=file accept=&quot;image/*&quot;&gt;不支持其他类型的文件 ，如音频，Pages文档或PDF文件。 也没有getUserMedia摄像头的实时流媒体支持。 可以使用的 HTML5 高级 api multipart POST 表单提交上传 XMLHttpRequest 2 AJAX 上传（甚至进度支持） 文件 API ，在 iOS 6 允许 JavaScript 直接读取的字节数和客户端操作文件。 智能应用程序横幅有了智能应用程序横幅，当网站上有一个相关联的本机应用程序时，Safari浏览器可以显示一个横幅。 如果用户没有安装这个应用程序将显示“安装”按钮，或已经安装的显示“查看”按钮可打开它。 在 iTunes Link Maker 搜索我们的应用程序和应用程序ID。 &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999&quot;&gt;可以使用 app-argument 提供字符串值，如果参加iTunes联盟计划，可以添加元标记数据 &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999, app-argument=xxxxxx&quot;&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999, app-argument=xxxxxx, affiliate-data=partnerId=99&amp;siteID=XXXX&quot;&gt;横幅需要156像素（设备是312 hi-dpi）在顶部，直到用户在下方点击内容或关闭按钮，你的网站才会展现全部的高度。 它就像HTML的DOM对象，但它不是一个真正的DOM。 CSS3 滤镜 -webkit-filter: blur(5px) grayscale (.5) opacity(0.66) hue-rotate(100deg);交叉淡变 background-image: -webkit-cross-fade(url(&quot;logo1.png&quot;), url(&quot;logo2.png&quot;), 50%);Safari中的全屏幕 除了chrome-less 主屏幕meta标签，现在的iPhone和iPod Touch（而不是在iPad）支持全屏幕模式的窗口。 没有办法强制全屏模式，它需要由用户启动（工具栏上的最后一个图标）。需要引导用户按下屏幕上的全屏图标来激活全屏效果。 可以使用onresize事件检测是否用户切换到全屏幕。 支持requestAnimationFrameAPI 支持image-set,retina屏幕的利器 -webkit-image-set(url(low.png) 1x, url(hi.jpg) 2x)应用程序缓存限制增加至25MB。 Web View（pseudobrowsers，PhoneGap/Cordova应用程序，嵌入式浏览器） 上Javascript运行比Safari慢3.3倍（或者说，Nitro引擎在Safari浏览器是Web应用程序是3.3倍速度）。 autocomplete属性的输入遵循DOM规范 来自DOM4的Mutation Observers已经实现。 您可以使用WebKitMutationObserver构造器捕获DOM的变化 Safari不再总是对用 -webkit-transform:preserve-3d 的元素创建硬件加速 支持window.selection 的Selection API Canvas更新 ：createImageData有一个参数，现在有两个新的功能做好准备，用webkitGetImageDataHD和webkitPutImageDataHD提供高分辨率图像 。 更新SVG处理器和事件构造函数 IOS7的大更新iOS 7 的 Safari 和 HTML5：问题，变化和新 API(张金龙翻译) iOS 7 的一些坑(英文) ios7的一些坑2(英文) webview相关Cache开启和设置browser.getSettings().setAppCacheEnabled(true); browser.getSettings().setAppCachePath(&quot;/data/data/[com.packagename]/cache&quot;); browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MBLocalStorage相关设置browser.getSettings().setDatabaseEnabled(true); browser.getSettings().setDomStorageEnabled(true); String databasePath = browser.getContext().getDir(&quot;databases&quot;, Context.MODE_PRIVATE).getPath(); browser.getSettings().setDatabasePath(databasePath);//Android webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中 myWebView.setWebChromeClient(new WebChromeClient(){ @Override public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) { quotaUpdater.updateQuota(estimatedSize * 2); } }浏览器自带缩放按钮取消显示browser.getSettings().setBuiltInZoomControls(false);几个比较好的实践使用localstorage缓存html 使用lazyload，还要记得lazyload占位图虽然小，但是最好能提前加载到缓存 延时加载执行js 主要原因就在于Android Webview的onPageFinished事件，Android端一般是用这个事件来标识页面加载完成并显示的，也就是说在此之前，会一直loading，但是Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。 manifest与缓存相关:http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/相关解决方案http://mt.tencent.com/ 移动端调适篇手机抓包与配host在PC上，我们可以很方便地配host，但是手机上如何配host，这是一个问题。 这里主要使用fiddler和远程代理，实现手机配host的操作，具体操作如下： 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” 手机上设置代理，代理IP为PC的IP地址，端口为8888（这是fiddler的默认端口）。通常手机上可以直接设置代理，如果没有，可以去下载一个叫ProxyDroid的APP来实现代理的设置。 此时你会发现，用手机上网，走的其实是PC上的fiddler，所有的请求包都会在fiddler中列出来，配合willow使用，即可实现配host，甚至是反向代理的操作。 也可以用CCProxy之类软件，还有一种方法就是买一个随身wifi，然后手机连接就可以了！ 高级抓包iPhone上使用Burp Suite捕捉HTTPS通信包方法 mobile app 通信分析方法小议（iOS/Android) 实时抓取移动设备上的通信包(ADVsock2pipe+Wireshark+nc+tcpdump) 静态资源缓存问题一般用代理软件代理过来的静态资源可以设置nocache避免缓存，但是有的手机比较诡异，会一直缓存住css等资源文件。由于静态资源一般都是用版本号管理的，我们以charles为例子来处理这个问题 charles 选择静态的html页面文件-saveResponse。之后把这个文件保存一下，修改一下版本号。之后继续发请求，刚才的html页面文件 右键选择 –map local 选择我们修改过版本号的html文件即ok。这其实也是fiddler远程映射并修改文件的一个应用场景。 安卓模拟器和真机区别http://www.farsight.com.cn/news/emb105.htm http://testerhome.com/topics/388 http://www.cnblogs.com/zdz8207/archive/2012/01/30/2332436.html 移动浏览器篇微信浏览器微信浏览器的各种bug汇总 （x5内核） http://www.qianduan.net/qqliu-lan-qi-x5nei-he-wen-ti-hui-zong/ 因为微信浏览器屏蔽了一部分链接图片，所以需要引导用户去打开新页面，可以用以下方式判断微信浏览器的ua function is_weixn(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) { return true; } else { return false; } }后端判断也很简单，比如php function is_weixin(){ if ( strpos($_SERVER[&apos;HTTP_USER_AGENT&apos;], &apos;MicroMessenger&apos;) !== false ) { return true; } return false; }https://github.com/maxzhang/maxzhang.github.com/issues/31 微信浏览器踩坑，来自maxZhang https://github.com/maxzhang 【UC浏览器】video标签脱离文档流场景：标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流。 测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 Demo：http://t.cn/zj3xiyu 解决方案：不使用transform属性。translate用top、margin等属性替代。 【UC浏览器】video标签总在最前场景：标签总是在最前（可以理解为video标签的z-index属性是Max）。 测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 【UC浏览器】position:fixed 属性在UC浏览器的奇葩现象场景：设置了position: fixed 的元素会遮挡z-index值更高的同辈元素。 在8.6的版本,这个情况直接出现。 在8.7之后的版本,当同辈元素的height大于713这个「神奇」的数值时,才会被遮挡。 测试环境：UC浏览器 8.8_beta/8.7/8.6 + Android 2.3/4.0 。 Demo：http://t.cn/zYLTSg6 【QQ手机浏览器】不支持HttpOnly场景：带有HttpOnly属性的Cookie，在QQ手机浏览器版本从4.0开始失效。JavaScript可以直接读取设置了HttpOnly的Cookie值。 测试环境：QQ手机浏览器 4.0/4.1/4.2 + Android 4.0 。 【MIUI原生浏览器】浏览器地址栏hash不改变场景：location.hash 被赋值后，地址栏的地址不会改变。 但实际上 location.href 已经更新了，通过JavaScript可以顺利获取到更新后的地址。 虽然不影响正常访问，但用户无法将访问过程中改变hash后的地址存为书签。 测试环境：MIUI 4.0 【Chrome Mobile】fixed元素无法点击 场景：父元素设置position: fixed; 子元素设置position: absolute; 此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。 视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。 补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。 测试平台： 小米1S，Android4.0的Chrome18 demo： http://maplejan.sinaapp.com/demo/fixed_chromemobile.html 解决办法： 把父元素和子元素的overflow: hidden去掉。 以上来源于 http://www.cnblogs.com/maplejan/archive/2013/04/26/3045928.html 库的使用实践zepto.js zepto的一篇使用注意点讲解 zepto的著名的tap“点透”bug zepto源码注释 使用zeptojs内嵌到android webview影响正常滚动时https://github.com/madrobby/zepto/blob/master/src/touch.js 去掉61行,其实就是使用原生的滚动 iscroll4 iscroll4 的几个bug(来自 http://www.mansonchor.com/blog/blog_detail_64.html 内有详细讲解) 1.滚动容器点击input框、select等表单元素时没有响应】 onBeforeScrollStart: function (e) { e.preventDefault(); }改为 onBeforeScrollStart: function (e) { var nodeType = e.explicitOriginalTarget © e.explicitOriginalTarget.nodeName.toLowerCase():(e.target © e.target.nodeName.toLowerCase():&apos;&apos;);if(nodeType !=&apos;select&apos;&amp;&amp; nodeType !=&apos;option&apos;&amp;&amp; nodeType !=&apos;input&apos;&amp;&amp; nodeType!=&apos;textarea&apos;) e.preventDefault(); }2.往iscroll容器内添加内容时，容器闪动的bug 源代码的 has3d = &apos;WebKitCSSMatrix&apos; in window &amp;&amp; &apos;m11&apos; in new WebKitCSSMatrix()改成 has3d = false在配置iscroll时，useTransition设置成false 3.过长的滚动内容，导致卡顿和app直接闪退 不要使用checkDOMChanges。虽然checkDOMChanges很方便，定时检测容器长度是否变化来refresh，但这也意味着你要消耗一个Interval的内存空间 隐藏iscroll滚动条，配置时设置hScrollbar和vScrollbar为false。 不得已的情况下，去掉各种效果，momentum、useTransform、useTransition都设置为false 4.左右滚动时，不能正确响应正文上下拉动 iscroll的闪动问题也与渲染有关系，可以参考 运用webkit绘制渲染页面原理解决iscroll4闪动的问题iscroll4升级到5要注意的问题 iscroll或者滚动类框架滚动时不点击的方法可以使用以下的解决方案(利用data-setapi) &lt;a ontouchmove=&quot;this.s=1&quot; ontouchend=&quot;this.s || window.open(this.dataset.href),this.s=0&quot; target=&quot;_blank&quot; data-href=&quot;http://www.hao123.com/topic/pig&quot;&gt;黄浦江死猪之谜&lt;/a&gt;也可以用这种方法 $(document).delegate(&apos;[data-target]&apos;, &apos;touchmove&apos;, function () { $(this).attr(&apos;moving&apos;,&apos;moving&apos;); }) $(document).delegate(&apos;[data-target]&apos;, &apos;touchend&apos;, function () { if ($(this).attr(&apos;moving&apos;) !== &apos;moving&apos;) { //做你想做的。。 $(this).attr(&apos;moving&apos;, &apos;notMoving&apos;); } else { $(this).attr(&apos;moving&apos;, &apos;notMoving&apos;); } })移动端字体问题知乎专栏 - [无线手册-4] dp、sp、px傻傻分不清楚[完整] Resolution Independent Mobile UI Pixel density, retina display and font-size in CSS Device pixel density tests 跨域问题手机浏览器也是浏览器，在ajax调用外部api的时候也存在跨域问题。当然利用 PhoneGap 打包后，由于协议不一样就不存在跨域问题了。但页面通常是需要跟后端进行调试的。一般会报类似 XMLHttpRequest cannot load XXX Origin null is not allowed by Access-Control-Allow-Origin.以及 XMLHttpRequest cannot load http://. Request header field Content-Type is not allowed by Access-Control-Allow-Headers.&quot;这时候可以让后端加上两个http头 Access-Control-Allow-Origin &quot;*&quot; Access-Control-Allow-Headers &quot;Origin, X-Requested-With, Content-Type, Accept&quot;第一个头可以避免跨域问题，第二个头可以方便ajax请求设置content-type等配置项 这个会存在一些安全问题，可以参考这个问题的讨论 http://www.zhihu.com/question/22992229 PhoneGap 部分http://snoopyxdy.blog.163.com/blog/static/60117440201432491123551 这里有一大堆snoopy总结的phonggap开发坑 Should not happen: no rect-based-test nodes found在 Android 项目中的 assets 中的 HTML 页面中加入以下代码，便可解决问题 window,html,body{ overflow-x:hidden !important; -webkit-overflow-scrolling: touch !important; overflow: scroll !important; }参考： http://stackoverflow.com/questions/12090899/android-webview-jellybean-should-not-happen-no-rect-based-test-nodes-found 拿联系人的时候报 ContactFindOptions is not defined出现这个问题可能是因为 Navigator 取 contacts 时绑定的 window.onload 注意使用 PhoneGap 的 API 时，一定要在 devicereay 事件的处理函数中使用 API document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false); function onDeviceReady() { callFetchContacts(); } function callFetchContacts(){ var options = new ContactFindOptions(); options.multiple = true; var fields = [&quot;displayName&quot;, &quot;name&quot;,&quot;phoneNumbers&quot;]; navigator.contacts.find(fields, onSuccess, onError,options); }","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://doubleray.top/tags/Web/"}]},{"title":"JavaScript 断点调试","slug":"article-js-pausebug","date":"2017-04-20T08:41:15.000Z","updated":"2021-06-24T04:02:41.969Z","comments":true,"path":"2017/04/20/article-js-pausebug/","link":"","permalink":"https://doubleray.top/2017/04/20/article-js-pausebug/","excerpt":"虽然网上已经有多的数不清的调试教程了，但仍然没有发现哪篇文章写的通俗易懂，索性自己尝试写写自己的一些使用习惯或者说是心得，希望对那些还不是很懂得使用断点调试的孩子有一些帮助（大神请无视~）。 本文参考自 沐清风blog 的 js断点调试心得","text":"虽然网上已经有多的数不清的调试教程了，但仍然没有发现哪篇文章写的通俗易懂，索性自己尝试写写自己的一些使用习惯或者说是心得，希望对那些还不是很懂得使用断点调试的孩子有一些帮助（大神请无视~）。 本文参考自 沐清风blog 的 js断点调试心得 1. 断点调试是啥？难不难？断点调试其实并不是多么复杂的一件事，简单的理解无外呼就是打开浏览器，打开sources找到js文件，在行号上点一下罢了。操作起来似乎很简单，其实很多人纠结的是，是在哪里打断点？（我们先看一个断点截图，以chrome浏览器的断点为例） 步骤记住没？ 用chrome浏览器打开页面 → 按f12打开开发者工具 → 打开Sources → 打开你要调试的js代码文件 → 在行号上单击一下，OK!恭喜你的处女断点打上了,哈哈~~ 2. 断点怎么打才合适？打断点操作很简单，核心的问题在于，断点怎么打才能够排查出代码的问题所在呢？下面我继续举个例子方便大家理解，废话不多说，上图： 假设我们现在正在实现一个加载更多的功能，如上图，但是现在加载更多功能出现了问题，点击以后数据没有加载出来，这时候我们第一时间想到的应该是啥？（换一行写答案，大家可以看看自己的第一反应是啥） 我最先想到的是，我点击到底有没有成功？点击事件里的方法有没有运行？好，要想知道这个问题的答案，我们立马去打个断点试试看，断点打在哪？自己先琢磨一下。 接着上图： 各位想到没？没错，既然想知道点击是否成功，我们当然是在代码中的点击事件处添加一个断点，切记不要添加在226行哦，因为被执行的是click方法内的函数，而不是226行的选择器。断点现在已经打上了，然后做什么呢？自己再琢磨琢磨~ 继续上图： 然后我们当然是回去点击加载更多按钮啦，为什么？额。。。如果你这么问，不点击加载更多按钮，怎么去触发点击事件？不触发点击事件，怎么去执行点击事件里的函数？咆哮状。。不过我相信大家肯定不会问这么low的问题不瞎扯了 继续正题，上面的图就是点击加载更多按钮后的情况，我们可以看到左侧的页面被一个半透明的层给盖住了，页面上方还有一串英文和两个按钮，右侧代码227行被添加上了背景色，出现这个情况，先不管那些按钮英文是啥意思有啥作用，你从这个图得到了什么信息？继续琢磨琢磨~ 如果出现了上图这个情况，说明一点，click事件中的函数被调用了，进一步说明了点击事件生效。那么我们对于这个问题产生的第一个“犯罪嫌疑人”就被排除了。 补充一下： 如果没有出现上面的情况咋办？那是不是说明点击事件没有生效呢？那是什么导致点击事件没有生效？大家自己思考思考~ 可能导致点击事件没生效的原因很多，比多选择器错误，语法错误，被选择的元素是后生成的等。怎么解决呢？ 选择器错误，大家可以继续往后看到console部分的内容，我想大家就知道怎么处理了 语法错误，细心排查一下，不熟悉的语法可以百度对比一下 被选择的元素是后生成的，最简单的处理就是使用.on()方法去处理，这个东东带有事件委托处理，详情可以自行百度。 那么接下来”犯罪嫌疑人“的身份锁定在哪里呢？ 我们将目光投向事件内部，click事件触发了，那么接下来的问题就是它内部的函数问题了。如果你要问为什么？请给我一块豆腐。。。 打个比方，给你一支笔，让你写字，然后你在纸上写了一个字，发现字没出来，为啥？你说我写了呀，纸上都还有划痕。那是不是可能笔没有墨水或者笔尖坏了了？这个例子和点击加载更多一个道理，写字这个动作就是点击操作，而内部函数就是墨水或者笔尖。明白了不~ 接着我们分析下点击事件里面的内容，里面包含三句话，第一句话是变量i自增长，第二句话是给按钮添加一个i标签，第三句话是调用请求数据的方法。 就通过这三句话的本身作用，我们可以将较大一部分嫌疑放在第三句话，一小部分放在第一句和第二句话上，有人可能会疑惑，第二句话怎么会有嫌疑呢？他的作用只不过是添加一个标签，对于数据完全没有影响啊，确实，这句话对于数据没有影响，但是出于严谨考虑，它仍然有可能出错，例如它要是少了一个分号呢？或者句子内部某个符号错误呢？往往就是这种小问题浪费我们很多时间。 好，为了进一步锁定”犯罪嫌疑人“，给大家介绍一个工具，也是上图出现两个图标之一，见下图： 这个小图标的功能叫”逐语句执行“或者叫”逐步执行“，这是我个人理解的一个叫法，意思就是，每点击它一次，js语句就会往后执行一句，它还有一个快捷键，F10。下图示范一下它被点击以后的效果： 我单击了两次这个按钮（或者使用F10快捷键），js代码从227行执行到了229行，所以我管它叫”逐语句执行“或者”逐步执行“。这个功能非常的实用，大部分的调试都会使用到它。 上面介绍到我单击了两次“逐语句执行”按钮，代码从227行运行到229行，大家觉得这意味着啥？是不是说明从语法上来说，前两句是没有问题的，那么是不是也同时意味着前两句就排除嫌疑了呢？我看不然。 大家都知道，加载更多就是一个下一页的功能，而其中最核心的一个就是传给后台的页码数值，每当我点击加载更多按钮一次，页码的数值就要加1，所以如果下一页的数据没出来，是不是有可能是因为页码数值也就是[i变量]（下面统一称呼i）有问题？那么如何排查页码是否存在问题呢？大家自己先思考思考。 下面教大家两种查看页码数值i]实际输出值的方法，上图： 第一种： 操作步骤如下： 1.仍然是在227行打上断点 → 2. 点击加载更多按钮 → 3. 单击一次“逐语句执行“按钮，js代码执行到228行 → 4.用鼠标选中i++（什么叫选中大家里不理解？就是你要复制一个东西，是不是要选中它？对，就是这个选中） → 5. 选中以后，鼠标悬浮在目标上方，你就看到上图的结果。 第二种： 这个方法其实和第一种差不多，只不过是在控制台输出i的值，大家只需要按照第一种方法执行到第三步 → 4. 打开和sources同一级栏目的console → 5. 在console下方的输入栏里输入i → 6. 按enter回车键即可。 上面的第二种方法里，提到了console这个东西，我们可以称呼它为控制台或者其他什么都可以，这不重要~console的功能很强大，在调试的过程中，我们往往需要知道某些变量的值到底输出了什么，或者我们使用选择器[$”.div”)这种]是否选中了我们想要的元素等，都可以在控制台打印出来。当然直接用第一种方法也可以。 给大家示范一下在console里打印我们想要选中的元素。上图~ 在控制台中输入$(this)，即可得到选择的元素，没错，正是我们所点击的对象——加载更多按钮元素。 在这里给大家说说我对console这个控制台的理解：这个东东就是一个js解析器，是浏览器本身用来解析运行js的家伙，只不过浏览器通过console让我们开发者在调试过程中，可以控制js的运行以及输出。通过上面的两种方法，大家可能觉得使用起来很简单，但是我要给大家提醒一下，或者说是一些新手比较容易遇到的困惑。 困惑一：在没有打断点的情况下，在console输入i，结果console报错了。 这应该是新手很常见的问题，为什么不打断点我就没有办法在控制台直接输出变量的值呢？个人理解这时候i只是一个局部变量，如果不打上断点，浏览器会把所有的js全部解析完成，console并不能访问到局部变量，只能访问到全局变量，所以这时候console会报错i未定义，但是当js打上断点时，console解析到了局部变量i所在的函数内，这时候i是能够被访问的。 困惑二：为什么我直接在console里输入$(“.xxx”)能打印出东西来呢？ 很简单，console本身就是一个js解析器，$(“.xxx”)就是一个js语句，所以自然console能够解析这个语句然后输出结果。 介绍完“逐语句执行”按钮和console控制台的用法，最后再介绍一个按钮，上图： 这个按钮我称呼它为“逐过程执行”按钮，和“逐语句执行”按钮不同，“逐过程执行”按钮常用在一个方法调用多个js文件时，涉及到的js代码比较长，则会使用到这个按钮。 上图： 假设上图我只在227行打了个断点，然后一直点击逐语句执行”按钮到229行，这时候如果再点击一次“逐语句执行”按钮呢？则会进入下图的js里： 这些都是zepto库文件的内容，没啥好看的，里面运行很复杂，我们不可能一直使用“逐语句执行”按钮，这样你会发现你按了大半天还在库文件里面绕。。。这时候咋办？那就该“逐过程执行”按钮上场了。 上图： 我除了在227行打了一个断点，同时还在237行打了一个断点，当我们运行到229行时，直接单击“逐过程执行”按钮，你会发现，js直接跳过了库文件，运行到了237行，大家可以自己使用体验一下。 最后总结本文主要介绍了“逐语句执行”按钮、“逐过程执行”按钮、console控制台这三个工具，以及调试bug时的一些思路。工具的用法我就不再赘述了，大家知道用法就行，具体怎么去更合理的使用，还需要大家通过大量的实践去总结提升~ 我其实在本文主要想讲的是调试bug的一个思路，但是由于选的例子涉及东西太多。。。怕全部写下来内容太长，大家也没兴趣看，所以我就简单的选了一部分给大家讲解，不知道大家有没有收获。别看我调试三句话写了一堆的东西，如果真的在实际项目中你也像我这样去做，估计你调试一个Bug的时间会比写一个脚本的时间还长很多。。。在实际情况下，我们应该养成拿到问题的第一时间，自行在脑海中排查问题，找到最有可能出现问题的点，如果没办法迅速的排查出最重要的点，那么你可以使用最麻烦但是很靠谱的方法，利用“逐语句执行”按钮将整个和问题相关的js依次去执行一遍，在执行的过程中，自己也跟着理清思路，同时注意下每个变量的值以及选择器选中的元素是否正确，一般来说，这样做一遍下来，bug都解决的差不多了。 所以个人认为，我们调试bug的思路应该是这样的：首先，js是否成功的执行进来；其次，js是否存在逻辑问题，变量问题，参数问题等等；最后，如果上述都没有问题，请仔细查看各种符号。。。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"深入理解 JavaScript 中的函数","slug":"article-js-fn","date":"2017-04-15T08:41:15.000Z","updated":"2021-06-24T04:02:41.966Z","comments":true,"path":"2017/04/15/article-js-fn/","link":"","permalink":"https://doubleray.top/2017/04/15/article-js-fn/","excerpt":"本文转自 码农网 的 深入理解 JavaScript 中的函数。 本文旨在提供web开发人员必须了解的所有JavaScript函数的基本知识。 函数于软件开发者而言并不是什么奇幻世界。如果你的日常活动涉及到编码，哪怕是一点点，那么在一天结束的时候，你一定创建/修改了一个或多个函数。 简而言之函数只不过是一组执行某个操作的语句。函数可能会有一些输入参数（在函数体中使用），并在执行后返回值。","text":"本文转自 码农网 的 深入理解 JavaScript 中的函数。 本文旨在提供web开发人员必须了解的所有JavaScript函数的基本知识。 函数于软件开发者而言并不是什么奇幻世界。如果你的日常活动涉及到编码，哪怕是一点点，那么在一天结束的时候，你一定创建/修改了一个或多个函数。 简而言之函数只不过是一组执行某个操作的语句。函数可能会有一些输入参数（在函数体中使用），并在执行后返回值。 JavaScript函数也具有这些特性，但它们不仅仅是常规函数。JavaScript函数是对象。你可以查看我曾经写的关于JavaScript对象的文章，里面我提到几乎JavaScript中的所有一切都是对象。 作为对象，JavaScript函数可能会有属性和其他函数（方法）。让我们来看看JavaScript中的一个典型的函数定义。 123function myNotSoGreatFunc(visitor) &#123; console.log(\"Welcome to Code Morning Mr. \" + visitor);&#125; 没错。上面的函数不涉及什么宏伟大业，因为它仅是对博客访问者表示了欢迎。但它展示了JavaScript函数的样子。函数定义从关键字function开始，然后是函数名，空的或有参数的括号。实际的函数代码（JavaScript语句）被封装在一对花括号内{ }。对于函数而言，return语句是可选的。JavaScript函数总是会返回一个值。当function主体中没有return语句时，那么function返回undefined。 下面的代码调用传递visitor name作为参数的函数。 123myNotSoGreatFunc(\"Bob Martin\");// Output:&amp;nbsp;// Welcome to Code Morning Mr. Bob Martin. 到现在为止，我们了解了函数非常基本的特征。现在，我们将对JavaScript函数的一些高级概念一探究竟。 1. 匿名函数JavaScript函数可以是匿名的。这意味着你可以从函数声明中省略函数名。但是，函数必须存储在变量中。 1var addNumbers = function (x, y) &#123; return x + y; &#125; 上述语法被也被称为函数表达式。你可以把变量addNumbers 当作函数名，以及像下面这样调用该函数。 1var sum = addNumbers(2, 3); 当你想传递一个函数作为参数给另一个函数时，函数表达式就非常方便了。让我们用一个简单的例子来试着了解这一点。 123456var add = function (first, second) &#123; return first + second &#125;;var multiply = function (first, second) &#123; return first * second &#125;; function calculate(fun, a, b) &#123; return fun(a, b);&#125; 首先我已经创建了两个匿名函数。第一个返回两个数的加法运算，第二个返回两个数的乘法运算。相当简单，没有什么可值得炫耀的地方。然后，我定义函数calculate，这个函数接受函数作为第一个参数后跟两个参数接受两个数字。 我可以通过传递任意函数作为第一个参数来调用函数calculate。 12var sum = calculate(add, 2, 3); // sum = 5var multiplication = calculate(multiply, 2, 3); // multiplication = 6 你可以看到将函数作为参数传递是多么容易。这种模式在AJAX中大量使用，当你在AJAX调用完成后，传递回调函数处理成功或失败的场景时。 2. 关于参数的更多内容JavaScript是非常灵活的，当涉及到传递或访问函数参数的时候。让我们看一下函数参数可以被操纵的方式。 2.1 缺少参数调用函数时，函数的参数数量可以比要求的更少或更多。如果你调用的函数的参数比声明的少，那么缺少的参数被设置为undefined。 12345678function callMe(a, b, c) &#123; console.log(\"c is \" + typeof c);&#125; callMe(\"Code\", \"Morning\"); // Output: \"c is undefined\"callMe(\"Learn\", \"JavaScript\", \"Functions\"); // Output: \"c is string\" 2.2 Arguments对象所有的JavaScript函数有一个特殊的对象，叫做arguments，它是在函数调用过程中传递的参数数组。该对象可以被用来访问单个参数或获得传递到函数的参数总数。 1234567function callMe() &#123; var i; for (i = 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125; console.log(\"Total arguments passed: \" + arguments.length);&#125; 此函数假设没有传递任何参数，但就像我说的，你可以传递任何数量的参数到JavaScript函数。我可以像这样调用这个函数： 123456callMe(\"Code\", \"Morning\", \"Mr. Programmer\");// Output\":// Code// Morning// Mr. Programmer// Total arguments passed: 3 每个参数可以从arguments对象作为一个数组项被访问。被传递给函数的arguments的总数可从arguments.length属性获得。 2.3 默认参数你是C ++或C#程序员吗？你见过使用默认参数的函数吗？也许你会回答yes！ ECMAScript 6带来了JavaScript的这一特性，就是你可以定义带有默认参数的函数。 123function greetMyVisitors(name, profession = \"The cool programmer\") &#123; alert(\"Welcome Mr. \" + name + \", \" + profession);&#125; 该函数有礼貌地地迎接了博客访问者。它有两个参数name 和profession，并在消息框中显示一个欢迎消息。如果在调用过程中没有参数（或“undefined”）传递，那么第二个参数取用默认值。 12345678greetMyVisitors(\"Justin Bieber\", \"The singer\"); // Shows the message \"Welcome Mr. Justin Bieber, The singer\" greetMyVisitors(\"Bob Martin\"); // Shows the message \"Welcome Mr. Bob Martin, The cool programmer\" greetMyVisitors(\"John Papa\", undefined); // Shows the message \"Welcome Mr. John Papa, The cool programmer\" 3. 嵌套函数函数可以在它的内部包含一个或多个函数。内部函数可能会在内部再次包含函数。让我们来看看以下操作。 123456789101112131415161718function wakeUpAndCode() &#123; function wakeUp() &#123; console.log(\"I just woke up\"); &#125; function code() &#123; console.log(\"I am ready to code now\"); &#125; wakeUp(); code();&#125; wakeUpAndCode(); // Output:// I just woke up// I am ready to code now 函数wakeUpAndCode包含两个内部函数wakeUp和code。当调用wakeUpAndCode时，函数主体开始执行函数主体。在外部函数中只有两个可执行语句，调用wakeUp和code的方法。调用wakeUp将执行内部wakeUp函数，这将写入string“I just woke up”到控制台。调用code将会写入“I am ready to code now”string到控制台。 内部函数可以访问所有外部函数的变量和参数。内部函数是函数内部某种private实现，并且不能从外部函数以外被调用。内部函数的使用生成了JavaScript闭包，这个我将另起一篇文章讨论。 4. 立即执行函数表达式（IIFE）IIFE是被立即调用执行的匿名函数表达式。IIFE看上去像这样： 123(function() &#123; // Your awesome code here&#125;()); 所有你要做的就是创建一个匿名函数，在函数定义后马上放一对圆括号以调用函数，最后将所有代码封装在另一对圆括号中。最外层的括号将它里面的所有一切转变成一个表达式，因为括号不能包含JavaScript语句。函数定义后面的圆括号则立即调用函数。 IIFE块中定义的任何变量或函数对块而言是本地的，并且不能被这个范围以外的任何代码改变。 看看IIFE的这个例子。此函数没有调用也会自动执行。 123(function() &#123; console.log(\"I run on my own.\");&#125;()); 只需在plunker中复制并粘贴代码，看看在浏览器控制台中的输出。如果你不知道去哪里找浏览器控制台，那么只要在浏览器窗口中按下F12就会出现开发者工具。跳转console选项卡以查看console.log语句的所有输出。 IIFE是一个在代码中创建局部范围的很好方法。它们可以帮助你保护变量和函数，以避免被应用程序的其他部分更改或覆盖。JavaScript中IIFE的其他优势？它们是如何解决全局范围污染问题的？欢迎点击查看我关于立即执行函数表达式的文章。 5. 构造函数函数可以充当构造器的角色，并且可以使用构造函数来创建新的对象。这是使JavaScript面向对象的特点之一。使用构造函数的好处是，你将能够通过预定义的属性和方法，创造尽可能多的对象。如果你由此关联到其他语言中的类和对象，那么你做的对。 让我们创建一个带有一些属性和方法的构造函数Programmer。你可以假设它在你最喜欢的语言中是一个类。 123456789101112131415161718192021function Programmer(name, company, expertise) &#123; this.name = name; this.company = company; this.expertise = expertise; this.writeCode = function() &#123; console.log(\"Writing some public static thing..\"); &#125; this.makeSkypeCall = function() &#123; console.log(\"Making skype call..\"); &#125; this.doSalsa = function() &#123; console.log(\"I'm a programmer, I can only do Gangnam style..\"); &#125; this.canWriteJavaScript = function() &#123; return expertise === \"JavaScript\"; &#125;&#125; 函数有三个参数，并创建了一个具有三个属性和四种方法的对象。我不认为上面的代码需要任何解释。此外，我可以创建任意数量程序员对象。 12var javaProgrammer = new Programmer(\"Mohit Srivastava\", \"Infosys\", \"Java\");var dotnetProgrammer = new Programmer(\"Atul Mishra\", \"Prowareness\", \".NET\"); 虽然也可以创建一个使用对象文本语法带有相同属性和方法的对象，但我们需要多次编写相同的代码，这可不是什么伟大的实践。如果你知道编程DRY原则，那么你就不会不赞同我。构造函数使得可以一次定义对象，并创建真正的实例，无论什么时候你想要。 注意： 始终使用new关键字来从构造器创建新的对象。忘记了new而像这个创建一个实例： 1var jsProgrammer = Programmer(\"Douglas Crockford\", \"Yahoo\", \"JavaScript\") 最终将添加所有属性和方法到全局的window对象，哇哦，这将是太可怕了。原因是，除非明确指定，否则“this”指向全局的window对象。使用new 设置“this”上下文到被创建的当前对象。 然而，有一种变通方法可以来克服这个问题。你可以改变构造函数的实现以使域安全，然后在创建新的对象时，你就可以愉快地忽略new 关键字了。请参见以下修改了的构造函数代码。为了便于查看，我已删除了一些方法。 12345678910111213function Programmer(name, company, expertise) &#123; if(!(this instanceof Programmer)) &#123; return new Programmer(name, company, expertise); &#125; this.name = name; this.company = company; this.expertise = expertise; this.writeCode = function() &#123; console.log(\"Writing some public static thing..\"); &#125;&#125; if 条件检查了this 对象是否是Programmer的一个实例。如果不是，它会创建一个新的Programmer对象，并通过再次调用构造器返回相同的内容。 注意：你无法在不使用’new’关键字的情况下，在Strict模式下从构造器创建一个新的对象。Strict模式强制一些编码准则，并且在你写的东西不安全的情况下会抛出错误。要启用Strict模式，你只需要添加在你的代码开头添加字符串 ‘use strict’。在Strict模式下运行代码是一个良好的实践，可以查看我的另一篇文章JavaScript 严格模式（strict）了解更多。 123456'use strict' function doSomething() &#123; //...&#125; //.... //.... 结语在这篇文章中，我几乎已经涵盖了有关函数的所有内容。函数被认为是JavaScript中的一等公民。如果你想掌握JavaScript的话，理解函数可能是最重要的事情。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JavaScript 实现继承的方式","slug":"article-js-prototype-method","date":"2017-04-09T02:41:15.000Z","updated":"2021-06-24T04:02:41.970Z","comments":true,"path":"2017/04/09/article-js-prototype-method/","link":"","permalink":"https://doubleray.top/2017/04/09/article-js-prototype-method/","excerpt":"这篇文章主要介绍 JavaScript 实现继承的方式： 类式继承 构造函数继承 组合继承 寄生组合式继承 extends继承 本文参考TG-路虽远，无所畏 的JavaScript实现继承的方式。","text":"这篇文章主要介绍 JavaScript 实现继承的方式： 类式继承 构造函数继承 组合继承 寄生组合式继承 extends继承 本文参考TG-路虽远，无所畏 的JavaScript实现继承的方式。 1. 类式继承简单的类式继承： 123456789101112131415161718// 声明父类function Animal() &#123; this.name = 'animal'; this.type = ['pig', 'cat'];&#125;// 为父类添加共有方法Animal.prototype.greet = function(sound) &#123; console.log(sound);&#125;// 声明子类function Dog() &#123; this.name = 'dog';&#125;// 继承父类Dog.prototype = new Animal();var dog = new Dog();dog.greet('汪汪'); // \"汪汪\"console.log(dog.type); // [\"pig\", \"cat\"] 在上面的代码中，我们创建了两个类Animal和Dog，而且给Animal.prototype原型上添加了一个greet共有方法，然后通过new命令实例化一个Animal，并且赋值给Dog.prototype原型。 原理说明：在实例化一个类时，新创建的对象复制了父类的构造函数内的属性与方法并且将原型__proto__指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法。 不过，通过类式继承方式，有两个缺点: 第一个是引用缺陷： 123dog.type.push('dog');var dog2 = new Dog();console.log(dog2.type); // [\"dog\", \"cat\", \"dog\"] 通过上面的执行结果，我们看到当通过dog实例对象修改继承自Animal中的数组type(引用类型)时，另外一个新创建的实例dog2也会受到影响。 第二个是我们无法为不同的实例初始化继承来的属性，我们可以修改一下上面的例子： 123456function Animal(color) &#123; this.color = color;&#125;Dog.prototype = new Animal('白色');console.log(dog.color); // \"白色\"console.log(do2.color); // \"白色\" 通过上面的代码可以看到，我们无法为不同dog赋值不同的颜色，所有dog只能同一种颜色。 2. 构造函数继承构造函数继承方式可以避免类式继承的缺陷： 1234567891011121314151617// 添加共有方法Animal.prototype.greet = function(sound) &#123; console.log(sound);&#125;// 声明子类function Dog(color) &#123; Animal.apply(this, arguments);&#125;var dog = new Dog('白色');var dog2 = new Dog('黑色');dog.type.push('dog');console.log(dog.color); // \"白色\"console.log(dog.type); // [\"pig\", \"cat\", \"dog\"]console.log(dog2.type); // [\"pig\", \"cat\"]console.log(dog2.color); // \"黑色\" 首先要知道apply方法的运用，它是可以更改函数的作用域，所以在上面的例子中，我们在Dog子类中调用这个方法也就是将Dog子类的变量在父类中执行一遍，这样子类就拥有了父类中的共有属性和方法。 但是，构造函数继承也是有缺陷的，那就是我们无法获取到父类的共有方法，也就是通过原型prototype绑定的方法： 1dog.greet(); // Uncaught TypeError: dog.greet is not a function 3. 组合继承组合继承其实就是将类式继承和构造函数继承组合在一起： 12345678910111213141516171819202122232425// 声明父类 function Animal(color) &#123; this.name = 'animal'; this.type = ['pig','cat']; this.color = color; &#125;// 添加共有方法 Animal.prototype.greet = function(sound) &#123; console.log(sound); &#125;// 声明子类 function Dog(color) &#123; // 构造函数继承 Animal.apply(this, arguments); &#125; // 类式继承Dog.prototype = new Animal(); var dog = new Dog('白色'); var dog2 = new Dog('黑色'); dog.type.push('dog'); console.log(dog.color); // \"白色\"console.log(dog.type); // [\"pig\", \"cat\", \"dog\"]console.log(dog2.type); // [\"pig\", \"cat\"]console.log(dog2.color); // \"黑色\"dog.greet('汪汪'); // \"汪汪\" 在上面的例子中，我们在子类构造函数中执行父类构造函数，在子类原型上实例化父类，这就是组合继承了，可以看到它综合了类式继承和构造函数继承的优点，同时去除了缺陷。 可能你会奇怪为什么组合式继承可以去除类式继承中的引用缺陷？其实这是由于原型链来决定的，由于JavaScript引擎在访问对象的属性时，会先在对象本身中查找，如果没有找到，才会去原型链中查找，如果找到，则返回值，如果整个原型链中都没有找到这个属性，则返回undefined。 也就是说，我们访问到的引用类型(比如上面的type)其实是通过apply复制到子类中的，所以不会发生共享。 这种组合继承也是有点小缺陷的，那就是它调用了两次父类的构造函数。 4. 寄生组合式继承寄生组合式继承强化的部分就是在组合继承的基础上减少一次多余的调用父类的构造函数： 1234567891011121314151617181920212223242526function Animal(color) &#123; this.color = color; this.name = 'animal'; this.type = ['pig', 'cat'];&#125;Animal.prototype.greet = function(sound) &#123; console.log(sound);&#125;function Dog(color) &#123; Animal.apply(this, arguments); this.name = 'dog';&#125;/* 注意下面两行 */Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.getName = function() &#123; console.log(this.name);&#125;var dog = new Dog('白色'); var dog2 = new Dog('黑色'); dog.type.push('dog'); console.log(dog.color); // \"白色\"console.log(dog.type); // [\"pig\", \"cat\", \"dog\"]console.log(dog2.type); // [\"pig\", \"cat\"]console.log(dog2.color); // \"黑色\"dog.greet('汪汪'); // \"汪汪\" 在上面的例子中，我们并不像构造函数继承一样直接将父类Animal的一个实例赋值给Dog.prototype，而是使用Object.create()进行一次浅拷贝，将父类原型上的方法拷贝后赋给Dog.prototype，这样子类上就能拥有了父类的共有方法，而且少了一次调用父类的构造函数。 Object.create()的浅拷贝的作用类式下面的函数： 12345function create(obj) &#123; function F() &#123;&#125;; F.prototype = obj; return new F();&#125; 这里还需注意一点，由于对Animal的原型进行了拷贝后赋给Dog.prototype，因此Dog.prototype上的constructor属性也被重写了，所以我们要修复这一个问题： 1Dog.prototype.constructor = Dog; 5. extends继承 Class和extends是在ES6中新增的，Class用来创建一个类，extends用来实现继承： 1234567891011121314151617class Animal &#123; constructor(color) &#123; this.color = color; &#125; greet(sound) &#123; console.log(sound); &#125; &#125; class Dog extends Animal &#123; constructor(color) &#123; super(color); this.color = color; &#125; &#125; let dog = new Dog('黑色'); dog.greet('汪汪'); // \"汪汪\"console.log(dog.color); // \"黑色\" 在上面的代码中，创建了父类Animal，然后Dog子类继承父类，两个类中都有一个constructor构造方法，实质就是构造函数Animal和Dog。 不知道你有没有注意到一点，我在子类的构造方法中调用了super方法，它表示父类的构造函数，用来新建父类的this对象。 注意：子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JS 构造函数内的方法与构造函数prototype属性上方法的对比","slug":"article-js-constructor-vs-prototype","date":"2017-04-08T02:41:15.000Z","updated":"2021-06-24T04:02:41.965Z","comments":true,"path":"2017/04/08/article-js-constructor-vs-prototype/","link":"","permalink":"https://doubleray.top/2017/04/08/article-js-constructor-vs-prototype/","excerpt":"最近用面向对象的思路写一个小小的H5小游戏，对之前零散的知识点进行了一下总结，本文的目的是让大家理解什么情况下把函数的方法写在JavaScript的构造函数上,什么时候把方法写在函数的prototype属性上;以及这样做的好处。 为了阅读方便,我们约定一下:把方法写在构造函数内的情况我们简称为函数内方法,把方法写在prototype属性上的情况我们简称为prototype上的方法。","text":"最近用面向对象的思路写一个小小的H5小游戏，对之前零散的知识点进行了一下总结，本文的目的是让大家理解什么情况下把函数的方法写在JavaScript的构造函数上,什么时候把方法写在函数的prototype属性上;以及这样做的好处。 为了阅读方便,我们约定一下:把方法写在构造函数内的情况我们简称为函数内方法,把方法写在prototype属性上的情况我们简称为prototype上的方法。 首先我们先了解一下这篇文章的重点: 函数内的方法: 使用函数内的方法我们可以访问到函数内部的私有变量,如果我们通过构造函数new出来的对象需要我们操作构造函数内部的私有变量的话,我们这个时候就要考虑使用函数内的方法. prototype上的方法: 当我们需要通过一个函数创建大量的对象,并且这些对象还都有许多的方法的时候;这时我们就要考虑在函数的prototype上添加这些方法.这种情况下我们代码的内存占用就比较小. 在实际的应用中,这两种方法往往是结合使用的;所以我们要首先了解我们需要的是什么,然后再去选择如何使用. 我们还是根据下面的代码来说明一下这些要点吧,下面是代码部分: 12345678910111213141516171819202122232425// 构造函数Afunction A(name) &#123; this.name = name || 'a'; this.sayHello = function() &#123; console.log('Hello, my name is: ' + this.name); &#125;&#125;// 构造函数Bfunction B(name) &#123; this.name = name || 'b';&#125;B.prototype.sayHello = function() &#123; console.log('Hello, my name is: ' + this.name);&#125;;var a1 = new A('a1');var a2 = new A('a2');a1.sayHello();a2.sayHello();var b1 = new B('b1');var b2 = new B('b2');b1.sayHello();b2.sayHello(); 我们首先写了两个构造函数,第一个是A,这个构造函数里面包含了一个方法sayHello;第二个是构造函数B,我们把那个方法sayHello写在了构造函数B的prototype属性上面. 需要指出的是,通过这两个构造函数new出来的对象具有一样的属性和方法,但是它们的区别我们可以通过下面的一个图来说明: 我们通过使用构造函数A创建了两个对象,分别是a1,a2;通过构造函数B创建了两个对象b1,b2;我们可以发现b1,b2这两个对象的那个sayHello方法都是指向了它们的构造函数的prototype属性的sayHello方法.而a1,a2都是在自己内部定义了这个方法。 定义在构造函数内部的方法,会在它的每一个实例上都克隆这个方法;定义在构造函数的prototype属性上的方法会让它的所有示例都共享这个方法,但是不会在每个实例的内部重新定义这个方法. 如果我们的应用需要创建很多新的对象,并且这些对象还有许多的方法,为了节省内存,我们建议把这些方法都定义在构造函数的prototype属性上 当然,在某些情况下,我们需要将某些方法定义在构造函数中,这种情况一般是因为我们需要访问构造函数内部的私有变量. 下面我们举一个两者结合的例子,代码如下: 1234567891011121314151617181920212223242526272829303132333435function Person(name, family) &#123; this.name = name; this.family = family; var records = [&#123;type: \"in\", amount: 0&#125;]; this.addTransaction = function(trans) &#123; if(trans.hasOwnProperty(\"type\") &amp;&amp; trans.hasOwnProperty(\"amount\")) &#123; records.push(trans); &#125; &#125; this.balance = function() &#123; var total = 0; records.forEach(function(record) &#123; if(record.type === \"in\") &#123; total += record.amount; &#125; else &#123; total -= record.amount; &#125; &#125;); return total; &#125;;&#125;;Person.prototype.getFull = function() &#123; return this.name + \" \" + this.family;&#125;;Person.prototype.getProfile = function() &#123; return this.getFull() + \", total balance: \" + this.balance();&#125;; 在上面的代码中,我们定义了一个Person构造函数;这个函数有一个内部的私有变量records,这个变量我们是不希望通过函数内部以外的方法去操作这个变量,所以我们把操作这个变量的方法都写在了函数的内部.而把一些可以公开的方法写在了Person的prototype属性上,比如方法getFull和getProfile. 把方法写在构造函数的内部,增加了通过构造函数初始化一个对象的成本,把方法写在prototype属性上就有效的减少了这种成本. 你也许会觉得,调用对象上的方法要比调用它的原型链上的方法快得多,其实并不是这样的,如果你的那个对象上面不是有很多的原型的话,它们的速度其实是差不多的 另外,需要注意的一些地方: 首先如果是在函数的prototype属性上定义方法的话,要牢记一点,如果你改变某个方法,那么由这个构造函数产生的所有对象的那个方法都会被改变. 还有一点就是变量提升的问题,我们可以稍微的看一下下面的代码: 123456789func1(); // 这里会报错,因为在函数执行的时候,func1还没有被赋值. error: func1 is not a functionvar func1 = function() &#123; console.log('func1');&#125;;func2(); // 这个会被正确执行,因为函数的声明会被提升.function func2() &#123; console.log('func2');&#125; 关于对象序列化的问题.定义在函数的prototype上的属性不会被序列化,可以看下面的代码: 1234567function A(name) &#123; this.name = name;&#125;A.prototype.sayWhat = 'say what...';var a = new A('dreamapple');console.log(JSON.stringify(a)); 我们可以看到输出结果是{&quot;name&quot;:&quot;dreamapple&quot;}","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"CSS 奇巧淫技","slug":"article-css3-skills-effects","date":"2017-03-26T04:19:15.000Z","updated":"2021-06-24T04:02:41.957Z","comments":true,"path":"2017/03/26/article-css3-skills-effects/","link":"","permalink":"https://doubleray.top/2017/03/26/article-css3-skills-effects/","excerpt":"能使用html/css解决的问题就不要使用JS，为什么呢？ 两个字，因为简单。简单就意味着更快的开发速度，更小的维护成本，同时往往具有更好的体验(但是也不要太局限于这个思路，好的方法是适用才好，而不是为了追求性能而性能)，JS 几乎可以做任何事情，但是有时候会显得十分笨拙，在js/html/css三者间灵活地切换，往往会极大地简化开发，没有谁是最好的语言，只有适不适合。只要用得好，不管黑猫白猫，都是好猫。下面总结几个实例。","text":"能使用html/css解决的问题就不要使用JS，为什么呢？ 两个字，因为简单。简单就意味着更快的开发速度，更小的维护成本，同时往往具有更好的体验(但是也不要太局限于这个思路，好的方法是适用才好，而不是为了追求性能而性能)，JS 几乎可以做任何事情，但是有时候会显得十分笨拙，在js/html/css三者间灵活地切换，往往会极大地简化开发，没有谁是最好的语言，只有适不适合。只要用得好，不管黑猫白猫，都是好猫。下面总结几个实例。 1. 自定义radio/checkbox的样式 我们知道，使用原生的radio/checkbox是不可以改变它的样式的，得自己用div/span去画，然后再去监听点击事件。但是这样需要自己去写逻辑控制，例如radio只能选一个的功能，另一个是没有办法使用change事件。就是没有用原生的方便。 但是实际上可以用一点CSS3的技巧实现自定义的目的，如下，就是用原生实现的radio： 这个主要是借助了CSS3提供的一个伪类:checkd，只要radio/checkbox是选中状态，这个伪类就会生效，因此可以利用选中和非选中的这两种状态，去切换不同的样式。如下把一个checkbox和一个用来自定义样式的span写在一个label里面，checkbox始终隐藏： 12345678910111213&lt;style&gt;input[type=checkbox]&#123; display: none;&#125;/*未选中的checkbox的样式*/.checkbox&#123; &#125;&lt;/style&gt;&lt;label&gt; &lt;input type=\"checkbox\"&gt; &lt;span class=\"checkbox\"&gt;&lt;/span&gt;&lt;/label&gt; 写在label里面是为了能够点击span的时候改变checkbox的状态，然后再改一下选中态的样式即可： 123input[type=checkbox]:checked + .checkbox&#123; ...&#125; 关键在于这一步，添加一个打勾的背景图也好，使用图标字体也好。 :checked兼容性还是比较好的，只要你不用兼容IE8就可以使用，或者说只要你可以用nth-of-type，就可以用:checked 2. 多列等高 多列等高的问题是这样的，排成一行的几列由于内容长短不一致，导致容器的高度不一致： 你可以用js算一下，以最高的一列的高度去设置所有列的高度，然而这个会造成页面闪动，刚开始打开页面的时候高度不一致，然后发现突然又对齐了。这个解决办法主要有两种： 第一种是利用CSS 伸缩盒布局，如下： 1234567891011121314151617181920&lt;style&gt; .wrapper &#123; display: flex; flex-direction: row &#125; .wrapper&gt;div &#123; width: 150px; margin: 0 10px; text-align: center; background-color: #ececec; border: 1px solid #ccc; &#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;div&gt;column 1&lt;/div&gt; &lt;div&gt;column 2&lt;/div&gt; &lt;div&gt;column 3&lt;/div&gt; &lt;div&gt;column 4&lt;/div&gt;&lt;/div&gt; 效果如下： 效果不错，只是兼容性你懂的，其他的关于flexbox的内容可以移步Flex布局新旧混合写法详解。 第二种办法是借助table的自适应特性: 每个div都是一个td，td肯定是等高的，html结构不变，CSS改一下： 12345678910.wrapper&#123; display: table; border-spacing: 20px; /* td间的间距*/&#125; .wrapper &gt; div &#123; display: table-cell; width: 1000px; /*设置很大的宽度，table自动平分宽度 */ border-radius: 5px; &#125; 3. 需要根据个数显示不同样式 例如说可能有1~3个item显示在同一行，而item的个数不一定，如果1个，那这个item占宽100%，2个时每一个50%，3个时每一个33%，这个你也可以用js计算一下，但是用CSS3就可以解决这个问题： 12345678910111213141516171819&lt;style&gt; li&#123; width: 100%; &#125; li:first-child:nth-last-child(2), li:first-child:nth-last-child(2) ~ li&#123; width: 50%; &#125; li:first-child:nth-last-child(3), li:first-child:nth-last-child(3) ~ li&#123; width: 33%; &#125; &lt;/style&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 第5行的意思就是选择li的第一个元素，并且它是倒数第二个元素，第6行的意思是选择前面有是第一个且是倒数第二个li的所有li，第一行是选择了第一个，第二行选择除第一个外的其它所有元素。有三个元素的类似。 4. 巧用CSS3伪类 CSS3的伪类提供了状态切换，除了第3点提到的checked之外，还有其它几个很好用的，例如:focus、:invalid等; 例如下面的效果：focus的时候把左边的放大镜颜色加深： 借用:focus实现： 12345678910111213&lt;style&gt; /*正常状态为浅灰色*/ .icon-search&#123; color: #ccc; &#125; /*input focus时为深灰色 */ input[type=search]:focus + .icon-search&#123; color: #111; &#125;&lt;/style&gt; &lt;input type=\"search\"&gt;&lt;span class=\"icon-search\"&gt;&lt;/span&gt; 再如，如果用户输入不合法，则下一步是半透明不可点的状态： 实现这一步可以用html5的input和css3的:invalid 1234567&lt;style&gt; input[type=email]:invalid + .next-step&#123; opacity: 0.5; &#125;&lt;/style&gt;&lt;input type=\"email\"&gt;&lt;span class=\"next-step\"&gt;Next&lt;/span&gt; 通过input的type和pattern属性约束合法性，然后触发:invalid。 5. 自动监听回车事件（HTML） 这个的场景是希望按回车的时候能够触发请求，或者按回车实现跳转，或者是按下回车就送一条聊天消息。 通常的做法是监听下keypress事件，然后检查一下keycode是不是回车，如果是则发请求。 但是其实有个特别简单的办法，也是不需要一行JS，那就是把表单写在一个form里面，按回车会自动触发submit事件。读者可以自己试试。这个就启示我们要用语义的html组织，而不是全部都用div。如果用相应的html标签，浏览器会自动做一些优化，特别是表单提交的input。","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"JavaScript 闭包可被利用的常见场景","slug":"article-js-closureuse","date":"2017-03-17T16:41:15.000Z","updated":"2021-06-24T04:02:41.964Z","comments":true,"path":"2017/03/18/article-js-closureuse/","link":"","permalink":"https://doubleray.top/2017/03/18/article-js-closureuse/","excerpt":"闭包（Closures）在 JavaScript 这类支持现代函式编程（FP，Functional Programming）的语言中非常普遍。到底什么是闭包?由于一个函式本身作为一级对象（first-class object），就像传统 OOP 中的对象一样，可以出现在任何一个值（value）允许出现的地方，因此只要你在一个（父）函式的内部声明、创建或者返回了一个新（子）函式，都有可能获得一个闭包。 下面介绍几种常见的场景。","text":"闭包（Closures）在 JavaScript 这类支持现代函式编程（FP，Functional Programming）的语言中非常普遍。到底什么是闭包?由于一个函式本身作为一级对象（first-class object），就像传统 OOP 中的对象一样，可以出现在任何一个值（value）允许出现的地方，因此只要你在一个（父）函式的内部声明、创建或者返回了一个新（子）函式，都有可能获得一个闭包。 下面介绍几种常见的场景。 采用函数引用方式的setTimeout调用 闭包的一个通常的用法是为一个在某一函数执行前先执行的函数提供参数。例如，在web环境中，一个函数作为setTimeout函数调用的第一个参数，是一种很常见的应用。 setTimeout将要执行的函数(或者一段javascript代码，但这不是我们要讨论的情况)作为它的第一个参数，下一个参数是需要延迟执行的时间。如果一段代码想通过setTimeout来调用，那么它需要传递一个函数对象的引用来作为第一个参数。延迟的毫秒数作为第二个参数，但这个函数对象的引用无法为将要被延迟执行的对象提供参数。 但是，可以调用另一个函数来返回一个内部函数的调用，将那个内部函数对象的引用传递给setTimeout函数。内部函数执行时需要的参数，在调用外部函数时传递给它。setTimeout在执行内部函数时无需传递参数，因为内部函数仍然能够访问外部函数调用时提供的参数： 1234567891011121314151617181920function callLater(paramA, paramB, paramC) &#123; /*使用函数表达式创建并放回一个匿名内部函数的引用*/ return (function () &#123; /* 这个内部函数将被setTimeout函数执行； 并且当它被执行时， 它能够访问并操作外部函数传递过来的参数 */ paramA[paramB] = paramC; &#125;);&#125; /*调用这个函数将在它的执行上下文中创建，并最终返回内部函数对象的引用传递过来的参数，内部函数在最终被执行时，将使用外部函数的参数返回的引用被赋予了一个变量*/var funcRef = callLater(elStyle, \"display\", \"none\");/*调用setTimeout函数，传递内部函数的引用作为第一个参数*/hideMenu = setTimeout(funcRef, 500); 将函数关联到对象的实例方法 有很多这样的场景：需要分配一个函数对象的引用，以便在未来的某个时间执行该函数。那么闭包对于为这个将要执行的函数提供引用会非常有帮助。因为该函数可能直到执行时才能够被访问。 有一个例子就是，一个javascript对象被封装用来参与一个特定DOM元素的交互。它有doOnClick、doMouseOver以及doMouseOut方法。并且想在DOM元素上对应的事件被触发时执行这些方法。但是，可能会有关联着DOM元素的任意数量的javascript对象被创建，并且单个的实例并不知道那些实例化它们的代码将如何处理它们。对象实例不知道怎样去“全局”地引用它们自己，因为它们不知道哪个全局变量(如果存在)的引用将被分配给它们。 所以，问题是执行一个与特定javascript对象实例关联的事件处理函数，并且知道调用那个对象的哪个方法。 接下来的一个例子，在有元素事件处理的对象实例的关联函数上使用一个简单的闭包。通过传递event对象以及要关联元素的一个引用，为事件处理器分配不同的对象实例方法以供调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*一个给对象实例关联一个事件处理器的普通方法，返回的内部函数被作为事件的处理器，对象实例被作为obj参数，对象上将要被调用的方法名称被作为第二个参数*/function associateObjWithEvent(obj, methodName) &#123; /*返回的内部函数被用来作为一个DOM元素的事件处理器*/ return (function (e) &#123; /* 事件对象在DOM标准的浏览器中将被转换为e参数， 如果没有传递参数给事件处理内部函数，将统一处理成IE的事件对象 */ e = e || window.event; /* 事件处理器调用obj对象上的以methodName字符串标识的方法 并传递两个对象：通用的事件对象，事件处理器被订阅的元素的引用 这里this参数能够使用，因为内部函数已经被执行作为事件处理器所在元素的一个方法 */ return obj[methodName](e, this); &#125;);&#125; /*这个构造器函数，通过将元素的ID作为字符串参数传递进来，来创建将自身关联到DOM元素上的对象，对象实例想在对应的元素触发onclick、onmouseover、onmouseout事件时对应的方法被调用。*/function DhtmlObject(elementId) &#123; /* 调用一个方法来获得一个DOM元素的引用 如果没有找到，则为null */ var el = getElementWith(elementId); /* 因为if语句块，el变量的值在内部进行了类型转换，变成了boolean类型 所以当它指向一个对象，结果就为true,如果为null则为false */ if (el) &#123; /* 为了给元素指定一个事件处理函数，调用了associateObjWithEvent函数， 利用它自己(this关键字)作为被调用方法的对象，并且提供方法名称 */ el.onclick = associateObjWithEvent(this, \"doOnClick\"); el.onmouseover = associateObjWithEvent(this, \"doOnMouseOver\"); el.onmouseout = associateObjWithEvent(this, \"doOnMouseOut\"); &#125;&#125; DhtmlObject.prototype.doOnClick = function (event, element) &#123; //doOnClick body&#125;DhtmlObject.prototype.doMouseOver = function (event, element) &#123; //doMouseOver body&#125; DhtmlObject.prototype.doMouseOut = function (event, element) &#123; //doMouseOut body&#125; 任何DhtmlObject的实例都能够将它们自身关联到它们感兴趣的DOM元素上去，不需要去担心这些元素将被其他的代码怎么处理，以及被全局命名空间“污染”或者与其他的DhtmlObject的实例产生冲突。 封装相关的功能集 闭包可以创建额外的scope，这可以被用来组合相关的或有依赖性的代码。用这种方式可以最大限度地减少代码干扰的危害。假设，一个函数被用来创建一个字符串并且避免重复串联的操作(比如创建一系列的中间字符串)。一个想法是，用一个数组来顺序存储字符串的一部分，然后使用Array.prototype.join方法输出结果(使用一个空字符串作为它的参数)。数组将扮演着输出缓冲区的角色，但局部定义它又将会导致它在函数的每次执行时再次创建。如果这个数组只是作为唯一的变量被分配给每一个函数调用，这将会有点小题大做。 一个解决方案是将数组提升为全局变量，让它不需要被再次创建也能够再次使用。但结果并不是想的那么简单，另外，一个全局变量关联这使用缓冲数组的函数，那将会有第二个全局属性(函数本身也是window对象的属性)关联这个数组，这将让代码失去一定的可控性。因为如果将它使用在其他地方。这段代码的创建者不得不记住包含函数的定义以及数组的定义逻辑。它也使得代码不那么容易与其他代码整合，因为将从原来只需要确定函数名是否在全局命名空间中唯一，变成有必要确定和该函数关联的数组的名称是否在全局命名空间中保持唯一。 一个闭包可以让缓冲数组关联(干净地包含)它依赖的函数，并且同时保持缓冲数组的属性名称，像被分配在全局空间中一样，同时能够避免名称冲突以及代码交互干扰的危险。 这里有一招就是通过执行一个内联的函数表达式创建一个额外的执行上下文，让那个函数表达式返回一个内联的函数，该函数被外部代码使用。缓冲数组被定义在内联执行的函数表达式中，作为一个局部变量。它仅被调用一次，所以该数组只被创建一次。但是对于依赖它的函数来说该数组是一直可访问的，并且可被重用的。 接一下的代码创建了一个函数，将返回一个HTML字符串，其中的一部分是不变的，但那些不变的字符串需要被穿插进作为参数传递进来的变量中。 一个内联执行的函数表达式返回了内部函数对象的一个引用。并且分配了一个全局变量，让它可以被作为一个全局函数来调用。而缓冲数组作为一个局部变量被定义在外部函数表达式中。它没有被扩展到全局命名空间中，并且无论函数什么时候使用它都不需要被再次创建。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 定义一个全局变量：getImgInPositionedDivHtml 被赋予对外部函数表达式一次调用返回的一个内部函数表达式 内部函数返回了一个HTML字符串，代表一个绝对定位的DIV 包裹这一个IMG元素，而所有的变量值都被作为函数调用的参数*/var getImgInPositionedDivHtml = (function () &#123; /* buffAr 数组被定义在外部函数表达式中，作为一个局部变量 它只被创建一次。数组的唯一实例对内部函数是可见的， 所以它可以被用于每一次的内部函数执行 空字符串仅仅被用来作为一个占位符，它将被内部函数的参数代替 */ var buffAr = [ '&lt;div id=\"', '', //index 1, DIV ID attribute '\" style=\"position:absolute;top:', '', //index 3, DIV top position 'px;left:', '', //index 5, DIV left position 'px;width:', '', //index 7, DIV width 'px;height:', '', //index 9, DIV height 'px;overflow:hidden;\\\"&gt;&lt;img src=\\\"', '', //index 11, IMG URL '\\\" width=\\\"', '', //index 13, IMG width '\\\" height=\\\"', '', //index 15, IMG height '\\\" alt=\\\"', '', //index 17, IMG alt text '\\\"&gt;&lt;\\/div&gt;' ]; /* 返回一个内部函数对象，他是函数表达式执行返回的结果 */ return (function (url, id, width, height, top, left, altText) &#123; /* 分配各种参数给对应的数组元素 */ buffAr[1] = id; buffAr[3] = top; buffAr[5] = left; buffAr[13] = (buffAr[7] = width); buffAr[15] = (buffAr[9] = height); buffAr[11] = url; buffAr[17] = altText; /* 返回连接每个元素后创建的字符串 */ return buffAr.join(''); &#125;);&#125;)(); 如果一个函数依赖另一个或几个函数，但那些其他的函数并不期望与任何其他的代码产生交互。那么这个简单的技巧(使用一个对外公开的函数来扩展那些函数)就可以被用来组织那些函数。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"rem 布局进阶篇","slug":"article-html-rem","date":"2017-03-06T05:13:05.000Z","updated":"2021-06-24T04:02:41.960Z","comments":true,"path":"2017/03/06/article-html-rem/","link":"","permalink":"https://doubleray.top/2017/03/06/article-html-rem/","excerpt":"相信很多刚开始写移动端页面的小伙伴都要面对页面自适应的问题，当然解决方案很多，比如：百分比布局，弹性布局flex（什么是flex），也都能获得不错的效果，这里主要介绍的是本人在实践中用的最顺手最简单的布局方案——rem 布局！ 之前写 rem 布局时首先引入的 JavaScript 代码 特别简单。但随着时间的推移，该方案已然过时，故为大家介绍一个目前我极力推荐使用的，更加完美的方案——rem 布局（进阶版）。","text":"相信很多刚开始写移动端页面的小伙伴都要面对页面自适应的问题，当然解决方案很多，比如：百分比布局，弹性布局flex（什么是flex），也都能获得不错的效果，这里主要介绍的是本人在实践中用的最顺手最简单的布局方案——rem 布局！ 之前写 rem 布局时首先引入的 JavaScript 代码 特别简单。但随着时间的推移，该方案已然过时，故为大家介绍一个目前我极力推荐使用的，更加完美的方案——rem 布局（进阶版）。 新方案的使用也是相当简单，把这段 原生JS 放到 HTML 的 head 标签中即可（注:不要手动设置viewport，该方案自动帮你设置） 1234567891011121314151617181920212223242526272829303132333435! function(e) &#123; function t(a) &#123; if (i[a]) return i[a].exports; var n = i[a] = &#123; exports: &#123;&#125;, id: a, loaded: !1 &#125;; return e[a].call(n.exports, n, n.exports, t), n.loaded = !0, n.exports &#125; var i = &#123;&#125;; return t.m = e, t.c = i, t.p = \"\", t(0)&#125;([function(e, t) &#123; \"use strict\"; Object.defineProperty(t, \"__esModule\", &#123; value: !0 &#125;); var i = window; t[\"default\"] = i.flex = function(e, t) &#123; var a = e || 100, n = t || 1, r = i.document, o = navigator.userAgent, d = o.match(/Android[\\S\\s]+AppleWebkit\\/(\\d&#123;3&#125;)/i), l = o.match(/U3\\/((\\d+|\\.)&#123;5,&#125;)/i), c = l &amp;&amp; parseInt(l[1].split(\".\").join(\"\"), 10) &gt;= 80, p = navigator.appVersion.match(/(iphone|ipad|ipod)/gi), s = i.devicePixelRatio || 1; p || d &amp;&amp; d[1] &gt; 534 || c || (s = 1); var u = 1 / s, m = r.querySelector('meta[name=\"viewport\"]'); m || (m = r.createElement(\"meta\"), m.setAttribute(\"name\", \"viewport\"), r.head.appendChild(m)), m.setAttribute(\"content\", \"width=device-width,user-scalable=no,initial-scale=\" + u + \",maximum-scale=\" + u + \",minimum-scale=\" + u), r.documentElement.style.fontSize = a / 2 * s * n + \"px\" &#125;, e.exports = t[\"default\"]&#125;]);flex(100, 1); 代码原理 这是阿里团队的高清方案布局代码，所谓高清方案就是根据设备屏幕的DPR（设备像素比，又称DPPX，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的 font-size, 同时根据设备 DPR 调整页面的缩放值，进而达到高清效果。 方案优势 引用简单，布局简便 根据设备屏幕的DPR,自动设置最合适的高清缩放。 保证了不同设备下视觉体验的一致性。（老方案是，屏幕越大元素越大；此方案是，屏幕越大，看的越多） 有效解决移动端真实1px问题（这里的1px 是设备屏幕上的物理像素） 使用方法 绝不是每个地方都要用rem，rem只适用于固定尺寸！ 在相当数量的布局情境中（比如底部导航元素平分屏幕宽，大尺寸元素），你必须使用百分比或者flex才能完美布局！ 此方案也是默认 1rem = 100px，所以你布局的时候，完全可以按照设计师给你的效果图写各种尺寸啦。比如你在效果图上量取的某个按钮元素长 55px, 宽37px ，那你直接可以这样写样式： 1234.btn &#123; width: .55rem; height: .37rem;&#125; 常见问题说明 1. 为什么效果图是要640或者750的，我非得弄个666的不行吗？ 老实说当然可以，不过为了规范，640或者750是相对合适的。 拿Iphone 5s 举例，它的css像素宽度是320px，由于它的dpr=2，所以它的物理像素宽度为320 × 2 = 640px，这也就是为什么，你在5s上截了一张图，在电脑上打开，它的原始宽度是640px的原因。 那 iphone 6 的截图宽度呢？ 375 × 2 = 750 那 iphone 6 sp 的截图宽度呢？ 414 × 3 = 1242 以此类推，你现在能明白效果图为什么一般是 640 ，750 甚至是 1242 的原因了么？（真没有歧视安卓机的意思。。。） 2. 宽度用 rem 写的情况下， 在 iphone6 上没问题， 在 iphone5上会有横向滚动条，何解？ 假设你的效果图宽度是750，在这个效果图上可能有一个宽度为7rem（高清方案默认 1rem = 100px）的元素。我们知道，高清方案的特点就是几乎完美还原效果图，也就是说，你写了一个宽度为 7rem 的元素，那么在目前主流移动设备上都是7rem。然而，iphone 5 的宽度为640，也就是6.4rem。于是横向滚动条不可避免的出现了。 怎么办呢？ 这是我目前推荐的比较安全的方式：如果元素的宽度超过效果图宽度的一半（效果图宽为640或750），果断使用百分比宽度，或者flex布局。就像把等屏宽的图片宽度设为100%一样。 3. 不是 1rem = 100px吗，为什么我的代码写了一个宽度为3rem的元素，在电脑端的谷歌浏览器上宽度只有150px? 先说高清方案代码，再次强调咱们的高清方案代码是根据设备的dpr动态设置html 的 font-size， 如果dpr=1(如电脑端），则html的font-size为50px，也就是 1rem = 50px 如果dpr=2(如iphone 5 和 6），则html的font-size为100px，也就是 1rem = 100px 如果dpr=3(如iphone 6 sp），则html的font-size为150px，也就是 1rem = 150px 如果dpr为其他值，即便不是整数，如3.4 , 也是一样直接将dpr 乘以 50 。 再来说说效果图，一般来讲，我们的效果图宽度要么是640，要么是750，无论哪一个，它们对应设备的dpr=2，此时，1 rem = 50 × 2 = 100px。这也就是为什么高清方案默认1rem = 100px。而将1rem默认100px也是好处多多，可以帮你快速换算单位，比如在750宽度下的效果图，某元素宽度为53px，那么css宽度直接设为53/100=0.53rem了。 然而极少情况下，有设计师将效果图宽定为 1242px，因为他手里只有一个 iphone 6 sp (dpr = 3)，设计完效果图刚好可以在他的 iphone 6 sp 里查看调整。一切完毕之后，他将这个效果图交给你来切图。由于这个效果图对应设备的 dpr=3,也就是1rem = 50 × 3 = 150px。所以如果你量取了一个宽度为 90px 的元素，它的css宽度应该为 90/150=0.6rem。因为咱们的高清方案默认 1rem=100px。所以为了还原效果图，你需要这样换算。当然，一个技巧就是你可以直接修改咱们的高清方案的默认设置。在代码的最后 你会看到 flex(100, 1) ，将其修改成 flex(150, 1)就不用那么麻烦的换算了，此时那个 90px 的直接写成 0.9rem 就可以了。 4. 高清方案在微信上，有时候字体会不受控制变的很大，怎么办？ 在 X5 新内核 Blink 中，在排版页面的时候，会主动对字体进行放大，会检测页面中的主字体，当某一块字体在我们的判定规则中，认为字号较小，并且是页面中的主要字体，就会采取主动放大的操作。然而这不是我们想要的，可以采取给最大高度解决。（经过项目实践，还是决定给 max-height 一个具体数值比较好，之前给的是 100% ，但有自身的局限性，比如 antd 的轮播组件在 max-height:100% 的情况下就不能正常显示。） 12345678910html,body,div,span,h1,h2,h3,h4,h5,h6,p,pre,a,blockquote,abbr,address,code,del,em,img,q,small,strong,sub,sup,var,b,i,dl,dt,dd,ul,ol,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,td,th&#123; border:0 none; font-size:inherit; color:inherit; margin:0; padding:0; vertical-align:baseline; /*给 max-height 一个具体数值解决在X5新内核Blink中在排版页面的时候，会主动对字体进行放大的问题*/ max-height: 100000px;&#125; （本文参考 minooo 的简书内容）未完待续 ··· 学习资料：移动端高清多屏适配的解决方案","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doubleray.top/tags/HTML/"}]},{"title":"文本溢出 text-overflow","slug":"article-css-ellipsis","date":"2017-03-02T12:19:15.000Z","updated":"2021-06-24T04:02:41.955Z","comments":true,"path":"2017/03/02/article-css-ellipsis/","link":"","permalink":"https://doubleray.top/2017/03/02/article-css-ellipsis/","excerpt":"有时我们会遇到当长文本超出他的容器时做文本溢出的处理，之前有一个比较 low 的 方法，用 jQuery 实现的（也是为了兼容性）。本文主要总结一下实现这个效果可用的方法及需要注意的小坑，方便日后查阅。","text":"有时我们会遇到当长文本超出他的容器时做文本溢出的处理，之前有一个比较 low 的 方法，用 jQuery 实现的（也是为了兼容性）。本文主要总结一下实现这个效果可用的方法及需要注意的小坑，方便日后查阅。 单行文本 如果实现单行文本的溢出显示省略号同学们应该都知道用text-overflow:ellipsis属性来，当然还需要加宽度width属来兼容部分浏览。 实现方法： 123456p&#123; /*display: block;需为块级元素*/ overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125; 效果如下： Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, animi beatae dicta dolorem excepturi facilis, illum maiores quia, repellat sit vero voluptate voluptates? Aspernatur et iusto, omnis qui quo velit. 多行文本方法一 实现方法： 123456p&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 效果如下： Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, animi beatae dicta dolorem excepturi facilis, illum maiores quia, repellat sit vero voluptate voluptates? Aspernatur et iusto, omnis qui quo velit. 适用范围： 因使用了 WebKit 的 CSS 扩展属性，该方法适用于 WebKit 浏览器及移动端； -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。 常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示； -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 方法二 实现方法： 12345678910111213141516p&#123; position: relative; line-height: 20px; max-height: 40px; overflow: hidden;&#125;p::after&#123; content: \"...\"; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%);&#125; 效果如下： .demo-css-ellipsis{position: relative;line-height: 20px;max-height: 60px;overflow: hidden;width: 300px}.demo-css-ellipsis::after{content: \"...\"; position: absolute;bottom: 0; right: 0;padding-left: 20px;background: -webkit-linear-gradient(left, transparent, #fff 35%);background: -moz-linear-gradient(right, transparent, #fff 35%);background: linear-gradient(to right, transparent, #fff 35%)} Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, animi beatae dicta dolorem excepturi facilis, illum maiores quia, repellat sit vero voluptate voluptates? Aspernatur et iusto, omnis qui quo velit. 适用范围： 该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合 js 优化该方法。 将height设置为line-height的整数倍，防止超出的文字露出。 给p::after添加渐变背景可避免文字只显示一半。 由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：&lt;span&gt;…&lt;span/&gt;）；兼容ie8需要将::after替换成:after。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"前端切图大法","slug":"article-ps-firework","date":"2017-03-01T10:13:05.000Z","updated":"2021-06-24T04:02:41.975Z","comments":true,"path":"2017/03/01/article-ps-firework/","link":"","permalink":"https://doubleray.top/2017/03/01/article-ps-firework/","excerpt":"作为一名“称职”的前端开发者，今天要“不知羞耻”的写一篇关于切图大法的总结，事情是这样的，就在前不久面试过程中有实操这么一个环节，面试官给了我一个很 easy 的 PSD 来让我完成一个简单的页面，本来半个小时四十分钟能解决的事情，我让 PS 愣给憋了半个小时（得亏面试官很 nice，当时真的是很尴尬），看来真是好记性不如烂键盘，所以也要劝诫大家不能忘了基本功啊。 现代互联网对交互设计越来越重视，切图早已经不是简单的使用 Photoshop 的切片工具对 JPG、PNG 等文件进行切片操作了。UI 设计师给出的设计稿往往会是 PSD 分层文件，这种文件中包含了更加丰富的图层、通道、路径等信息，也为更优雅的前端交互奠定了基础。所以我觉得现在的‘切图’更多的是一种思路。","text":"作为一名“称职”的前端开发者，今天要“不知羞耻”的写一篇关于切图大法的总结，事情是这样的，就在前不久面试过程中有实操这么一个环节，面试官给了我一个很 easy 的 PSD 来让我完成一个简单的页面，本来半个小时四十分钟能解决的事情，我让 PS 愣给憋了半个小时（得亏面试官很 nice，当时真的是很尴尬），看来真是好记性不如烂键盘，所以也要劝诫大家不能忘了基本功啊。 现代互联网对交互设计越来越重视，切图早已经不是简单的使用 Photoshop 的切片工具对 JPG、PNG 等文件进行切片操作了。UI 设计师给出的设计稿往往会是 PSD 分层文件，这种文件中包含了更加丰富的图层、通道、路径等信息，也为更优雅的前端交互奠定了基础。所以我觉得现在的‘切图’更多的是一种思路。 准备： Photoshop CC或CS6 一张 PSD 设计稿 1. 打开设计稿 先来简单熟悉一下 ps 的主界面： ① 为工具栏 ② 为画布 ③ 为图层操作面板 加载 PSD 文件时可能会遇到嵌入的配置文件不匹配、字体丢失等问题，不用理会，直接按确定键即可。 Tips：如果③图层工作区默认没有显示，点击 菜单栏&gt;窗口&gt;图层 即可打开 2. 分析设计稿 分析设计稿有哪些内容是需要进行切图保留的内容，主要内容考虑主要有以下几个部分： ① 图标（是否可以使用伪元素 :before、:after 实现，例如各种箭头图标） ② 背景（是否可以使用 background 实现） ③ 按钮（是否可以使用 background、border-radius、:hover 等实现交互效果） ④ 字体（是否被高频使用，是否需要做成单独的字体文件或做成切片） ⑤ 装饰性元素（是否可以使用伪元素 :before、:after 实现） 3. 开始切图 首先写几点操作过程中时不时需要注意的几点： 参考线可以通过在主画板顶部及左侧的标尺中通过拖拽添加 / 删除，如果没有打开标尺，按快捷键 Ctrl+R 即可显示标尺。 保存为 web 格式的时候，选 PNG-24 记得勾选下方的‘交错’，选 JPEG 记得勾选‘连续’，这样在浏览器加载图片的时候会以模糊逐渐转为清晰的效果渐渐显示出来，浏览体验更好。转换为 sRGB 可以在绝大部分浏览器中显示出你期望的颜色。 需要保留透明度的选择PNG-24（PNG-8不支持半透明，这是为了照顾 IE6 的显示效果，现在谁还管 IE6，用 IE6 的人还想要什么优雅的交互体验，页面能显示出来主要内容就不错了，嫌弃脸.jpg &lt;_&lt;），不需要保留透明度的选择JPEG。另外.JPG 文件，相对于 PNG-24，对图片质量要求不高的情况下，JPEG 能获得更小的文件体积。 具体到切图的方法，主流的方法主要有这么几种： 3.1 传统切图法 普通切图方法就是使用切片工具&amp;&amp;切片选择工具，在设计稿上调整好切片然后输出。 首先开始划分出我们需要的切片（注意：设计稿中已经包含原作者留下的切片，为防干扰最好使用切片选择工具把这些切片删除）。早期的浏览器对含透明通道的PNG图支持不好，所以处理含透明通道的图时我们一般使用GIF，或者索性把图形连同背景合并到一起输出不透明的图。而随着前端技术的发展和古老浏览器的淘汰，现在更好的做法是使用透明通道的PNG图片，既保证了图像质量又保证了图片在不同页面中都能适应。 使用切片切图时建议使用 基于参考线的切片，也就是先用参考线选好，然后再选择切片工具，然后点击基于参考线的切片： 3.2 文艺切图法 可以看到，普通切图法需要手动编辑切片，耗时耗力，当设计稿元素较多时容易出错。其实在处理大量图片时，我们常用到PS的脚本功能来对图像进行批处理，切图这一工作也可以通过脚本来实现半自动化。 文件&gt;脚本&gt;将图层导出到文件”这条命令是PS中预置的一个脚本，正如你想要的，他会把设计稿中的图层输出成图片。用这种方式切图，为了不破坏设计稿、脚本运行速度更快，我建议新建一个文档来进行。新建一个尺寸为800800的文档，把需要切图的元素拖动到这个文档中来，位置随意摆放，因为这个脚本会将“图层导出到文件”，所以有些元素可能包含多个图层的要使用“*图层&gt;合并图层**”将他们合并。 执行“文件&gt;脚本&gt;将图层导出到文件: 3.3 2B 切图法 2B 切图法就是使用裁剪工具，将设计稿中的每个元素分别提取出来并单独存储，仅需要输出少量图片或是要对图像局部调整时才使用此方法。 3.4 直接导出 新版 PS CC 可以右键直接导出 PNG 文件～～～ 3.5 简单实用（1） 如果你的图层很多，你可以用“ctrl+点击想要的图片“直接选中你想要图片的图层，简单到位，然后将图层转化为智能对象（当然可以几个图层拼到一起），然后双击弹出点击确定，就 ok 了； （2） 对于大图，这个时候就有很多的东西存在，这里就使用，选区先选中你要切的图形，然后”编辑-合并拷贝-新建-拷贝“，就能建立一个完成整的图片切图的样子了，就 ok 了。 4. 结语 当然，本文主要还是针对的传统 Web 切图工作，现在也有很多新兴的工具，可以更加有效率的完成前端的设计编码工作，不忘初衷，方得始终，与时俱进，一定要装作好像自己很熟练了的样子～～～","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"https://doubleray.top/tags/PhotoShop/"}]},{"title":"H5 移动多终端适配","slug":"article-html-adaptation","date":"2017-02-26T05:13:05.000Z","updated":"2021-06-24T04:02:41.960Z","comments":true,"path":"2017/02/26/article-html-adaptation/","link":"","permalink":"https://doubleray.top/2017/02/26/article-html-adaptation/","excerpt":"移动端的浏览器在展示页面时会出现许多非预期的现象，比如有的可能浏览器自动缩放网页让整个内容能够在可视区域展示，但内容会缩小；有的可能会出现横向滚动条。这些都不是理想的浏览状态，理想的网页展示应该是用户进入页面不需要手动缩放就能够看清页面的内容也没有横向滚动条。 要如何去实现移动端网页展示达到理想效果涉及到很多因素，但主要包括三个方面：像素（pixels）、屏幕（screen）、视口（viewport）和缩放（scale）。","text":"移动端的浏览器在展示页面时会出现许多非预期的现象，比如有的可能浏览器自动缩放网页让整个内容能够在可视区域展示，但内容会缩小；有的可能会出现横向滚动条。这些都不是理想的浏览状态，理想的网页展示应该是用户进入页面不需要手动缩放就能够看清页面的内容也没有横向滚动条。 要如何去实现移动端网页展示达到理想效果涉及到很多因素，但主要包括三个方面：像素（pixels）、屏幕（screen）、视口（viewport）和缩放（scale）。 1. 像素（pixels） 像素这个词对绝大多素人都不陌生，正常的理解就是像素就好像是一个个“点”，屏幕由不同数量的点排列构成不同的分辨率，一张图片由不同的像素点构成不同的大小。同时我们经常将像素说成长度的单位，但实际上我们说1像素其实是一个1 x 1的小方块，它的面积是1。 1.1 设备像素 设备像素又称物理像素，是显示设备（PC、手机显示屏等）最小的物理部件，设备像素由操作系统控制来发光填色值，来让我们在视觉上看到相应的效果（如50 x 50的红色方块）。设备像素做为物理属性的存在是固定不变的，开发人员不可能通过程序控制设备像素数量上的增加减少。 1.2 CSS 像素 我们平时写网页的时候用的长度单位是 px，属于 CSS 像素。CSS 像素是抽象的，抽象意味着它没有物理属性的实体依据，它可以收缩放大。简单的理解为 CSS 像素点是有面积的，一个个 CSS 像素点铺起来盖在设备的显示屏上，其面积随着浏览器的缩放比例而同步缩放。例如在 PC 上的浏览器中，定义一 100 x 100 的红色方块，缩放比例为 100% 的情况下，一个 CSS 像素是与一个设备像素完全重叠的。当缩放比设置为 50% 即缩小一半，CSS像素会等比缩放一半，那一个 CSS 像素的面积就只占 100% 情况下的四分之一了，所以视觉上看到方块变成了 50x50 的大小（即占了 50x50 的设备像素）。 此时浏览器中检查元素大小会发现红色方块的大小仍旧为100x100，只是CSS像素的面积缩小了！ 但是，到了移动终端，由于高密度显示技术出现，比如苹果的Retina显示屏中，当缩放比是 100% 的时候，一个 CSS 像素占的面积是 4 个设备像素的面积，即一个 CSS 像素横向宽度覆盖了 2 个设备像素的宽度。缩放比为 100% 时一个 CSS 像素占多少个设备像素是由 设备像素比（dpr） 决定的，dpr为 2，则占两个，dpr 为 3 则占三个。dpr 的取值可以通过如下代码得到： 1window.devicePixelRatio 2. 屏幕（screen） 屏幕的完整大小用设备像素来衡量，单位是物理属性的单位，做开发的时候也不需要太过关注，我们关注的是CSS像素。一般就可以理解为这个单位和CSS像素的大小在缩放比为100%时是一样大的。我们可以在chrome这类下载浏览器中能够通过screen.width/height来得到屏幕高宽的具体值。这个时候你会发现在PC上不管把浏览器窗口调整至多大,返回值总是一致的，移动端上的情况也很明朗，比如iphone6返回的值就是 375。 我们构建网页的时候关注的是 CSS 像素，用户看网页的时候关注的是浏览器宽度内的内容，浏览器宽度决定了用户在视觉上能够看到多少东西。所以我们开发的时候关注的也就是浏览器视觉宽度下，里面的 CSS 像素的数量多少。这个浏览器尺寸内的 CSS 像素多少可以通过window.innerWidth/Height来获取。由于 CSS 像素会缩放，所以同一个浏览器宽度下这个取值是可能不同的。 3. 视口（viewport） 我们进行网页布局的时候设置 html 元素宽度为100%，这个100%是依据什么设置的呢？浏览器窗口用 CSS 像素衡量的宽度（window.innerWidth)还是别的呢？我们可以发现在PC端的浏览器上设置100%，html 元素的 px 宽度就等于浏览器宽度；而在移动端不管是在什么设备上，html 设置100%，基本上宽度都等于980px。 3.1 布局视口 所以这就引出了布局视口的概念。宽度设置是根据布局视口来算的，只是PC端布局视口就等于浏览器宽度，而移动终端由于屏幕宽度较窄，为了显示在 PC 端网页显示的网页能在移动端基本能看，所以浏览器厂商一般将其设为 980px 然后进行缩放，让网页在窄屏幕上能够全部显示。布局视口尺寸可以通过如下代码获取： 1document.documentElement.clientWidth/Height; 虽然document.documentElement就是 html 元素，但是取值却不是取的 html 元素的宽度。同时我们做的媒体查询中判断的max-width也是判断布局视口的宽度。 12345@media all and (max-width: 400px) &#123; .box&#123; width: 300px; &#125;&#125; 3.2 视觉视口 视觉视口就是用户能够看到的窗口，单纯的用视觉去描述它就是浏览器屏幕的大小。用CSS像素去描述就是：视觉视口的大小就是屏幕大小范围内CSS像素堆积的总面积，不管CSS像素是否缩放。 移动端布局需要达到的效果： 设置布局视口的宽度正好等于屏幕的大小。 12345678&lt;!--设置布局视口等于device-width--&gt;&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;&lt;!-- 只设置缩放值也能将布局视口宽度设置为屏幕宽度，设置为0.5时由于CSS像素缩放了0.5，填到屏幕中的CSS像素数量正好是屏幕宽度 --&gt;&lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt;&lt;!-- 这是兼容写法 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1,user-scalable=no\"&gt; 4. 移动适配方案总结4.1 width=device-width 直接设置width=device-width，这样能够保证宽度一致，但考虑到苹果的Retina屏幕设计师出设计稿的时候都是放大了一倍设计稿，比如640px（基于iphone5）、750px（基于iphone6）。如果我们拿到的设计稿是750px宽，在设置缩放比为100%、布局视口等于屏幕宽度的情况下，我们拿到的设计稿宽度是大了一倍的，（网页中设置375px沾满屏幕，而设计稿切出的图是750px），所以在转换成网页的时候设置宽度需要将设计图的宽度除以2来，如果考虑到iphone6 plus的dpr为3，要保证在6 plus下图片还是高清，就需要将750px的设计稿再放大1.5倍，用@3倍图切出来。以上可以知道这种方案不需要动态的去根据屏幕dpr不同来设置meta标签内容，直接一句话搞定，然后需要调整的地方通过媒体查询来做。 4.2 flexible 淘宝的 flexible 方案只解决苹果设备上的 dpr 为2和3的情况，不考虑安卓设备也不考虑 pad。做的事情也很简单，就是动态设置 meta 标签的内容，和第一种方案不同的是没有设置为 width=device-width,而是通过设置 initial-scale 来缩放布局视口，dpr 为1，缩放为1；dpr 为2，缩放0.5；dpr 为3，缩放0.3333；通过这种方法使得布局视口在视觉上还是屏幕大小但CSS像素数量却增加了4倍/9倍。而这样的直接好处就是比如 iphone6 的视觉视口横向有了750个 CSS 像素点，和设计图保持一致了，同时CSS像素缩放 0.5 解决了经典的 1px 像素问题。 该方案的核心原理是通过window.navigator.appVersion判断是否是iphone，其他的比如ipad、Android直接设置dpr为1，然后通过 1/ dpr 得到缩放值。 12345678910111213141516171819var isAndroid = win.navigator.appVersion.match(/android/gi);/* 判断iphone ipad不考虑*/var isIPhone = win.navigator.appVersion.match(/iphone/gi);var devicePixelRatio = win.devicePixelRatio;if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125;&#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1;&#125;/*缩放值*/scale = 1 / dpr; 这个解决方案中用的布局单位是rem而不是px，这也是为了等比例缩放的问题。rem单位代表的是根节点也就是 html 的 fontSize 的值，html默认为16px，所以默认1rem = 16px。既然开发的设计标注图是750px的，将 html 设为 75px 就很方便了，10rem = 750px。然后放到所有屏幕情况下： 12345678910111213function refreshRem()&#123; /*获取布局视口宽度,也可用document.documentElement.clientWidth*/ var width = document.documentElement.getBoundingClientRect().width; /* 判断屏幕宽度，如果dpr为1且宽度&gt;540 则恒定为540px，dpr为2如果宽度&gt;1080则恒定为1080px*/ if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; /*将布局视口宽度除以10得到html字体大小*/ var rem = width / 10; document.documentElement.style.fontSize = rem + 'px' 比如iphone5的设备下布局视口是640，所以 html 的字体大小会设置为64px，而在开发的时候设置的单位为 rem,这个时候rem 自动根据 64px 转换，就实现了等比缩放。写 rem 的时候可以通过 CSSREM 插件来写，只是后期维护比较麻烦。 字体不用 rem 而采用 px 是因为我们希望一个文本字号不因为Retina显示屏的原因而缩放变小。然后在大屏上也不会放大而能够看到更多的文本。但是不同的dpr下又的确是要分别设置字号的。这个解决方案会在 htm l元素上设置 data-dpr 属性，然后通过该属性判断来设置字体大小。 123456789div.box&#123; font-size: 12px;&#125;[data-dpr=\"2\"] div&#123; font-size: 24px;&#125;[data-dpr=\"3\"] div&#123; font-size: 36px;&#125; 设计稿设计方面要求为 750px，如果设计师有做标注就做在这个稿子上，没有标注的话我们开发的时候就依据这个设计稿来量间距之类的。同时将这个稿子放大 1.5 倍来得到 1125px 的设计稿，切图用这份设计稿保证 dpr 为 3 的屏幕图片显示足够清晰。在 iphone6 的屏幕下开发然后再向上向下适配。 4.3 设置固宽 固定设置布局视口的宽度，比如设置为640，或750。 移动端适配的原理很简单，各个项目在用的时候也能去选一个适合的方案。在 vw 和 vh 单位兼容性不够的时候，要做到设置的单位等比缩放只能用 rem。另外现在是不是有更好的适配方案不太清楚，本文主要是对现在我所知道的方案做一个总结。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doubleray.top/tags/HTML/"}]},{"title":"ECMAScript 6 扫盲学习","slug":"article-ES6-know","date":"2017-02-23T11:41:15.000Z","updated":"2021-06-24T04:02:41.952Z","comments":true,"path":"2017/02/23/article-ES6-know/","link":"","permalink":"https://doubleray.top/2017/02/23/article-ES6-know/","excerpt":"ECMAScript 6 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 本文转自 ECMAScript 6 扫盲 ，参考 Github 上的 一篇文章，目的是对还不太熟悉 ES6 语法的小伙伴做一个简单的扫盲学习。","text":"ECMAScript 6 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 本文转自 ECMAScript 6 扫盲 ，参考 Github 上的 一篇文章，目的是对还不太熟悉 ES6 语法的小伙伴做一个简单的扫盲学习。 1. let、const 和 block 作用域 let 允许创建块级作用域，ES6 推荐在函数中使用 let 定义变量，而非 var： 123456var a = 2;&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // 2 同样在块级作用域有效的另一个变量声明方式是 const，它可以声明一个常量。ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的，如： 123456&#123; const ARR = [5,6]; ARR.push(7); console.log(ARR); // [5,6,7] //ARR = 10; // TypeError&#125; 有几个点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let 和 const 声明只在最靠近的一个块中（花括号内）有效 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING const 在声明时必须被赋值 2. 箭头函数（Arrow Functions） ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体： 12345var getPrice = function() &#123; return 4.55;&#125;;// Implementation with Arrow Functionvar getPrice = () =&gt; 4.55; 需要注意的是，上面栗子中的 getPrice 箭头函数采用了简洁函数体，它不需要 reture 语句，下面这个栗子使用的是正常函数体： 12345let arr = ['apple', 'banana', 'orange'];let breakfast = arr.map(fruit =&gt; &#123; return fruit + 's';&#125;);console.log(breakfast); // apples bananas oranges 当然，箭头函数不仅仅是让代码变得简洁，函数中 this 总是绑定总是指向对象自身。具体可以看看下面几个栗子： 12345678function Person() &#123; this.age = 0; setInterval(function growUp() &#123; // 在非严格模式下，growUp() 函数的 this 指向 window 对象 this.age++; &#125;, 1000);&#125;var person = new Person(); 我们经常需要使用一个变量来保存 this，然后在 growUp 函数中引用： 1234567function Person() &#123; var self = this; self.age = 0; setInterval(function growUp() &#123; self.age++; &#125;, 1000);&#125; 而使用箭头函数可以省却这个麻烦： 12345678function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; // |this| 指向 person 对象 this.age++; &#125;, 1000);&#125;var person = new Person(); 在 这里 可以阅读更多 this 在箭头函数中的词法特性。 3. 函数参数默认值 ES6 中允许你对函数参数设置默认值： 12let getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;getFinalPrice(500); // 850 4. Spread / Rest 操作符 Spread / Rest 操作符指的是 …，具体是 Spread 还是 Rest 需要看上下文语境。当被用于迭代器中时，它是一个 Spread 操作符： 12345function foo(x,y,z) &#123; console.log(x,y,z);&#125;let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符： 1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 5. 对象词法扩展 ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作： 12345678910111213141516171819202122function getCar(make, model, value) &#123; return &#123; // 简写变量 make, // 等同于 make: make model, // 等同于 model: model value, // 等同于 value: value // 属性可以使用表达式计算值 ['make' + make]: true, // 忽略 `function` 关键词简写对象函数 depreciate() &#123; this.value -= 2500; &#125; &#125;;&#125;let car = getCar('Barret', 'Lee', 40000);// output: &#123;// make: 'Barret',// model:'Lee',// value: 40000,// makeBarret: true,// depreciate: function()// &#125; 6. 二进制和八进制字面量 ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者 0O 即可将其转换为二进制值： 1234let oValue = 0o10;console.log(oValue); // 8let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`console.log(bValue); // 2 7. 对象和数组解构 解构可以避免在对象赋值时产生中间变量： 123456789101112131415function foo() &#123; return [1,2,3];&#125;let arr = foo(); // [1,2,3]let [a, b, c] = foo();console.log(a, b, c); // 1 2 3function bar() &#123; return &#123; x: 4, y: 5, z: 6 &#125;;&#125;let &#123;x: x, y: y, z: z&#125; = bar();console.log(x, y, z); // 4 5 6 8. 对象超类 ES6 允许在对象中使用 super 方法： 1234567891011121314var parent = &#123; foo() &#123; console.log(\"Hello from the Parent\"); &#125;&#125;var child = &#123; foo() &#123; super.foo(); console.log(\"Hello from the Child\"); &#125;&#125;Object.setPrototypeOf(child, parent);child.foo(); // Hello from the Parent // Hello from the Child 9. 模板语法和分隔符 ES6 中有一种十分简洁的方法组装一堆字符串和变量。 ${ … } 用来渲染一个变量 ` 作为分隔符 12let user = 'Barret';console.log(`Hi $&#123;user&#125;!`); // Hi Barret! 10. for…of VS for…in for…of 用于遍历一个迭代器，如数组： 123456let nicknames = ['di', 'boo', 'punkeye'];nicknames.size = 3;for (let nickname of nicknames) &#123; console.log(nickname);&#125;Result: di, boo, punkeye for…in 用来遍历对象中的属性： 123456let nicknames = ['di', 'boo', 'punkeye'];nicknames.size = 3;for (let nickname in nicknames) &#123; console.log(nickname);&#125;Result: 0, 1, 2, size 11. Map 和 WeakMap ES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。 Map 一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如： 12345678910111213var myMap = new Map();var keyString = \"a string\", keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;;// 设置值myMap.set(keyString, \"value 与 'a string' 关联\");myMap.set(keyObj, \"value 与 keyObj 关联\");myMap.set(keyFunc, \"value 与 keyFunc 关联\");myMap.size; // 3// 获取值myMap.get(keyString); // \"value 与 'a string' 关联\"myMap.get(keyObj); // \"value 与 keyObj 关联\"myMap.get(keyFunc); // \"value 与 keyFunc 关联\" WeakMap WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。 另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和 set(key, val)： 12345678910111213let w = new WeakMap();w.set('a', 'b'); // Uncaught TypeError: Invalid value used as weak map keyvar o1 = &#123;&#125;, o2 = function()&#123;&#125;, o3 = window;w.set(o1, 37);w.set(o2, \"azerty\");w.set(o3, undefined);w.get(o3); // undefined, because that is the set valuew.has(o1); // truew.delete(o1);w.has(o1); // false 12. Set 和 WeakSetSet Set 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型： 12345let mySet = new Set([1, 1, 2, 2, 3, 3]);mySet.size; // 3mySet.has(1); // truemySet.add('strings');mySet.add(&#123; a: 1, b:2 &#125;); 可以通过 forEach 和 for…of 来遍历 Set 对象： 12345678910111213141516mySet.forEach((item) =&gt; &#123; console.log(item); // 1 // 2 // 3 // 'strings' // Object &#123; a: 1, b: 2 &#125;&#125;);for (let value of mySet) &#123; console.log(value); // 1 // 2 // 3 // 'strings' // Object &#123; a: 1, b: 2 &#125;&#125; Set 同样有 delete() 和 clear() 方法。 WeakSet 类似于 WeakMap，WeakSet 对象可以让你在一个集合中保存对象的弱引用，在 WeakSet 中的对象只允许出现一次： 123456789var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // false, foo 没有添加成功ws.delete(window); // 从结合中删除 window 对象ws.has(window); // false, window 对象已经被删除 13. 类 ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。函数中使用 static 关键词定义构造函数的的方法和属性： 123456789101112131415class Task &#123; constructor() &#123; console.log(\"task instantiated!\"); &#125; showId() &#123; console.log(23); &#125; static loadAll() &#123; console.log(\"Loading all tasks..\"); &#125;&#125;console.log(typeof Task); // functionlet task = new Task(); // \"task instantiated!\"task.showId(); // 23Task.loadAll(); // \"Loading all tasks..\" 类中的继承和超集： 1234567891011121314class Car &#123; constructor() &#123; console.log(\"Creating a new car\"); &#125;&#125;class Porsche extends Car &#123; constructor() &#123; super(); console.log(\"Creating Porsche\"); &#125;&#125;let c = new Porsche();// Creating a new car// Creating Porsche extends 允许一个子类继承父类，需要注意的是，子类的 constructor 函数中需要执行 super() 函数。当然，你也可以在子类方法中调用父类的方法，如 super.parentMethodName()。 有两点值得注意的是： 类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误 在类中定义函数不需要使用 function 关键词 在 这里 阅读更多关于类的介绍。 14. Symbol Symbol 是一种新的数据类型，它的值是唯一的，不可变的。ES6 中提出 symbol 的目的是为了生成一个唯一的标识符，不过你访问不到这个标识符： 12var sym = Symbol( \"some optional description\" );console.log(typeof sym); // symbol 注意，这里 Symbol 前面不能使用 new 操作符。如果它被用作一个对象的属性，那么这个属性会是不可枚举的： 12345var o = &#123; val: 10, [ Symbol(\"random\") ]: \"I'm a symbol\",&#125;;console.log(Object.getOwnPropertyNames(o)); // val 如果要获取对象 symbol 属性，需要使用 Object.getOwnPropertySymbols(o)。 15. 迭代器（Iterators） 迭代器允许每次访问数据集合的一个元素，当指针指向数据集合最后一个元素是，迭代器便会退出。它提供了 next() 函数来遍历一个序列，这个方法返回一个包含 done 和 value 属性的对象。 ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，无论什么时候对象需要被遍历，执行它的 @@iterator 方法便可以返回一个用于获取值的迭代器。 数组默认就是一个迭代器： 123456var arr = [11,12,13];var itr = arr[Symbol.iterator]();itr.next(); // &#123; value: 11, done: false &#125;itr.next(); // &#123; value: 12, done: false &#125;itr.next(); // &#123; value: 13, done: false &#125;itr.next(); // &#123; value: undefined, done: true &#125; 你可以通过 Symbol.iterator 自定义一个对象的迭代器。 16. Generators 和 PromisesGenerators Generator 函数是 ES6 的新特性，它允许一个函数返回的可遍历对象生成多个值。在使用中你会看到 * 语法和一个新的关键词 yield: 12345678910function *infiniteNumbers() &#123; var n = 1; while (true)&#123; yield n++; &#125;&#125;var numbers = infiniteNumbers(); // returns an iterable objectnumbers.next(); // &#123; value: 1, done: false &#125;numbers.next(); // &#123; value: 2, done: false &#125;numbers.next(); // &#123; value: 3, done: false &#125; 每次执行 yield 时，返回的值变为迭代器的下一个值。 Promises ES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者 rejected。 123456789var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调： 12p.then((val) =&gt; console.log(\"Promise Resolved\", val), (err) =&gt; console.log(\"Promise Rejected\", err));","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"Git 中 git push 到远程仓库不被授权的问题","slug":"article-git-connect","date":"2017-02-21T04:19:15.000Z","updated":"2021-06-24T04:02:41.958Z","comments":true,"path":"2017/02/21/article-git-connect/","link":"","permalink":"https://doubleray.top/2017/02/21/article-git-connect/","excerpt":"","text":"使用 Git 过程中，今天突然遇到这样的问题，在 git push 到 github 远程仓库时失败了，提示你说这次 push 不被授权，昨天还是好好的，难道是 github 又被墙了？后开始测试发现除了 SSH 所有的连接都是正常的。Webstorm 里直接 push 会提示： 1Push failed: Failed with error: fatal: Could not read from remote repository. 原因 没有匹配正确 ssh 公钥密钥对。要么是你没有生成对应的公钥密钥对并将公钥部署在 github 上的对应项目，要么就是生成了密钥对并将公钥部署在了 github 上之后，你的本地目录没有将私钥配置上或者是之前有配置，但是过期了。 解决方法 首先，生成一个公钥密钥对：ssh-keygen -t rsa -C “youemail@example.com“ -f ~/.ssh/id_rsa 此命令可创建 SSH 公钥密钥对，”youemail@example.com“为你自己的邮箱地址，”id_rsa”为公钥密钥名，可修改。 创建后的公钥密钥对存放在本地目录C:\\Users[UserName].ssh\\文件夹中，可以查看 将公钥部署上github，将（1）中生成的id_rsa.pub文件用文本编辑器打开，复制其中内容。在对应的github项目的“setting”中的“SSH and GPG keys”选择“new SSH key“，将公钥内容粘贴上去，新建一个SSH key。 在 git bash 命令行在添加私钥。查看私钥列表的命令为：ssh-add -l，如果输出以上命令出现Could not open a connection to your authentication agent.，则再输入ssh-agent bash，即可进入SSH bash。添加私钥的命令：ssh-add ~/.ssh/id_rsa，此时再查看私钥列表，若已经成功添加，则可以正常地使用 git push 进行对远程仓库的更新了。 其他 Git 常用命令行请移步 常用 git 命令行总结。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doubleray.top/tags/Git/"}]},{"title":"驯服 JavaScript 的“this”！","slug":"article-js-this","date":"2017-02-18T04:19:15.000Z","updated":"2021-06-24T04:02:41.972Z","comments":true,"path":"2017/02/18/article-js-this/","link":"","permalink":"https://doubleray.top/2017/02/18/article-js-this/","excerpt":"JavaScript 中的this关键字往往让菜鸟和大神都感到困惑。本文目的就是带你驯服它。我们将了解如何在每一个场景中正确地使用this，内容较多，多方整理。 在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。 因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。","text":"JavaScript 中的this关键字往往让菜鸟和大神都感到困惑。本文目的就是带你驯服它。我们将了解如何在每一个场景中正确地使用this，内容较多，多方整理。 在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。 因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。 JavaScript中很多时候会用到this，下面详细介绍每一种情况。在这里我想首先介绍一下宿主环境这个概念。一门语言在运行的时候，需要一个环境，叫做宿主环境。对于JavaScript，宿主环境最常见的是web浏览器，浏览器提供了一个JavaScript运行的环境，这个环境里面，需要提供一些接口，好让JavaScript引擎能够和宿主环境对接。JavaScript引擎才是真正执行JavaScript代码的地方，常见的引擎有V8(目前最快JavaScript引擎、Google生产)、JavaScript core。JavaScript引擎主要做了下面几件事情： 一套与宿主环境相联系的规则; JavaScript引擎内核（基本语法规范、逻辑、命令和算法); 一组内置对象和API; 其他约定。 但是环境不是唯一的，也就是JavaScript不仅仅能够在浏览器里面跑，也能在其他提供了宿主环境的程序里面跑，最常见的就是nodejs。同样作为一个宿主环境，nodejs也有自己的JavaScript引擎–V8。根据官方的定义: Node.js is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applications global this 在浏览器里，在全局范围内，this等价于window对象。 123&lt;script type=\"text/javascript\"&gt; console.log(this === window); //true&lt;/script&gt; 在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的。 12345&lt;script type=\"text/javascript\"&gt; var foo = \"bar\"; console.log(this.foo); //logs \"bar\" console.log(window.foo); //logs \"bar\"&lt;/script&gt; 如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。 12345678910&lt;script type=\"text/javascript\"&gt; foo = \"bar\"; function testThis() &#123; foo = \"foo\"; &#125; console.log(this.foo); //logs \"bar\" testThis(); console.log(this.foo); //logs \"foo\"&lt;/script&gt; 在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global。 1234567 //this&#123; ArrayBuffer: [Function: ArrayBuffer], Int8Array: &#123; [Function: Int8Array] BYTES_PER_ELEMENT: 1 &#125;, Uint8Array: &#123; [Function: Uint8Array] BYTES_PER_ELEMENT: 1 &#125;, //... global === this //true 在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。 1234567//test.js脚本内容：console.log(this);console.log(this === global);//REPL运行脚本：$ node test.js&#123;&#125;false 在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。 12345//test.js:var foo = \"bar\";console.log(this.foo);//$ node test.jsundefined 但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑) 12345var foo = \"bar\";this.foobarglobal.foobar 在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this。 1234567//test.jsfoo = \"bar\";console.log(this.foo);console.log(global.foo);//$ node test.jsundefinedbar 上面的八种情况可能大家已经绕晕了，总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大。 function this 无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。 123456789&lt;script type=\"text/javascript\"&gt; foo = \"bar\"; function testThis() &#123; this.foo = \"foo\"; &#125; console.log(this.foo); //logs \"bar\" testThis(); console.log(this.foo); //logs \"foo\"&lt;/script&gt; 123456789101112//test.js foo = \"bar\";function testThis () &#123; this.foo = \"foo\";&#125;console.log(global.foo);testThis();console.log(global.foo);//$ node test.jsbarfoo 除非你使用严格模式，这时候this就会变成undefined。 123456789&lt;script type=\"text/javascript\"&gt; foo = \"bar\"; function testThis() &#123; \"use strict\"; this.foo = \"foo\"; &#125; console.log(this.foo); //logs \"bar\" testThis(); //Uncaught TypeError: Cannot set property 'foo' of undefined &lt;/script&gt; 如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。 12345678910&lt;script type=\"text/javascript\"&gt; foo = \"bar\"; function testThis() &#123; this.foo = \"foo\"; &#125; console.log(this.foo); //logs \"bar\" new testThis(); console.log(this.foo); //logs \"bar\" console.log(new testThis().foo); //logs \"foo\"&lt;/script&gt; 我更喜欢把新的值称作一个实例。 函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。 prototype this 你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。 123456function Thing() &#123; console.log(this.foo);&#125;Thing.prototype.foo = \"bar\";var thing = new Thing(); //logs \"bar\"console.log(thing.foo); //logs \"bar\" 当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo。 12345678910111213141516171819function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; console.log(this.foo);&#125;Thing.prototype.setFoo = function (newFoo) &#123; this.foo = newFoo;&#125;var thing1 = new Thing();var thing2 = new Thing();thing1.logFoo(); //logs \"bar\"thing2.logFoo(); //logs \"bar\" thing1.setFoo(\"foo\");thing1.logFoo(); //logs \"foo\";thing2.logFoo(); //logs \"bar\";thing2.foo = \"foobar\";thing1.logFoo(); //logs \"foo\";thing2.logFoo(); //logs \"foobar\"; 实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现。 123456789101112131415161718192021function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; console.log(this.foo);&#125;Thing.prototype.setFoo = function (newFoo) &#123; this.foo = newFoo;&#125;Thing.prototype.deleteFoo = function () &#123; delete this.foo;&#125;var thing = new Thing();thing.setFoo(\"foo\");thing.logFoo(); //logs \"foo\";thing.deleteFoo();thing.logFoo(); //logs \"bar\";thing.foo = \"foobar\";thing.logFoo(); //logs \"foobar\";delete thing.foo;thing.logFoo(); //logs \"bar\"; 或者你也能直接通过引用函数对象的prototype 来获得你需要的值。 123456789function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; console.log(this.foo, Thing.prototype.foo); &#125;var thing = new Thing();thing.foo = \"foo\";thing.logFoo(); //logs \"foo bar\"; 通过一个函数创建的实例会共享这个函数的prototype属性的值，如果你给这个函数的prototype赋值一个Array，那么所有的实例都会共享这个Array，除非你在实例里面重写了这个Array，这种情况下，函数的prototype的Array就会被隐藏掉。 1234567function Thing() &#123;&#125;Thing.prototype.things = [];var thing1 = new Thing();var thing2 = new Thing();thing1.things.push(\"foo\");console.log(thing2.things); //logs [\"foo\"] 给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。 12345678function Thing() &#123; this.things = [];&#125; var thing1 = new Thing(); var thing2 = new Thing();thing1.things.push(\"foo\");console.log(thing1.things); //logs [\"foo\"]console.log(thing2.things); //logs [] 实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。 12345678function Thing1() &#123;&#125;Thing1.prototype.foo = \"bar\";function Thing2() &#123;&#125;Thing2.prototype = new Thing1();var thing = new Thing2();console.log(thing.foo); //logs \"bar\" 一些人利用原型链的特性来在JavaScript模仿经典的面向对象的继承方式。任何给用于构建原型链的函数的this的赋值的语句都会隐藏原型链上游的相同的属性。 123456789101112function Thing1() &#123;&#125;Thing1.prototype.foo = \"bar\";function Thing2() &#123; this.foo = \"foo\";&#125;Thing2.prototype = new Thing1();function Thing3() &#123;&#125;Thing3.prototype = new Thing2();var thing = new Thing3();console.log(thing.foo); //logs \"foo\" 我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实力的原始函数。我通常把这些原始函数叫做构造函数。在prototype里面定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。 123456789101112function Thing1() &#123;&#125;Thing1.prototype.foo = \"bar\";Thing1.prototype.logFoo = function () &#123; console.log(this.foo); &#125;function Thing2() &#123; this.foo = \"foo\";&#125;Thing2.prototype = new Thing1();var thing = new Thing2();thing.logFoo(); //logs \"foo\"; 在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this。 123456789101112function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; var info = \"attempting to log this.foo:\"; function doIt() &#123; console.log(info, this.foo); &#125; doIt();&#125;var thing = new Thing();thing.logFoo(); //logs \"attempting to log this.foo: undefined\" 在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作一个值，把这个值当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。 123456789101112function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; console.log(this.foo); &#125;function doIt(method) &#123; method();&#125; var thing = new Thing();thing.logFoo(); //logs \"bar\"doIt(thing.logFoo); //logs undefined 一些人喜欢先把this捕获到一个变量里面，通常这个变量叫做self，来避免上面这种情况的发生。 1234567891011121314function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; var self = this; var info = \"attempting to log this.foo:\"; function doIt() &#123; console.log(info, self.foo); &#125; doIt();&#125; var thing = new Thing();thing.logFoo(); //logs \"attempting to log this.foo: bar\" 但是当你需要把一个方法作为一个值传递给一个函数的时候并不管用。 12345678910111213141516function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; var self = this; function doIt() &#123; console.log(self.foo); &#125; doIt();&#125;function doItIndirectly(method) &#123; method(); &#125; var thing = new Thing(); thing.logFoo(); //logs \"bar\" doItIndirectly(thing.logFoo); //logs undefined 你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数定义在所有函数和方法的函数对象上面。 1234567891011function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; console.log(this.foo);&#125;function doIt(method) &#123; method();&#125;var thing = new Thing();doIt(thing.logFoo.bind(thing)); //logs bar 你同样可以使用apply和call来在新的上下文中调用方法或函数。 1234567891011121314function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; function doIt() &#123; console.log(this.foo); &#125; doIt.apply(this);&#125;function doItIndirectly(method) &#123; method();&#125;var thing = new Thing();doItIndirectly(thing.logFoo.bind(thing)); //logs bar 你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。 1234567891011function Thing() &#123;&#125;Thing.prototype.foo = \"bar\";function logFoo(aStr) &#123; console.log(aStr, this.foo);&#125;var thing = new Thing();logFoo.bind(thing)(\"using bind\"); //logs \"using bind bar\"logFoo.apply(thing, [\"using apply\"]); //logs \"using apply bar\"logFoo.call(thing, \"using call\"); //logs \"using call bar\"logFoo(\"using nothing\"); //logs \"using nothing undefined\" 你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例。 123456789function Thing() &#123; return &#123;&#125;;&#125; Thing.prototype.foo = \"bar\"; Thing.prototype.logFoo = function () &#123; console.log(this.foo); &#125; var thing = new Thing(); thing.logFoo(); //Uncaught TypeError: undefined is not a function 奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的。 你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。 12345678function Thing() &#123; &#125; Thing.prototype.foo = \"bar\"; Thing.prototype.logFoo = function () &#123; console.log(this.foo); &#125; var thing = Object.create(Thing.prototype); thing.logFoo(); //logs \"bar\" 在这种情况下并不会调用构造函数： 1234567891011function Thing() &#123; this.foo = \"foo\"; &#125; Thing.prototype.foo = \"bar\"; Thing.prototype.logFoo = function () &#123; console.log(this.foo);&#125;var thing = Object.create(Thing.prototype);thing.logFoo(); //logs \"bar\" 因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。 1234567891011121314function Thing1() &#123; this.foo = \"foo\"; &#125;Thing1.prototype.foo = \"bar\";function Thing2() &#123; this.logFoo(); //logs \"bar\" Thing1.apply(this); this.logFoo(); //logs \"foo\"&#125;Thing2.prototype = Object.create(Thing1.prototype);Thing2.prototype.logFoo = function () &#123; console.log(this.foo);&#125;var thing = new Thing2(); object this 在一个对象的一个函数里，你可以通过this来引用这个对象的其他属性。这个用new来新建一个实例是不一样的。 12345678var obj = &#123; foo: \"bar\", logFoo: function () &#123; console.log(this.foo); &#125;&#125;; obj.logFoo(); //logs \"bar\" 注意，没有使用new，没有使用Object.create，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。 1234567var obj = &#123; foo: \"bar\"&#125;;function logFoo() &#123; console.log(this.foo); &#125;logFoo.apply(obj); //logs \"bar\" 当你用这种方式使用this的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过this共享变量。 123456789var obj = &#123; foo: \"bar\", deeper: &#123; logFoo: function () &#123; console.log(this.foo); &#125; &#125;&#125;;obj.deeper.logFoo(); //logs undefined 你可以直接通过对象引用你需要的属性 12345678910var obj = &#123; foo: \"bar\", deeper: &#123; logFoo: function () &#123; console.log(obj.foo); &#125; &#125;&#125;; obj.deeper.logFoo(); //logs \"bar\" DOM event this 在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点 123456789function Listener() &#123; document.getElementById(\"foo\").addEventListener(\"click\", this.handleClick);&#125;Listener.prototype.handleClick = function (event) &#123; console.log(this); //logs \"&lt;div id=\"foo\"&gt;&lt;/div&gt;\"&#125;var listener = new Listener();document.getElementById(\"foo\").click(); 除非你自己通过bind切换了上下文 123456789function Listener() &#123; document.getElementById(\"foo\").addEventListener(\"click\", this.handleClick.bind(this));&#125;Listener.prototype.handleClick = function (event) &#123; console.log(this); //logs Listener &#123;handleClick: function&#125;&#125;var listener = new Listener();document.getElementById(\"foo\").click(); HTML this 在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素 1234&lt;div id=\"foo\" onclick=\"console.log(this);\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;document.getElementById(\"foo\").click(); //logs &lt;div id=\"foo\"...&lt;/script&gt; override this 你不能重写this，因为它是保留字。 123function test () &#123; var this = &#123;&#125;; // Uncaught SyntaxError: Unexpected token this &#125; eval this 你可以通过eval来访问this 12345678function Thing () &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; eval(\"console.log(this.foo)\"); //logs \"bar\"&#125;var thing = new Thing();thing.logFoo(); 这会造成一个安全问题，除非不用eval，没有其他方式来避免这个问题。 在通过Function来创建一个函数的时候，同样能够访问this 1234567function Thing () &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = new Function(\"console.log(this.foo);\"); var thing = new Thing();thing.logFoo(); //logs \"bar\" with this 你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this 12345678910111213function Thing () &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; with (this) &#123; console.log(foo); foo = \"foo\"; &#125;&#125; var thing = new Thing();thing.logFoo(); // logs \"bar\"console.log(thing.foo); // logs \"foo\" 许多人认为这样使用是不好的，因为with本身就饱受争议。 jQuery this 和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each 12345678910111213&lt;div class=\"foo bar1\"&gt;&lt;/div&gt;&lt;div class=\"foo bar2\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;$(\".foo\").each(function () &#123; console.log(this); //logs &lt;div class=\"foo...&#125;);$(\".foo\").on(\"click\", function () &#123; console.log(this); //logs &lt;div class=\"foo...&#125;);$(\".foo\").each(function () &#123; this.click();&#125;);&lt;/script&gt; thisArg this 如果你用过underscore.js 或者 lo-dash你可能知道许多类库的方法可以通过一个叫做thisArg 的函数参数来传递实例，这个函数参数会作为this的上下文。举个例子，这适用于_.each。原生的JavaScript在ECMAScript 5的时候也允许函数传递一个thisArg参数了，比如forEach。事实上，之前阐述的bind，apply和call的使用已经给你创造了传递thisArg参数给函数的机会。这个参数将this绑定为你所传递的对象。 123456789101112function Thing(type) &#123; this.type = type;&#125;Thing.prototype.log = function (thing) &#123; console.log(this.type, thing);&#125;Thing.prototype.logThings = function (arr) &#123; arr.forEach(this.log, this); // logs \"fruit apples...\" _.each(arr, this.log, this); //logs \"fruit apples...\"&#125;var thing = new Thing(\"fruit\");thing.logThings([\"apples\", \"oranges\", \"strawberries\", \"bananas\"]); 这使得代码变得更加简介，因为避免了一大堆bind语句、函数嵌套和this暂存的使用。","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"Web 前端性能优化","slug":"article-web-optimize","date":"2017-02-16T04:19:15.000Z","updated":"2021-06-24T04:02:41.981Z","comments":true,"path":"2017/02/16/article-web-optimize/","link":"","permalink":"https://doubleray.top/2017/02/16/article-web-optimize/","excerpt":"前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。 Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则，那我们就先来看看这23条。","text":"前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。 Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则，那我们就先来看看这23条。 Yslow 23条 减少HTTP请求次数 尽量合并图片、CSS、JS。比如加载一个页面，如果有5个 css 文件的话，那么会发出5次 http 请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次 http 请求，节省网络请求时间，加快页面的加载。 使用CDN 网站上静态资源即 css、js 全都可以使用 cdn 分发，图片亦然。 避免空的 src 和 href 当 link 标签的 href 属性为空、script 标签的 src 属性为空的时候，浏览器渲染的时候会把当前页面的 URL 作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免这样的疏忽。 为文件头指定 Expires Exipres 是用来设置文件的过期时间的，一般对 css、js、图片资源有效。他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出 http 请求。如下例子： 新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14。 使用gzip压缩内容 gzip 能够压缩任何一个文本类型的响应，包括 html，xml，json 。大大缩小请求返回的数据量。 把 CSS 放到顶部 网页上的资源加载时从上网下顺序加载的，所以 css 放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 把 JS 放到底部 加载 js 时会对后续的资源造成阻塞，必须得等 js 加载完才去加载后续的文件 ，所以就把 js 放在页面底部最后加载。 避免使用 CSS 表达式 举个css表达式的例子： 1font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF&quot; : “#AAAAAA&quot; ); 这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 将 CSS 和 JS 放到外部文件中 目的是缓存文件，可以参考原则 4。 但有时候为了减少请求，也会直接写到页面里，需根据 PV 和 IP 的比例权衡。 权衡 DNS 查找次数 减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。 IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。 下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。 精简 CSS 和 JS 这里就涉及到 css 和 js 的压缩了。比如下面的新浪的一个 css 文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行 css 和 js 文件的压缩，如 grunt，glup 等。 避免跳转 有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 _http://baidu.com/_（注意末尾的斜杠）。在 nginx 服务器可以使用 rewrite；Apache 服务器中可以使用 Alias 或者 mod_rewrite 或者 the DirectorySlash 来避免。 另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到 _http://bbs.baidu.com/_。那么可以通过使用 Alias 或者 mod_rewirte 建立 CNAME（保存一个域名和另外一个域名之间关系的 DNS 记录）来替代。 删除重复的 JS 和 CSS 重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在 IE 和 Firefox 中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 配置 ETags 它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比 last-modified date 更具有弹性，例如某个文件在1秒内修改了10次，Etag 可以综合 Inode (文件的索引节点(inode)数)，MTime (修改时间)和 Size 来精准的进行判断，避开 UNIX 记录 MTime 只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用 ETags 减少 Web 应用带宽和负载。 可缓存的 AJAX 异步请求同样的造成用户等待，所以使用 ajax 请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true 就是显式的要求如果当前请求有缓存的话，直接使用缓存： 1234567$.ajax(&#123; url : 'url', dataType : \"json\", cache: true, success : function(son, status)&#123; // do something; &#125;) 使用 GET 来完成 AJAX 请求 当使用 XMLHttpRequest 时，浏览器中的 POST 方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用 GET 获取数据时更加有意义。 减少 DOM 元素数量 这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少 DOM 数量，就会减少浏览器的解析负担。 避免404 比如外链的 css 或者 js 文件出现问题返回 404 时，会破坏浏览器对文件的并行加载。并且浏览器会把试图在返回的 404 响应内容中找到可能有用的部分当作 JavaScript 代码来执行。 减少 Cookie 的大小 Cookie 里面别塞那么多东西，因为每个请求都得带着他跑。 使用无 cookie 的域 比如 CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 不要使用滤镜 IE 独有属性 AlphaImageLoader 用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用 AlphaImageLoader 的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线 _filter 又使之对 IE7 以上版本的用户无效。 不要在 HTML 中缩放图片 比如你需要的图片尺寸是50* 50 1&lt;img width=”50″ height=”50″ src=“hahah.jpg” alt=”hahaha” /&gt; 那就不用用一张500*500的大尺寸图片，影响加载。 缩小 favicon.ico ，并缓存 很多时候开发者都会忽略这个文件，但是每当有用户收藏网站/网页时，浏览器会自动请求这个文件，就算这个图标文件没有在你的网页中明显说明，浏览器也会请求，如果不添加就会出现 404。 -------------- 分割线 -------------- 在文章开始就已经提到过了，前端优化是一个很大的话题，远远不是这23条就可以说完了，下面一些是个人实践或参考各方大牛的实践总结出来的（一部分常用）优化技巧。 HTML 性能优化 HTML标签有始终。 减少浏览器的判断时间 减少iframe的使用，因为iframe会增加一条http请求，阻止页面加载，即使内容为空，加载也需要时间 id和class，在能看明白的基础上，简化命名，在含有关键字的连接词中连接符号用’-‘，不要用’_’（未测试） 保持统一大小写，统一大小写有利于浏览器缓存，虽然浏览器不区分大小写，但是 w3c 标准为小写 清除空格，虽然空格有助于我们查看代码，但是每个空格相当于一个字符，空格越多，页面体积越大，像 google、baidu 等搜索引擎的首页去掉了所有可以去掉的空格、回车等字符，这样可以加快 web 页面的传输。 减少不必要的嵌套，尽量扁平化，因为当浏览器编译器遇到一个标签时就开始寻找它的结束标签，直到它匹配上才能显示它的内容，所以当嵌套很多时打开页面就会特别慢。 减少注释，因为过多注释不光占用空间，如果里面有大量关键词会影响搜索引擎的搜索 代码要结构化、语义化 除去无用的标签和空标签 尽量少使用废弃的标签，如b、i等，尽管高版本浏览器是向后兼容的 CSS 性能优化 慎重使用高性能属性：浮动、定位； 尽量减少页面重排、重绘 重排按照css的书写顺序： 1234567891011位置：positon、top、left、z-index、float、dispay 大小：width、height、margin、padding 文字系列： font、line-height、color、letter-spacing 背景边框：background、 border 其它：anmation、transition 重绘:border、outline、background、box-shadow,能使用background-color,就尽量不要使用background; 去除空规则：｛｝； 属性值为0时，不加单位； 属性值为浮动小数0.**，可以省略小数点之前的0； 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后； 不使用@import前缀，它会影响css的加载速度； 充分利用css继承属性，减少代码量； 抽象提取公共样式，减少代码量； 选择器优化嵌套，尽量避免层级过深； css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用; 图片优化 使用 base64 编码代替图片 适用于图片小于2KB，页面引用图片不多的情况。将图片转换为base64编码字符串inline到CSS或页面中，减少http的请求次数。 合并图片sprite（雪碧图） 任何用到页面图片的场景。将多个页面用到的北京图片合并成一个大的图片在页面中引用，可以有效地减少请求个数。 使用canvas代替图片 需要高性能的图片或动画，使用HTML5的canvas元素绘制图片，页面渲染性能较高。 响应式图片 不同终端对同一图片的需求不一样，根据终端加载不同的图片来节省不必要的流量。通过picture元素，picturefill或平台判断来为不同终端平台输出不同的图片。减少没必要的图片加载，灵活控制。 图片压缩 在不得不加载图片的前提下，进一步提高优化效果，通过有损或无损压缩所见图片的大小。减少图片加载流量，效果明显。 更好的图片格式 webp、bpg、sharpP等新图片格式具有更好的压缩比 JavaScript 性能优化 常见的 DOM 操作的优化方法 最小化dom访问次数，尽可能在js端执行； 如果需要多次访问某个dom节点，请使用局部变量存储对它的引用； 小心处理html集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中； 如果可能的话，使用速度更快的API，比如querySelectorAll和firstElementChild； 要留意重绘和重排；批量修改样式时，“离线”操作dom树；使用缓存，并减少访问布局的次数； 动画中使用绝对定位，使用拖放代理 使用事件委托来减少事件处理器的数量 对数据访问的优化 函数中读写局部变量总是最快的，而全局变量的读取则是最慢的； 尽可能地少用with 语句，因为它会增加with 语句以外的数据的访问代价； 闭包尽管强大，但不可滥用，否则会影响到执行速度以及内存； 嵌套的对象成员会明显影响性能，尽量少用； 避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存。 实践小技巧 字符串判断使用正则表达式 数字转换成字符：(“” +) &gt; String() &gt; .toString() &gt; new String() 数组拼接字符串用join(),不要用+=。 浮点数转换成整型：使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转换成数字。 动画中使用绝对定位，使用拖放代理 使用事件委托来减少事件处理器的数量 switch 替代 if else var a,b,c; 替代 var a;var b; var c; xxx[i++]; 替代 xxx[i];i++; i++; 替代 i=i+1; i+=5; 替代 i=i+5; 移动 H5 性能优化指南","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://doubleray.top/tags/Web/"}]},{"title":"JavaScript 常用算法总结","slug":"article-js-arithmetic","date":"2017-02-15T06:41:15.000Z","updated":"2021-06-24T04:02:41.962Z","comments":true,"path":"2017/02/15/article-js-arithmetic/","link":"","permalink":"https://doubleray.top/2017/02/15/article-js-arithmetic/","excerpt":"算法通俗的讲：就是解决问题的方法和步骤。在计算机发明之前便已经存在。只不过在计算机发明后，其应用变得更为广泛。通过简单的算法，利用电脑的计算速度，可以让问题变得简单。在前端运算中，算法也是非常重要的。记不清是谁说过“现在的前端已经不是选择器和超链接就能应付的了“，说得一点都没错。在移动端和大数据飞速发展的今天，性能已经是所有工程师所必须重视的部分。作为用户交互的先锋队，前端工程师的技术含量也愈发增加，随着用户体验的不断发展，页面交互的自由度及性能使我们必须深入设计的部分。 作为前端工程师，我们的工作已经不仅仅是完成UI的静态设计稿，还需要设计页面的呈现顺序（惰性加载），功能模块化，设计交互（页面滑动，3D效果等），设计网页游戏等，这时候就需要我们对算法和设计模式的研究。","text":"算法通俗的讲：就是解决问题的方法和步骤。在计算机发明之前便已经存在。只不过在计算机发明后，其应用变得更为广泛。通过简单的算法，利用电脑的计算速度，可以让问题变得简单。在前端运算中，算法也是非常重要的。记不清是谁说过“现在的前端已经不是选择器和超链接就能应付的了“，说得一点都没错。在移动端和大数据飞速发展的今天，性能已经是所有工程师所必须重视的部分。作为用户交互的先锋队，前端工程师的技术含量也愈发增加，随着用户体验的不断发展，页面交互的自由度及性能使我们必须深入设计的部分。 作为前端工程师，我们的工作已经不仅仅是完成UI的静态设计稿，还需要设计页面的呈现顺序（惰性加载），功能模块化，设计交互（页面滑动，3D效果等），设计网页游戏等，这时候就需要我们对算法和设计模式的研究。 1. 99乘法表123456for(var i = 1; i &lt;= 9; i++) &#123; for(var n = 1; n &lt;= i; n++) &#123; document.write(n+'*'+i+'='+i*n+'\\t'); &#125; document.write('&lt;br/&gt;')&#125;//9*9乘法表 2. 斐波那契数列1234567891011121314151617181920212223function fib(n) &#123; if (n&gt;2) &#123; return fib(n - 2) + fib(n - 1); &#125; else &#123; return 1 &#125;&#125;alert(fib(6));//递归//生成斐波那契数列function getFibonacci(n) &#123; var fibarr = []; var i = 0; while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibarr.push(i); &#125; else &#123; fibarr.push(fibarr[i - 1] + fibarr[i - 2]) &#125; i++; &#125; return fibarr;&#125;alert(getFibonacci(6)) 3. 回文字符串判断1234567891011121314151617function palindrome(str) &#123; // 删除字符串中不必要的字符 var re = /[W_]/g; // 将字符串变成小写字符 var lowRegStr = str.toLowerCase().replace(re, ''); // 如果字符串lowRegStr的length长度为0时，字符串即是palindrome if (lowRegStr.length === 0) &#123; return true; &#125; // 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome if (lowRegStr[0] !== lowRegStr[lowRegStr.length - 1]) &#123; return false; &#125; else &#123; return palindrome(lowRegStr.slice(1, lowRegStr.length - 1)); &#125;&#125;alert(palindrome('asddfa')) 4. 获取任意长度的随机字符串1234567891011121314var getRandomString = function(n)&#123; // 定义随机字符串的字符库 var str = 'qwertyuiopasdfghjklzxcvbnm1234567890'; // 定义一个临时变量tmp存储生成的随机字符串 var tmp = ''; //获取str的长度 var len = str.length; // 生成一个长度为n的随机字符串 for(var i = 0; i &lt; n; i++)&#123; tmp += str.charAt(Math.floor(Math.random() * len)); &#125; return tmp;&#125;;alert(getRandomString(10)) 5. 阶乘算法123456789101112131415function factorialize(num) &#123; var result = num; if (num &lt; 0) &#123; return -1; &#125; else if (num === 0 || num === 1) &#123; return 1; &#125; else &#123; while (num &gt; 1) &#123; num--; result *= num; &#125; &#125; return result;&#125;alert(factorialize(5)); 6. 数组排序6.1 快速排序 在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 快排的时间复杂度是O(nlogn)，属于不稳定的排序! 123456789101112131415161718192021222324function quickSort(arr)&#123; //如果数组&lt;=1,则直接返回 if(arr.length&lt;=1)&#123;return arr;&#125; var pivotIndex=Math.floor(arr.length/2); //找基准，并把基准从原数组删除 var pivot=arr.splice(pivotIndex,1)[0]; //定义左右数组 var left=[]; var right=[]; //比基准小的放在left，比基准大的放在right for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;=pivot)&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125;var arr=[3,1,5,2,6];alert(quickSort(arr)) 6.2. 冒泡排序 冒泡排序分两种，一种小泡泡往上吐，一种大泡泡往上吐。也就是从小到大和从大到小。 具体步骤: 冒泡排序就是从最开始的位置或结尾的位置反方向对比，如果比它大/小,就交换然后继续走，第一遍走完,最后一个位置是最大值或者最小值。 1234567891011121314151617181920212223242526272829303132333435363738function bubbleSort(arr)&#123; for(var i=1;i&lt;arr.length;i++)&#123; for(var j=0;j&lt;arr.length-i;j++)&#123; var temp; if(arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr;&#125;var arr=[2,3,1,4,11,58,45];alert(bubbleSort(arr));//冒泡排序逻辑var array=[1,20,4,18,7,3];var temp=0;document.writeln(\"排序前:\"+array+\"&lt;/br&gt;\");for(var i=0;i&lt;array.length-1;i++)&#123; for(var j=i+1;j&lt;array.length;j++) &#123; if(array[i]&gt;array[j]) &#123; temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; &#125; var m=i+1; document.write(\"第\"+m+\"次排序:\"+array+\"&lt;/br&gt;\");&#125;document.writeln(\"排序后:\"+array+\"&lt;/br&gt;\");document.write(arr); 6.3 插入排序1234567891011121314151617//插入排序Array.prototype.insertSort=function()&#123; var len = this.length, i, j, tmp; for(i=1; i&lt;len; i++)&#123; tmp = this[i]; j = i - 1; //初始时数组索引值为1的与为0的比较，如果索引值为1的小于则将其值换为索引值为0的 while(j&gt;=0 &amp;&amp; tmp &lt; this[j])&#123; this[j+1] = this[j]; j--; &#125; //随着j--循环的次，则找到tmp的前面有序区应该的位置。 this[j+1] = tmp; &#125; return this;&#125; 关于更多的排序知识，可移步 这里。 7. 求一个数组的最大差值12345678910111213141516var getMaxProfit = function(arr)&#123; // 定义两个变量，分别存贮最大值和最小值 var maxNum = arr[0]; var minNum = arr[0]; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &gt; maxNum)&#123; maxNum = arr[i]; &#125; if(arr[i] &lt; minNum)&#123; minNum = arr[i]; &#125; &#125; return maxNum - minNum;&#125;;var arr=[1,2,3,4,5,6];alert(getMaxProfit(arr)) 8. 数组的偶数位删除123456789101112var arr=[];for(var i=1;i&lt;=100;i++)&#123; arr.push(i);&#125;do&#123; for(var a=arr.length;a&gt;0;a--)&#123; if(a%2==1)&#123; arr.splice(a,1); &#125; &#125;&#125;while (arr.length&gt;2);alert(arr); 9. 数组去重9.1 利用 key 去重12345678910111213function unique(arr)&#123; var hashTable = &#123;&#125;; var data = []; for(var i = 0, l = arr.length; i &lt; l; i++) &#123; if(!hashTable[arr[i]]) &#123; hashTable[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data;&#125;var arr=[2,3,4,5,2,3,6,1,6];alert(unique(arr)) 9.2 逻辑去重123456789101112var arr=[21,32,45,32,21,56,45];function fn(arr) &#123; var temp=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(temp.indexOf(arr[i])==-1)&#123; temp.push(arr[i]); &#125; &#125; return temp;&#125;var a=fn(arr);//接收返回值document.write(a); 9.3 传统 key 方法12345678910111213141516171819var arr=[2,3,1,4,2,1,4,12,12,3,5,6,5];function toObject(arr)&#123; var obj=&#123;&#125;; for(var i=0;i&lt;arr.length;i++)&#123; obj[arr[i]]=true; &#125; return obj;&#125;function toArr(obj)&#123; var arr=[]; for(var attr in obj)&#123; arr.push(attr); &#125; return arr;&#125;function newArr(Arr)&#123; return toArr(toObject(Arr))&#125;alert(newArr(arr)); 10. 水仙花数及四叶玫瑰数12345678910111213141516171819202122for(var i = 100; i &lt;= 999; i++) &#123; var g, s, b; g = i % 10; s = parseInt(i / 10) % 10; b = parseInt(i / 100); var sum1 = g * g * g + s * s * s + b * b * b; if(i == sum1) &#123; document.write(i + '&lt;br/&gt;'); &#125;;&#125; //水仙花数for(var i = 1000; i &lt;= 9999; i++) &#123; var g, s, b, q; g = i % 10; s = parseInt(i / 10) % 10; b = parseInt(i / 100) % 10; q = parseInt(i / 1000); var sum2 = g * g * g * g + s * s * s * s + b * b * b * b + q * q * q * q; if(i == sum2) &#123; document.write(i + '&lt;br/&gt;'); &#125;;&#125; //四叶玫瑰数 11. 交换两个值为数字的两个变量的值12345678910var swap = function(a,b)&#123; if(a === b)&#123; return [a,b]; &#125; b = b - a; // 此处的 b - a中的b和a的值是最初的值 a = a + b; // a = a + b -a; 实现了将b的值赋给a b = a - b; // b = a - (b - a) = 2a - b 相当于 2b = 2a;实现了将a的值赋给b return [a,b];&#125;;alert(swap(3,6))","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"原生 JavaScript 实现 AJAX、JSONP","slug":"article-js-ajax-jsonp","date":"2017-02-14T05:15:15.000Z","updated":"2021-06-24T04:02:41.962Z","comments":true,"path":"2017/02/14/article-js-ajax-jsonp/","link":"","permalink":"https://doubleray.top/2017/02/14/article-js-ajax-jsonp/","excerpt":"本文转自 TG 的 原生 JavaScript 实现 AJAX、JSONP。 相信大多数前端开发者在需要与后端进行数据交互时，为了方便快捷，都会选择JQuery中封装的AJAX方法，但是有些时候，我们只需要JQuery的AJAX请求方法，而其他的功能用到的很少，这显然是没必要的。 其实，原生JavaScript实现AJAX并不难，这篇文章将会讲解如何实现简单的AJAX，还有跨域请求JSONP！","text":"本文转自 TG 的 原生 JavaScript 实现 AJAX、JSONP。 相信大多数前端开发者在需要与后端进行数据交互时，为了方便快捷，都会选择JQuery中封装的AJAX方法，但是有些时候，我们只需要JQuery的AJAX请求方法，而其他的功能用到的很少，这显然是没必要的。 其实，原生JavaScript实现AJAX并不难，这篇文章将会讲解如何实现简单的AJAX，还有跨域请求JSONP！ 1. AJAX一个完整的AJAX请求一般包括以下步骤： 实例化XMLHttpRequest对象 连接服务器 发送请求 接收响应数据 我将AJAX请求封装成ajax()方法，它接受一个配置对象params。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; // 判断是ajax请求还是jsonp请求 var json = params.jsonp ? jsonp(params) : json(params); // ajax请求 function json(params) &#123; // 请求方式，默认是GET params.type = (params.type || 'GET').toUpperCase(); // 避免有特殊字符，必须格式化传输数据 params.data = formatParams(params.data); var xhr = null; // 实例化XMLHttpRequest对象 if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet('Microsoft.XMLHTTP'); &#125;; // 监听事件，只要 readyState 的值变化，就会调用 readystatechange 事件 xhr.onreadystatechange = function() &#123; // readyState属性表示请求/响应过程的当前活动阶段，4为完成，已经接收到全部响应数据 if (xhr.readyState == 4) &#123; var status = xhr.status; // status：响应的HTTP状态码，以2开头的都是成功 if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; var response = ''; // 判断接受数据的内容类型 var type = xhr.getResponseHeader('Content-type'); if (type.indexOf('xml') !== -1 &amp;&amp; xhr.responseXML) &#123; response = xhr.responseXML; //Document对象响应 &#125; else if (type === 'application/json') &#123; response = JSON.parse(xhr.responseText); //JSON响应 &#125; else &#123; response = xhr.responseText; //字符串响应 &#125;; // 成功回调函数 params.success &amp;&amp; params.success(response); &#125; else &#123; params.error &amp;&amp; params.error(status); &#125; &#125;; &#125;; // 连接和传输数据 if (params.type == 'GET') &#123; // 三个参数：请求方式、请求地址(get方式时，传输数据是加在地址后的)、是否异步请求(同步请求的情况极少)； xhr.open(params.type, params.url + '?' + params.data, true); xhr.send(null); &#125; else &#123; xhr.open(params.type, params.url, true); //必须，设置提交时的内容类型 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); // 传输数据 xhr.send(params.data); &#125; &#125; //格式化参数 function formatParams(data) &#123; var arr = []; for (var name in data) &#123; // encodeURIComponent() ：用于对 URI 中的某一部分进行编码 arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125;; // 添加一个随机数参数，防止缓存 arr.push('v=' + random()); return arr.join('&amp;'); &#125; // 获取随机数 function random() &#123; return Math.floor(Math.random() * 10000 + 500); &#125;&#125; 在上面的代码中，已经添加具体的注释，如需了解更多AJAX，可查看 TG 的书籍《JavaScript半知半解》中的AJAX章节：AJAX。 使用实例： 123456789ajax(&#123; url: 'test.php', // 请求地址 type: 'POST', // 请求类型，默认\"GET\"，还可以是\"POST\" data: &#123;'b': '异步请求'&#125;, // 传输数据 success: function(res)&#123; // 请求成功的回调函数 console.log(JSON.parse(res)); &#125;, error: function(error) &#123;&#125; // 请求失败的回调函数&#125;); 2. JSONP 同源策略 AJAX之所以需要“跨域”，罪魁祸首就是浏览器的同源策略。即，一个页面的AJAX只能获取这个页面相同源或者相同域的数据。 如何叫“同源”或者“同域”呢？——_协议、域名、端口号都必须相同_。例如： 123http://example.com 和 https://example.com 不同，因为协议不同； http://localhost:8080 和 http://localhost:1000 不同，因为端口不同； http://localhost:8080 和 https://example.com 不同，协议、域名、端口号都不同，根本不是一家的。 当跨域请求时，一般都会看到这个错误： 1XMLHttpRequest cannot load http://ghmagical.com/article/?intro=jsonp%E8%AF%B7%E6%B1%82&amp;v=5520. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost&apos; is therefore not allowed access. 那如何跨域请求呢？这时，JSONP就登场了！ JSONP(JSON with Padding) 是一种跨域请求方式。主要原理是利用了script 标签可以跨域请求的特性，由其 src 属性发送请求到服务器，服务器返回 JavaScript 代码，浏览器接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。 JSONP由两部分组成：回调函数和数据，回调函数一般是在浏览器控制，作为参数发往服务器端（当然，你也可以固定回调函数的名字，但客户端和服务器端的名称一定要一致）。当服务器响应时，服务器端就会把该函数和数据拼成字符串返回。 JSONP的请求过程： 请求阶段：浏览器创建一个 script 标签，并给其src 赋值(类似 http://example.com/api/?callback=jsonpCallback）。 发送请求：当给script的src赋值时，浏览器就会发起一个请求。 数据响应：服务端将要返回的数据作为参数和函数名称拼接在一起(格式类似”jsonpCallback({name: &#39;abc&#39;})”)返回。当浏览器接收到了响应数据，由于发起请求的是 script，所以相当于直接调用 jsonpCallback 方法，并且传入了一个参数。 用原生JavaScript如何实现 依旧是ajax()方法里添加JSONP，后面会将两者整合在一起，JSONP的配置参数主要多了一个jsonp参数，它就是你的回调函数名。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; var json = params.jsonp ? jsonp(params) : json(params); // jsonp请求 function jsonp(params) &#123; //创建script标签并加入到页面中 var callbackName = params.jsonp; var head = document.getElementsByTagName('head')[0]; // 设置传递给后台的回调参数名 params.data['callback'] = callbackName; var data = formatParams(params.data); var script = document.createElement('script'); head.appendChild(script); //创建jsonp回调函数 window[callbackName] = function(json) &#123; head.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; params.success &amp;&amp; params.success(json); &#125;; //发送请求 script.src = params.url + '?' + data; //为了得知此次请求是否成功，设置超时处理 if (params.time) &#123; script.timer = setTimeout(function() &#123; window[callbackName] = null; head.removeChild(script); params.error &amp;&amp; params.error(&#123; message: '超时' &#125;); &#125;, time); &#125; &#125;; //格式化参数 function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125;; // 添加一个随机数，防止缓存 arr.push('v=' + random()); return arr.join('&amp;'); &#125; // 获取随机数 function random() &#123; return Math.floor(Math.random() * 10000 + 500); &#125;&#125; 注意：因为 script 标签的 src 属性只在第一次设置的时候起作用，导致 script 标签没法重用，所以每次完成操作之后要移除； 使用实例： 1234567891011121314151617ajax(&#123; url: 'test.php', // 请求地址 jsonp: 'jsonpCallback', // 采用jsonp请求，且回调函数名为\"jsonpCallbak\"，可以设置为合法的字符串 data: &#123;'b': '异步请求'&#125;, // 传输数据 success:function(res)&#123; // 请求成功的回调函数 console.log(res); &#125;, error: function(error) &#123;&#125; // 请求失败的回调函数&#125;); 注意：别漏了用函数名与数据拼接返回。 当然，前面也说过，你可以给定固定回调函数名： 123function jsonpCallback() &#123;&#125;&lt;?php echo 'jsonpCallback('.$data.')'; 最后我已经将AJAX和JSONP请求合并在一起了，下载链接：ajax.zip。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://doubleray.top/tags/Ajax/"},{"name":"jsonp","slug":"jsonp","permalink":"https://doubleray.top/tags/jsonp/"}]},{"title":"webpack 入门指南","slug":"article-webpack-know","date":"2017-02-12T05:15:15.000Z","updated":"2021-06-24T04:02:41.982Z","comments":true,"path":"2017/02/12/article-webpack-know/","link":"","permalink":"https://doubleray.top/2017/02/12/article-webpack-know/","excerpt":"本文转自博客园的 一小时包教会 —— webpack 入门指南。 有些知识点已过时，请参考结合 webpack 3 入门指南 webpack 是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如 JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。 你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。","text":"本文转自博客园的 一小时包教会 —— webpack 入门指南。 有些知识点已过时，请参考结合 webpack 3 入门指南 webpack 是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如 JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。 你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。 我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。s 想对其进行更详细了解的可以点 webpack的官网 及 文档地址 进去瞧一瞧。 webpack 的优势主要可以归类为如下几个： webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。 我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调： 12345678define(['package/lib'], function(lib)&#123; function foo()&#123; lib.log('hello world!'); &#125; return &#123; foo: foo &#125;;&#125;); 另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写： 123456789101112define(function (require, exports, module)&#123; var someModule = require(\"someModule\"); var anotherModule = require(\"anotherModule\"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;;&#125;); 然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）： 12345678910var someModule = require(\"someModule\"); var anotherModule = require(\"anotherModule\"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;; 这样撸码自然更简单，跟回调神马的说 byebye～～不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。 1. 安装和配置1.1 安装 我们常规直接使用 npm 的形式来安装： $ npm install webpack -g 当然如果常规项目还是把依赖写入 package.json 包去更人性化： $ npm init $ npm install webpack --save-dev1.2 配置 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 我们看看下方的示例： 1234567891011121314151617181920212223242526272829303132333435var webpack = require('webpack');var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : './src/js/page/index.js' &#125;, //入口文件输出配置 output: &#123; path: 'dist/js/page', filename: '[name].js' &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: &#123; AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125;&#125;; plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。 entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为： 1234567891011&#123; entry: &#123; page1: \"./page1\", //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 page2: [\"./entry1\", \"./entry2\"] &#125;, output: &#123; path: \"dist/js/page\", filename: \"[name].bundle.js\" &#125;&#125; 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。 module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理： 12345678910111213module: &#123; //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, //.js 文件使用 jsx-loader 来编译处理 &#123; test: /\\.js$/, loader: 'jsx-loader?harmony' &#125;, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 &#123; test: /\\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125; 如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。 注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。 拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装： npm install url-loader -save-dev 配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。 最后是 resolve 配置，这块很好理解，直接写注释了： 123456789101112resolve: &#123; //查找module的话从这里开始查找 root: 'E:/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.js', '.json', '.scss'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125; 关于 webpack.config.js 更详尽的配置可以参考这里。 2. 运行 webpack webpack 的执行也很简单，直接执行： webpack –display-error-details 即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。 其他主要的参数有： 1234567$ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包 $ webpack --watch //监听变动并自动打包 $ webpack -p //压缩混淆脚本，这个非常非常重要！ $ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。 3. 模块引入 上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。 3.1 HTML 直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"dist/js/page/common.js\"&gt;&lt;/script&gt; &lt;script src=\"dist/js/page/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成并标签打到head里。 3.2 JS 各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。 我们再看看编译前的页面入口文件（index.js）： 1234567891011121314151617181920212223require('../../css/reset.scss'); //加载初始化样式require('../../css/allComponent.scss'); //加载组件样式var React = require('react');var AppWrap = require('../component/AppWrap'); //加载组件var createRedux = require('redux').createRedux;var Provider = require('redux/react').Provider;var stores = require('AppStore'); var redux = createRedux(stores); var App = React.createClass(&#123; render: function() &#123; return ( &lt;Provider redux=&#123;redux&#125;&gt; &#123;function() &#123; return &lt;AppWrap /&gt;; &#125;&#125; &lt;/Provider&gt; ); &#125;&#125;); React.render( &lt;App /&gt;, document.body); 一切就是这么简单么么哒~~ 后续各种有的没的，webpack 都会帮你进行处理。 4. 其他 至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。 4.1 shimming 在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙： { test: require.resolve(&quot;./src/js/tool/swipe.js&quot;), loader: &quot;exports?swipe&quot;} 之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了： 12require('./tool/swipe.js');swipe(); 4.2 自定义公共模块提取 在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。 但有时候我们希望能更加个性化一些，我们可以这样配置： 1234567891011121314151617181920212223var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; p1: \"./page1\", p2: \"./page2\", p3: \"./page3\", ap1: \"./admin/page1\", ap2: \"./admin/page2\" &#125;, output: &#123; filename: \"[name].js\" &#125;, plugins: [ new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]), new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"]) ]&#125;;// &lt;script&gt;s required:// page1.html: commons.js, p1.js// page2.html: commons.js, p2.js// page3.html: p3.js// admin-page1.html: commons.js, admin-commons.js, ap1.js// admin-page2.html: commons.js, admin-commons.js, ap2.js 4.3 独立打包样式文件 有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙： 123456789var webpack = require('webpack'); var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); var ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); module.exports = &#123; plugins: [commonsPlugin, new ExtractTextPlugin(\"[name].css\")], entry: &#123;&#125; &#125; //...省略其它配置 最终 webpack 执行后会乖乖地把样式文件提取出来： 4.4 使用CDN/远程文件 有时候我们希望某些模块走CDN并以的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。 这时候我们可以在配置文件里使用 externals 属性来帮忙： 1234567&#123; externals: &#123; // require(\"jquery\") 是引用自外部模块的 // 对应全局变量 jQuery \"jquery\": \"jQuery\" &#125;&#125; 需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。 我们倒也可以使用 script.js 在脚本中来加载我们的模块： 1234var $script = require(\"scriptjs\");$script(\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\", function() &#123; $('body').html('It works!')&#125;); 4.5 与 grunt/gulp 配合 以 gulp 为示例，我们可以这样混搭： 123456789101112gulp.task(\"webpack\", function(callback) &#123; // run webpack webpack(&#123; // configuration &#125;, function(err, stats) &#123; if(err) throw new gutil.PluginError(\"webpack\", err); gutil.log(\"[webpack]\", stats.toString(&#123; // output options &#125;)); callback(); &#125;);&#125;); 当然我们只需要把配置写到 webpack({ ... }) 中去即可，无须再写 webpack.config.js 了。更多参照信息请参阅：grunt配置 / gulp配置 。 4.6 React 相关1 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。 2 react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！ 基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考这篇文章来入门： webpack-howto。","categories":[{"name":"前沿技术","slug":"前沿技术","permalink":"https://doubleray.top/categories/前沿技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://doubleray.top/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"},{"name":"webpack","slug":"webpack","permalink":"https://doubleray.top/tags/webpack/"}]},{"title":"详解五种跨域方式及其原理","slug":"article-js-jsonp","date":"2017-02-10T06:41:15.000Z","updated":"2021-06-24T04:02:41.967Z","comments":true,"path":"2017/02/10/article-js-jsonp/","link":"","permalink":"https://doubleray.top/2017/02/10/article-js-jsonp/","excerpt":"这里说的 js 跨域是指通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。","text":"这里说的 js 跨域是指通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。 本文参考自 JavaScript （微信公众号）。 同源定义： 如果两个页面拥有相同的协议（protocol），端口（如果指定），和主机，那么这两个页面就属于同一个源（origin）。以下是同源检测的示例： URL结果原因http://store.company.com/dir2/other.htmlSuccesshttp://store.company.com/dir/inner/another.htmlSuccesshttps://store.company.com/secure.htmlFailure协议不同http://store.company.com:81/dir/etc.htmlFailure端口不同http://news.company.com/dir/other.htmlFailure主机不同 1. jsonp script 标签是不受同源策略影响的，它可以引入来自任何地方的 js 文件。 而 jsonp 的原理就是，在客户端和服务端定义一个函数，当客户端发起一个请求时，服务端返回一段javascript代码，其中调用了在客户端定义的函数，并将相应的数据作为参数传入该函数。 1234567891011function jsonp_cb(data) &#123; console.log(data);&#125;function ajax()&#123; var url = \"http://xx.com/test.php?jsonp_callback=jsonp_cb\"; var script = document.createElement('script'); // 发送请求 script.src = url; document.head.appendChild(script);&#125;ajax() 服务端获取到jsonp_callback传递的函数名jsonp_cb，返回一段对该函数调用的js代码： 123jsonp_cb(&#123; \"name\": \"story\"&#125;); 2. img ping img 标签也是没有跨域限制的，但它只能用来发送 GET 请求，且无法获取服务端的响应文本，可以利用它实现一些简单的、单向的跨域通信，例如跟踪用户的点击： 1234567var img = new Image();img.onload = function()&#123; console.log('done') img.onload = null; img = null;&#125;img.src = \"http://xx/xx.gif\" 3. window.name window 对象拥有 name 属性，它有一个特点：相同协议下，在一个页面中，不随URL的改变而改变。 示例代码: 123window.name = 'string' // 字符串，一般允许的最大值为2Mconsole.log(window.name)location = 'http://funteas.com/' 此时，在控制台输入 window.name，结果依然是”string” 1window.name // \"string\" window.name 的值只能是字符串，任何其他类型的值都会“转化”为字符串，例如： 123window.name = function()&#123;&#125;console.log(window.name)// \"function()&#123;&#125;\" 通过 window.name 实现跨域也很简单，iframe 拥有 contentWindow 属性，其指向该 iframe 的 window 对象的引用，如果在 iframe 的 src 指向的页面中设置 window.name 值，那么就可以通过 iframe.contentWindow.name 就可以拿到这个值了。 12345678var url = \"http://funteas.com/lab/windowName\";var iframe = document.createElement('iframe')iframe.onload = function()&#123; var data = iframe.contentWindow.name console.log(data)&#125;iframe.src = urldocument.body.appendChild(iframe) 然而，chrome 会提示你跨域了！而我们已经知道 window.name 不随 URL 的改变而改版，也就是说，onload 时，已经获取到了 name，只不过因为不同源，当前页面的脚本无法拿到 iframe.contentWindow.name，此时只需要把 iframe.src 改为同源即可。 123456789var url = \"http://funteas.com/lab/windowName\";var iframe = document.createElement('iframe')iframe.onload = function()&#123; iframe.src = 'favicon.ico'; var data = iframe.contentWindow.name console.log(data)&#125;iframe.src = urldocument.body.appendChild(iframe) 刷新页面，你会发现 iframe 不断刷新，这是因为每次 onload，iframe 的 src 被修改，然后再次触发 onload，从而导致iframe 循环刷新，修改下即可： 123456789101112131415var url = \"http://funteas.com/lab/windowName\";var iframe = document.createElement('iframe')var state = true;iframe.onload = function()&#123; if(state === true)&#123; iframe.src = 'favicon.ico'; state = false; &#125;else if(state === false)&#123; state = null var data = iframe.contentWindow.name console.log(data) &#125;&#125;iframe.src = urldocument.body.appendChild(iframe) 上面请求的是一个静态页面，而服务端通常需要的是动态数据： 1echo '&lt;script&gt; window.name = \"&#123;\\\"name\\\":\\\"story\\\"&#125;\"&lt;/script&gt;'; 4. postMessage postMessage 允许不同源之间的脚本进行通信，用法： 1otherWindow.postMessage(message, targetOrigin); otherWindow 引用窗口 iframe.contentwindow 或 window.open返回的对象 message 为要传递的数据 targetOrigin 为目标源 123456789101112131415161718192021222324// http://127.0.0.1:80var iframe = document.createElement('iframe')iframe.onload = function()&#123; var popup = iframe.contentWindow popup.postMessage(\"hello\", \"http://127.0.0.1:5000\");&#125;iframe.src = 'http://127.0.0.1:5000/lab/postMessage'document.body.appendChild(iframe)// 监听返回的postMessagewindow.addEventListener(\"message\", function(event)&#123; if (event.origin !== \"http://127.0.0.1:5000\") return; console.log(event.data)&#125;, false)// http://127.0.0.1:5000/lab/postMessagewindow.addEventListener(\"message\", function(event)&#123; // 验证消息来源 if (event.origin !== \"http://127.0.0.1\") return; console.log(event.source); // 消息源 popup console.log(event.origin); // 消息源URI https://secure.example.net console.log(event.data); // 来自消息源的数据 hello // 返回数据 var message = 'world'; event.source.postMessage(message, event.origin);&#125;, false); 5. CORS CORS（跨域资源共享）是一种跨域访问的机制，可以让 AJAX 实现跨域访问。它允许一个域上的脚本向另一个域提交跨域 AJAX 请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。 12Access-Control-Allow-Origin: * // 允许来自任何域的请求Access-Control-Allow-Origin: http://funteas.com/ // 仅允许来自http://funteas.com/的请求 当客户端的 ajax 请求的 url 为其他域时，对于支持 CORS 的浏览器，请求头会自动添加 Origin，值为当前 host。 1234var xhr = new XMLHttpRequest();var url = 'http://bar.other/resources/public-data/';xhr.open('GET', url, true);xhr.send(); CORS 默认不发送 cookie，如果要发送 cookie，需要设置 withCredentials： 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 同时，服务端也要设置： 1Access-Control-Allow-Credentials: true 详细可查看MDN 关于CORS的介绍。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"Ajax 基础详解","slug":"article-js-ajax","date":"2017-02-09T13:25:15.000Z","updated":"2021-06-24T04:02:41.962Z","comments":true,"path":"2017/02/09/article-js-ajax/","link":"","permalink":"https://doubleray.top/2017/02/09/article-js-ajax/","excerpt":"Ajax 全称为“Asynchronous JavaScript And XML”（异步 JavaScript 和 XML） 是指一种创建交互式网页应用的开发技术、改善用户体验，实现无刷新效果。","text":"Ajax 全称为“Asynchronous JavaScript And XML”（异步 JavaScript 和 XML） 是指一种创建交互式网页应用的开发技术、改善用户体验，实现无刷新效果。 Ajax 基础1. 什么是 Ajax Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术。它是一套综合了多项技术的浏览器端网页开发技术。这些技术包括Javascript、XHTML 和 CSS、DOM、XML 和 XMLHttpRequest。 2. 为什么使用 Ajax？ 优点: 使用 Ajax 的最大优点，就是能在不更新整个页面的前提下维护数据。这使得 Web 应用程序更为迅捷地响应用户动作，并避免了在网络上发送那些没有改变的 html 代码信息。 减轻服务器负担，按需要获得数据。 无刷新更新页面，减少用户的实际和心理的等待时间。 更好的用户体验。 减轻宽带的负担。 主流浏览器支持。 缺点: Ajax 的程序必须测试针对各个浏览器的兼容性。 Ajax 更新页面内容的时候并没有刷新整个页面，因此，网页的后退功能是失效的；需提醒用户。 对搜索引擎支持不好。 3. Ajax 原理 运用 HTML 和 css 来实现页面,表达信息 通过浏览器的 XmlHttpRequest ( Ajax 引擎)对象 来向服务器(发送异步请求)并(接收服务器)的响应数据， 然后用 JavaScript 来操作 DOM，实现动态局部刷新。 4. Ajax 实现过程通常是： 第一步: Javascript 监听浏览器网页事件(点击,提交,更改等) 第二步:由 Javascript 创建 Ajax 引擎对象 第三步:通过 Ajax 引擎对象发出请求 第四步: Ajax 引擎等待并且接受服务器的响应内容 第五步: Javascript 再从 Ajax引擎对象 中获取响应内容,并且通过 DOM 改变网页界面显示效果 4.1 创建Ajax引擎对象 Ajax 引擎对象，就是 XMLHtttpRequest 对象,所有现代浏览器均支持 XMLHttpRequest 对象。 兼容性处理： 12345678var xhr = null;if (window.XMLHttpRequest) &#123; //所有现代浏览器(IE7+.Firefox.Chrome.Safari以及opera) xhr = new XMLHttpRequest;&#125;else&#123; //老版本的Internet Explorer使用ActiveX对象 xhr = new ActiveXObject(\"Microsoft.XMLHttp\");&#125; 4.2 配置请求对象的信息12345xhr.open('GET/POST','url地址',['是否异步']);//注意：如果使用post请求,就一定要设置请求头xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded;charset=gb2312\"); 4.3 发送请求1xhr.send([post请求参数字符串]); 发送请求分为两种情况: 监控用户的事件(onclick,onchange等),通过ajax发送请求 监控浏览器的事件(onload),通过ajax发送请求 4.4 监听 Ajax 引擎对象的改变(是否正确做出了响应)123456xmlHttpRequest.onreadystatechange = function()&#123; if (xmlHttpRequest.readyState== 4 &amp;&amp; xmlHttpRequest==200) &#123; //xmlHttpRequest.responseText //xmlHttpRequest.responseText &#125;&#125; 详解 onreadystatechange onreadystatechange属性是一个方法，监控到响应内容的返回，根据响应内容使用javascript改变当前页面的部分html代码,从而达到不刷新改变局部html代码。当 Ajax 引擎的状态发生改变时都会执行onreadystatechange属性对应的方法。 其他方法： abort:取消当前请求 getAllResponseHeaders:获取响应的所有http头 getResponseHeader:从响应信息中获取指定的http头 open(方式get/post，url地址，同步异步): 创建一个新的http请求，打开请求，并指定此请求的方法、URL以及验证信息(用户名/密码) send():发送请求到http服务器并接收回应 setRequestHeader:单独指定请求的某个http头，header()设置http头协议信息 其他属性： onreadystatechange:指定当readyState属性改变时的事件处理句柄。 readyState:返回当前请求的状态，ajax行进过程中不同状态 responseBody:将回应信息正文以unsigned byte数组形式返回. responseStream:以Ado Stream对象的形式返回响应信息。 responseText:将响应信息作为字符串返回.只读 responseXML:将响应信息格式化为Xml Document对象并返回，只读 status:返回当前请求的http状态码. 200 ok 304 缓存；404 not found; 403 没有权限；501 服务器级别错误 statusText:返回当前请求的响应行状态文本， ok not found forbidden 详解状态属性 readyState(0 1 2 3 4) 请求未初始化 服务器连接已建立 请求已接收 请求处理中 请求已完成,并且响应已就绪 当Ajax引擎的状态属性为readyState为 4 时,说明服务器的响应已经发送给 Ajax 请求了； 但是响应的状态吗为200时：说明响应的内容是正确的,这时才会根据相应内容对当前页面的html处理。 5. 总结示例123456789var xhr = new XMLHttpRequest;xhr.open('GET/POST','url地址',['是否异步']);xhr.send([post请求参数字符串]);xhr.onreadystatechange = function()&#123; if (xmlHttpRequest.readyState== 4 &amp;&amp; xmlHttpRequest==200) &#123; //做一些事情 //xhr.responseText &#125;&#125; Ajax 相关知识点1. 同步请求和异步请求 先解释一下同步和异步的概念： 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 1.1 同步请求 客户端请求(等待) -&gt; 服务端处理 -&gt; 响应 -&gt; 页面载入（缺少对象:XMLhttpRequest）这时候如果有错误，只能再次发送请求，再次等待。 1.2 异步请求 比如当你填写邮箱地址的时候，页面当时就把邮箱地址发送到了服务器（也就是页面发送了一个请求），服务器做处理和响应，得到你的邮箱地址填写重复了，把响应结果发给页面，在这个过程中你仍然可以填写其他内容，这时候服务器会提示你有重复的邮箱地址，在页面上的表现只是邮箱地址旁别加了一行字或者把整个文本框标红，并没有重新刷你的页面，所有的填写错误会实时的显示出来，你也会实时的更正。这个过程中，你会有整个页面的刷新，也不会有整个页面的提交和等待，最后提交，一切都会搞定的 页面上的操作和服务器端的操作互相之间不会造成阻塞！ 2. HTTP是什么 http 是计算机通过网络进行通信的规则。 一个完整的HTTP请求过程的七个步骤： 建立 TCP 连接 web 浏览器向 web 服务器发送请求命令 web 浏览器发送请求头信息 web 服务器应答 web 服务器发送应答头信息 web 服务器向浏览器发送数据 web 服务器关闭 TCP 连接 2.1 作用 客户端向服务端发送请求信息和服务。 客户端：自己的计算机的浏览器(web浏览器) 服务端：服务器,一台高性能的计算机，作为存储，处理网络上的数据，信息(web服务器) ，服务器指一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器、数据库服务器和应用程序服务器。运行以上软件的计算机或计算机系统也被称为服务器。 2.2 特点 是一种无状态的协议(不建立持久的连接,服务端不保留连接的信息)。 2.4 请求方法 GET： 一般用于信息获取,用get请求–&gt;查询或获取的操作 使用URL传递参数 对所发送信息的数量有限制,一般在2000个字 POST： 一般用于修改服务器上的数据.比如:新建,修改,删除,发送表单数据 对所发送信息的数量无限制 2.5 HTTP 状态码 100：信息类,表示web浏览器请求,正在进一步的处理中 200：成功,表示用户请求被正确接收正在进一步的处理中 200 OK 300：表示请求没有成功,客户端必须采取进一步的动作 400：客户端错误,表示客户端提交的请求有错误 例如:404 NOT Found,意味着请求中所引用的文档不存在 500：服务器错误 表示服务器不能完成对请求的处理,如500 2.6 HTTP 响应 HTTP 响应一般由三部分组成： 一个数字和文字组成的状态码,用来显示请求是成功还是失败 响应头:响应头也和请求头一样包含许多有用的信息,例如：服务器类型,日期时间,内容类型和长度等 响应体,也就是响应正文 2.7 HTTP 请求 HTTP 请求的四部分组成： HTTP 请求的方法或动作,比如 GET 还是 POST 正在请求的 URL,总得知道请求的地址是什么 请求头,包含一些客户端环境信息,身份验证信息等 请求体,也就是请求正文,请求正文中可以包含客户提交的查询字符串信息,表单信息等等","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://doubleray.top/tags/Ajax/"}]},{"title":"你可能学了假的 JavaScript！","slug":"article-js-kills1","date":"2017-02-08T06:41:15.000Z","updated":"2021-06-24T04:02:41.968Z","comments":true,"path":"2017/02/08/article-js-kills1/","link":"","permalink":"https://doubleray.top/2017/02/08/article-js-kills1/","excerpt":"Adobe 一个高级工程师 Dmitry Baranovskiy 在 他的博客 上写了这么一篇博文 So,you think you know JavaScript? ，并在博文中贴出了五个小示例（先不要看我贴的测试结果），大家可以感受一下，看看你是不是学了假的 JavaScript！","text":"Adobe 一个高级工程师 Dmitry Baranovskiy 在 他的博客 上写了这么一篇博文 So,you think you know JavaScript? ，并在博文中贴出了五个小示例（先不要看我贴的测试结果），大家可以感受一下，看看你是不是学了假的 JavaScript！ 1. 示例展示1234if (!(\"a\" in window)) &#123; var a = 1;&#125;alert(a); 12345var a = 1, b = function a(x) &#123; x &amp;&amp; a(--x); &#125;;alert(a); 12345function a(x) &#123; return x * 2;&#125;var a;alert(a); 12345function b(x, y, a) &#123; arguments[2] = 10; alert(a);&#125;b(1, 2, 3); 1234function a() &#123; alert(this);&#125;a.call(null); 感受完了请先将你的答案写出来，然后再去实际测试一下 … … 如果错了一两个说明你 JavaScript 基础不牢，如果错了三四个了，那就只能说明你学了假的 JavaScript！ 2. 示例测试 undefined 1 function a (x) {return x * 2;} 1、2、3、undefined、10 object Windows 3. 示例分析3.1 示例 1 示例1原型： 12345分析：首先会解析所有函数，其次是var声明的变量，但是不会赋值。因为javascript没有块的概念。像for(var i in array)这里的i依然是全局变量。 执行顺序： 1.var a;//声明一个变量，但是不会赋值 2.if语句，全局变量相当于window的属性，所以”a” in window为真，取反为假。故不会执行大括号里面的语句。 3.alert(a);//undefined 示例1变形： 1234if ((\"a\" in window)) &#123; var a = 1; &#125; alert (a); Javascript变量的scope是根据方法块来划分的（也就是说以function的一对大括号｛ ｝来划分）。切记，是function块，而for、while、if块并不是作用域的划分标准!所以这里的a依然是全局变量。 3.2 示例 2 示例2原型： 1234分析： JavaScript中定义变量时，也可以同时定义多个，例如var a,b,c;在定义变量时使用函数表达式就类似于局部变量，不会被全局作用域中访问到。 执行顺序： 1.声明两个变量var a,b;并给他们赋值a=1,b=function a()&#123;…&#125;;这里的function a是局部变量，外部无法访问到。因此全局a还是1. 2.alert(a);//1 示例2变形： 这样写的话大家比较一下可能更能理解一点。 12345678910var a = 1, b = function a (x) &#123; x &amp;&amp; a (--x); alert(a);//打印看一下a是什么值，和外面打印的a进行比较 return x;//返回一个值，这个值其实就是给b赋的值&#125;;alert (a);//这里只能取到全局变量aalert (a(1)); //报错: a is not a functionalert(b);alert(b(1)); 3.3 示例 3 示例3原型： 12345分析： js永远是先解析声明式函数，再解析变量。 执行顺序： 1.解析函数a; 2.声明变量var a;因为a此时没有被赋值，所以它还是指向原来的值。即function a; 3.alert(a); 示例3变形： 如果要证明js解析的顺序，很简单，把代码位置换一下： 12345var a;function a (x) &#123; return x * 2;&#125;alert (a); 3.4 示例 4 示例4原型： 1234分析：在函数内部可以引用一个对象，它是arguments类似数组，但不是数组。它代表了函数实际接收参数的集合。可以通过下标对相应参数进行访问。如果修改此对象某些属性，如arguments[index]，则被传进来的第index(如果有的话，下标从0开始)变量的值也会被修改。 执行顺序： 1.声明一个函数b; 2.执行函数b(1,2,3);因为这里arguments[2]与变量a引用的是一个值，所以当arguments[2]改变时，a也随之改变。 3.5 示例 5 示例5原型： 12345678call方法: 语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。分析： call方法接受多个参数，其作用是借用别人的方法当作自己的方法。这样能保证执行的时候this能够指向自己。call方法的第二个参数到最后一个参数是传给借用过来函数的。第一个参数是借用的对象，如果这个对象为空，那么将会作为全局window对象调用。即函数中的this指向window。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"mate 标签大集会","slug":"article-html-mate","date":"2017-02-05T05:13:05.000Z","updated":"2021-06-24T04:02:41.960Z","comments":true,"path":"2017/02/05/article-html-mate/","link":"","permalink":"https://doubleray.top/2017/02/05/article-html-mate/","excerpt":"meta 是 html 语言 head 区的一个辅助性标签。也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！","text":"meta 是 html 语言 head 区的一个辅助性标签。也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！ 1. meta 标签的组成 meta 标签的组成：meta 标签共有两个属性，它们分别是 http-equiv 属性和 name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1.1 name 属性 name 属性主要用于描述网页，与之对应的属性值为 content，content 中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 meta 标签的 name 属性语法格式是： 1&lt;meta name=\"参数\" content=\"具体的参数值\"&gt; 其中name属性常见有以下几种参数： Keywords(关键字)：告诉搜索引擎你网页的关键字是什么； description(网站内容描述)：告诉搜索引擎你的网站主要内容； robots(机器人向导)：告诉搜索机器人哪些页面需要索引，哪些页面不需要索引； author(作者)：标注网页的作者。 1.2 http-equiv 属性 http-equiv 顾名思义，相当于 http 的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为 content，content 中的内容其实就是各个参数的变量值。 meta 标签的 http-equiv 属性语法格式是： 1&lt;meta http-equiv=\"参数\" content=\"参数变量值\"&gt; 其中 http-equiv 属性常见有以下几种参数： Expires(期限)：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 Pragma(cache模式)：禁止浏览器从本地计算机的缓存中访问页面内容； X-UA-Compatible：是 IE8 的专用标记,用来指定 IE8 浏览器去模拟某个特定版本的IE浏览器的渲染方式； Refresh(刷新)：自动刷新并指向新页面； Set-Cookie(cookie设定)：如果网页过期，那么存盘的cookie将被删除； Window-target(显示窗口的设定)：强制页面在当前窗口以独立页面显示； content-Type(显示字符集的设定)：设定页面使用的字符集； content-Language（显示语言的设定）：设定页面的语言； Cache-Control：指定请求和响应遵循的缓存机制。 2. 常用 meta 标签总结2.1 name 属性123456789101112131415161718192021&lt;!-- 设置作者姓名及联系方式 --&gt;&lt;meta name=\"author\" contect=\"name, xxx@163.com\"&gt;&lt;!-- 页面描述 --&gt;&lt;meta name=\"description\" content=\"meta元素共有三个可选属性(不超过150字符)\" /&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name=\"keywords\" content=\"关键字1,关键字2,...\" /&gt;&lt;!-- 页面生成器 --&gt;&lt;meta name=\"generator\" content=\"hexo\" /&gt;&lt;!-- 页面修改信息 --&gt;&lt;meta name=\"revised\" content=\"story,2015/07/22\" /&gt;&lt;!-- 版权信息 --&gt;&lt;meta name=\"copyright\" content=\"All Rights Reserved\" /&gt;&lt;!-- 页面爬虫设置 --&gt;&lt;meta name=\"robots\" content=\"index,follow\" /&gt;&lt;!-- robots的content取值 --&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询 --&gt;&lt;!-- none：文件将不被检索，且页面上的链接不可以被查询 --&gt;&lt;!-- index：文件将被检索 --&gt;&lt;!-- follow：页面上的链接可以被查询 --&gt;&lt;!-- noindex：文件将不被检索，但页面上的链接可以被查询 --&gt;&lt;!-- nofollow：文件将被检索，但页面上的链接不可以被查询 --&gt; 2.2 http-equiv 属性123456789101112131415161718192021&lt;!-- 字符编码 --&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\" /&gt;&lt;meta charset=\"utf-8\"&gt;&lt;!--简写版--&gt;&lt;!-- 页面到期时间，必须使用GMT的时间格式 --&gt;&lt;meta http-equiv=\"expire\" content=\"Wed,22Jul201511:11:11GMT\" /&gt;&lt;!-- 页面重刷新，0秒后刷新并跳转 --&gt;&lt;meta http-equiv=\"refresh\" content=\"0;URL=''\" /&gt;&lt;!-- cookie设置 --&gt;&lt;meta http-equiv=\"set-cookie\" content=\"cookie value=xxx;expires=Wed,22-Jul-201511:11:11GMT；path=/\" /&gt;&lt;!-- 脚本类型 --&gt;&lt;meta http-equiv=\"Content-Script-Type\" content=\"text/javascript\"&gt;&lt;!-- 禁止从本地缓存中读取页面 --&gt;&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; &lt;!--清除缓存（再访问这个网站要重新下载！）--&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache, must-revalidate\"&gt; &lt;!--优先使用 IE 最新版本和 Chrome 内核--&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\" &gt;&lt;!--强制页面在当前窗口以独立页面显示，用来防止别人在框架里调用自己的页面--&gt;&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt;&lt;!--不让百度转码--&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\"&gt; 2.3 移动端1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no\"/&gt;&lt;!-- viewport的content取值 --&gt;&lt;!-- width：宽度（数值 / device-width）（200~10000，默认为980px） --&gt;&lt;!-- height：高度（数值 / device-height）（223~10000） --&gt;&lt;!-- initial-scale：初始缩放比例 （0~10） --&gt;&lt;!-- minimum-scale：允许用户缩放到的最小比例 --&gt;&lt;!-- maximum-scale：允许用户缩放到的最大比例 --&gt;&lt;!-- user-scalable：是否允许用户缩放 (no/yes) --&gt; &lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- IOS启用 WebApp 全屏模式 --&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;!-- IOS全屏模式下隐藏状态栏/设置状态栏颜色 content的值为default | black | black-translucent --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt;&lt;!-- IOS添加到主屏后的标题 --&gt;&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt;&lt;!-- IOS添加智能 App 广告条 Smart App Banner --&gt;&lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt;&lt;!--微软的老式浏览器--&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!--针对手持设备优化，主要是针对一些老的不识别 viewport 的浏览器，比如黑莓--&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 去除iphone 识别数字为号码 --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;&lt;!-- 不识别邮箱 --&gt;&lt;meta name=\"format-detection\" content=\"email=no\"&gt;&lt;!-- 禁止跳转至地图 --&gt;&lt;meta name=\"format-detection\" content=\"adress=no\"&gt;&lt;!-- 可以连写--&gt;&lt;meta name=\"format-detection\" content=\"telephone=no,email=no,adress=no\"&gt;&lt;!--启用360浏览器的极速模式(webkit)--&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt; 以上为平时常用 mate 标签，有遗漏的地方在下面留言就OK，会不断更新… …","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://doubleray.top/tags/HTML/"}]},{"title":"CSS：font 总结","slug":"article-css-font","date":"2017-02-04T06:41:15.000Z","updated":"2021-06-24T04:02:41.956Z","comments":true,"path":"2017/02/04/article-css-font/","link":"","permalink":"https://doubleray.top/2017/02/04/article-css-font/","excerpt":"","text":"本文记录总结一些平时经常用的字体知识，方便查阅。（font-family、font-size、font-weight等。） font-family 中文字体多数使用宋体、雅黑，英文用Helvetica，如下： 1body &#123; font-family: Microsoft Yahei,SimSun,Helvetica; &#125; 那么常用的中文字体的英文名称： 宋体 SimSun 黑体 SimHei 微信雅黑 Microsoft Yahei 微软正黑体 Microsoft JhengHei 新宋体 NSimSun 新细明体 MingLiU 细明体 MingLiU 标楷体 DFKai-SB 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 font-size 移动端字体单位 font-size 选择 px 还是 rem： 1234/*如需适配多种移动设备，建议使用rem。以下为参考值：*/html &#123; font-size: 62.5%; &#125; //10*16 = 62.5%/*设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级*/body &#123; font-size:12px; font-size:1.2rem; &#125; 针对谷歌默认最小字体12px的正确解决方案： 123456789.small-font&#123; font-size:12px; -webkit-transform-origin-x: 0; -webkit-transform: scale(0.90);&#125;/*兼容IE7，IE8*/.smallsize-font &#123; font-size:10.8px;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"}]},{"title":"有趣的 fullPage.js","slug":"article-js-fullpage","date":"2017-02-03T12:57:15.000Z","updated":"2021-06-24T04:02:41.966Z","comments":true,"path":"2017/02/03/article-js-fullpage/","link":"","permalink":"https://doubleray.top/2017/02/03/article-js-fullpage/","excerpt":"如今我们经常能见到全屏网站，尤其是国外网站。这些网站用几幅很大的图片或色块做背景，再添加一些简单的内容，显得格外的高端大气上档次。比如 iPhone 5C 的介绍页面（查看），QQ浏览器的官网站。如果你也希望你的网站能设计成全屏的，显得更上档次，你可以试试 fullPage.js。","text":"如今我们经常能见到全屏网站，尤其是国外网站。这些网站用几幅很大的图片或色块做背景，再添加一些简单的内容，显得格外的高端大气上档次。比如 iPhone 5C 的介绍页面（查看），QQ浏览器的官网站。如果你也希望你的网站能设计成全屏的，显得更上档次，你可以试试 fullPage.js。 演 示 下 载 1. 简介 fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站，主要功能有： 支持鼠标滚动 支持前进后退和键盘控制 多个回调函数 支持手机、平板触摸事件 支持 CSS3 动画 支持窗口缩放 窗口缩放时自动调整 可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等 2. 兼容性jQuery 兼容 兼容 jQuery 1.7+。 浏览器兼容IE8+ ✔Chrome ✔Firefox ✔Opera ✔Safari ✔ 3. 使用方法1、引入文件12345678910&lt;link rel=\"stylesheet\" href=\"css/jquery.fullPage.css\"&gt;&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jquery.easings.min.js 用于 easing 参数，也可以使用完整的 jQuery UI 代替，如果不需要设置 easing 参数，可去掉改文件 --&gt;&lt;script src=\"js/jquery.easings.min.js\"&gt;&lt;/script&gt;&lt;!-- 如果 scrollOverflow 设置为 true，则需要引入 jquery.slimscroll.min.js，一般情况下不需要 --&gt;&lt;script src=\"js/jquery.slimscroll.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.fullPage.js\"&gt;&lt;/script&gt; 2、HTML1234567891011121314&lt;div id=\"dowebok\"&gt; &lt;div class=\"section\"&gt; &lt;h3&gt;第一屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"section\"&gt; &lt;h3&gt;第二屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"section\"&gt; &lt;h3&gt;第三屏&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"section\"&gt; &lt;h3&gt;第四屏&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt; 每个 section 代表一屏，默认显示“第一屏”，如果要指定加载页面时显示的“屏幕”，可以在对应的 section 加上 class=”active”，如： 1&lt;div class=\"section active\"&gt;第三屏&lt;/div&gt; 同时，可以在 section 内加入 slide，如： 1234567891011&lt;div id=\"dowebok\"&gt; &lt;div class=\"section\"&gt;第一屏&lt;/div&gt; &lt;div class=\"section\"&gt;第二屏&lt;/div&gt; &lt;div class=\"section\"&gt; &lt;div class=\"slide\"&gt;第三屏的第一屏&lt;/div&gt; &lt;div class=\"slide\"&gt;第三屏的第二屏&lt;/div&gt; &lt;div class=\"slide\"&gt;第三屏的第三屏&lt;/div&gt; &lt;div class=\"slide\"&gt;第三屏的第四屏&lt;/div&gt; &lt;/div&gt; &lt;div class=\"section\"&gt;第四屏&lt;/div&gt;&lt;/div&gt; 3、JavaScript123$(function()&#123; $('#dowebok').fullpage();&#125;); 4. 配置1、选项选项类型默认值说明verticalCentered字符串true内容是否垂直居中resize布尔值false字体是否随着窗口缩放而缩放slidesColor函数无设置背景颜色anchors数组无定义锚链接scrollingSpeed整数700滚动速度，单位为毫秒easing字符串easeInQuart滚动动画方式menu布尔值false绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动navigation布尔值false是否显示项目导航navigationPosition字符串right项目导航的位置，可选 left 或 rightnavigationColor字符串#000项目导航的颜色navigationTooltips数组空项目导航的 tipslidesNavigation布尔值false是否显示左右滑块的项目导航slidesNavPosition字符串bottom左右滑块的项目导航的位置，可选 top 或 bottomcontrolArrowColor字符串#fff左右滑块的箭头的背景颜色loopBottom布尔值false滚动到最底部后是否滚回顶部loopTop布尔值false滚动到最顶部后是否滚底部loopHorizontal布尔值true左右滑块是否循环滑动autoScrolling布尔值true是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条scrollOverflow布尔值false内容超过满屏后是否显示滚动条css3布尔值false是否使用 CSS3 transforms 滚动paddingTop字符串0与顶部的距离paddingBottom字符串0与底部距离fixedElements字符串无normalScrollElements无keyboardScrolling布尔值true是否使用键盘方向键导航touchSensitivity整数5continuousVertical布尔值false是否循环滚动，与 loopTop 及 loopBottom 不兼容animateAnchor布尔值truenormalScrollElementTouchThreshold整数5 2、方法名称说明moveSectionUp()向上滚动moveSectionDown()向下滚动moveTo(section, slide)滚动到moveSlideRight()slide 向右滚动moveSlideLeft()slide 向左滚动setAutoScrolling()设置页面滚动方式，设置为 true 时自动滚动setAllowScrolling()添加或删除鼠标滚轮/触控板控制setKeyboardScrolling()添加或删除键盘方向键控制setScrollingSpeed()定义以毫秒为单位的滚动速度 3、回调函数名称说明afterLoad滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数，anchorLink 是锚链接的名称，index 是序号，从1开始计算onLeave滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数：index 是离开的“页面”的序号，从1开始计算；nextIndex 是滚动到的“页面”的序号，从1开始计算；direction 判断往上滚动还是往下滚动，值是 up 或 down。afterRender页面结构生成后的回调函数，或者说页面初始化完成后的回调函数afterSlideLoad滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收 anchorLink、index、slideIndex、direction 4个参数onSlideLeave某一水平滑块滚动前的回调函数，与 onLeave 类似，接收 anchorLink、index、slideIndex、direction 4个参数","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"常用 JavaScript 效果","slug":"article-js-effect","date":"2017-02-03T06:41:15.000Z","updated":"2021-06-24T04:02:41.966Z","comments":true,"path":"2017/02/03/article-js-effect/","link":"","permalink":"https://doubleray.top/2017/02/03/article-js-effect/","excerpt":"一直只顾着码效果，都是想到哪儿就写到哪儿，今天对平时用过的效果做一下总结。","text":"一直只顾着码效果，都是想到哪儿就写到哪儿，今天对平时用过的效果做一下总结。 1. 图片遮罩条 仿百度图片随鼠标划入划出方向入出（基于 JQuery）： 123456789101112131415161718192021222324252627282930313233function shade(parent,item) &#123; //parent为遮罩条的父级元素选择器 //item为遮罩条的选择名（字符串形式 如：\".span\"） parent.on('mouseenter mouseleave', function(e) &#123; var w = $(this).width(), h = $(this).height(), x = (e.pageX - this.offsetLeft - (w / 2)) * (w &gt; h ? (h / w) : 1), y = (e.pageY - this.offsetTop - (h / 2)) * (h &gt; w ? (w / h) : 1); var dirNum = Math.round((((Math.atan2(y, x) * (180 / Math.PI)) + 180) / 90) + 3) % 4; //根据鼠标的x，y随机出现0,1,2,3（来判断方向） var eventType = e.type; var aPos = [&#123; left: 0, bottom: h &#125;, &#123; left: w, bottom: 0 &#125;, &#123; left: 0, bottom: -h &#125;, &#123; left: -w, bottom: 0 &#125;]; //不同方向的动作放在一个数组里，用随机出来的的下标来取值 if (eventType == 'mouseenter') &#123; $(this).children(item).css(aPos[dirNum]).stop(true, true).animate(&#123; left: 0, bottom: 0 &#125;, 400); &#125; else &#123; $(this).children(item).stop(true, true).animate(aPos[dirNum], 400); &#125; &#125;); &#125; 2. 图片左右动作轮播 图片左右动作轮播（基于 JQuery）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function carouselA(parent,next,pre,btn) &#123;/** * parent为轮播图片的父级，一般为ul； * next为下一张图片的按钮 * pre为上一张图片的按钮 * btn为底部小圆点按钮（$('.btn li')） */ var timer = null, pIn = 0; clone = parent.children().first().clone(); //克隆了第一个li parent.append(clone); //放在了ul的最后 var picW = parent.children().width(), size = parent.children().size(); parent.width(picW * (size + 1)); btn.first().css('background', '#a10000'); ht(parent.children()); ht(pre); ht(next); ht(btn); timer = setInterval(function() &#123; pIn++; move(); &#125;, 2000); //轮播动起来 function ht(area) &#123; area.hover(function() &#123; clearInterval(timer); &#125;, function() &#123; timer = setInterval(function() &#123; pIn++; move(); &#125;, 2000); &#125;); &#125; //悬停动画 btn.hover(function() &#123; var index = $(this).index(); pIn = index; //将当前index给全局的索引，否则鼠标离开后会恢复到先前的索引 parent.stop().animate(&#123; left: -index * picW &#125;, 800); $(this).css('background', '#a10000').siblings().css('background', '#ddd'); &#125;); //按钮动作 pre.click(function() &#123; pIn++; move(); &#125;); //向左 next.click(function() &#123; pIn--; move(); &#125;); //向右 function move() &#123; //因为将第一li克隆后放在了最后，所以现在的索引是0-7 if (pIn == size) &#123; parent.css('left', 0); pIn = 1; &#125; if (pIn == -1) &#123; parent.css('left', -(size - 1) * picW); pIn = size - 2; &#125; parent.stop().animate(&#123; left: -pIn * picW &#125;, 800); if (pIn == size - 1) &#123; btn.eq(0).css('background', '#a10000').siblings().css('background', '#ddd'); &#125; else &#123; btn.eq(pIn).css('background', '#a10000').siblings().css('background', '#ddd'); &#125; &#125; &#125; 图片左右轮播（原生 js）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding:0;border:0;&#125; a&#123;text-decoration:none;color:#fff;font-size:40px;line-height:200px;display:none;text-align:center;&#125; #container&#123;width:300px;height:200px;margin:50px auto;position:relative;overflow:hidden;&#125; #list&#123;width:2100px;height:200px;position:absolute;top:0;&#125; #list span&#123;width:300px;height:200px;display:inline-block;text-align:center;font-size:22px;float:left;color:#fff;&#125; .one&#123;background:red;&#125; .two&#123;background:orange;&#125; .three&#123;background:blue;&#125; .four&#123;background:green;&#125; .five&#123;background:black;&#125; #buttons&#123;width:200px;height:30px;position:absolute;bottom:0px;left:100px;z-index:9;&#125; #buttons span&#123;display:inline-block;cursor:pointer;width:12px;height:12px;border-radius:6px;background: #2a2a2a&#125; #prev&#123;width:40px;height:200px;position:absolute;left:0px;&#125; #next&#123;width:40px;height:200px;position:absolute;right:0px;&#125; #container .on&#123;background:#fff;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt; &lt;div id=\"list\" style=\"left:-300px\"&gt; &lt;span class=\"five\"&gt;我是黑色第五张&lt;/span&gt; &lt;span class=\"one\"&gt;我是红色第一张&lt;/span&gt; &lt;span class=\"two\"&gt;我是黄色第二张&lt;/span&gt; &lt;span class=\"three\"&gt;我是蓝色第三张&lt;/span&gt; &lt;span class=\"four\"&gt;我是绿色第四张&lt;/span&gt; &lt;span class=\"five\"&gt;我是黑色第五张&lt;/span&gt; &lt;span class=\"one\"&gt;我是红色第一张&lt;/span&gt; &lt;/div&gt; &lt;div id=\"buttons\"&gt; &lt;span class=\"on\" index=\"1\"&gt;&lt;/span&gt; &lt;span index=\"2\"&gt;&lt;/span&gt; &lt;span index=\"3\"&gt;&lt;/span&gt; &lt;span index=\"4\"&gt;&lt;/span&gt; &lt;span index=\"5\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;a id=\"prev\" href=\"javascript:;\"&gt;&amp;lt;&lt;/a&gt; &lt;a id=\"next\" href=\"javascript:;\"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var container = document.getElementById('container'), list = document.getElementById('list'), buttons = document.getElementById('buttons').getElementsByTagName('span'), prev = document.getElementById('prev'), next = document.getElementById('next'), index = 1, len = 5, interval = 3000, animated = false, timer; function animate(offset)&#123; if(offset == 0) return; animated = true; var time = 150, inter = 5, speed = offset/(time/inter), left = parseInt(list.style.left) + offset; var go = function()&#123; if((speed&gt;0 &amp;&amp; parseInt(list.style.left)&lt;left) || (speed&lt;0 &amp;&amp; parseInt(list.style.left)&gt;left))&#123; list.style.left = parseInt(list.style.left) + speed + 'px'; setTimeout(go,inter); &#125;else&#123; list.style.left = left + 'px'; if(left &gt; -100)&#123; list.style.left = -300*len + 'px'; &#125; if(left &lt; (-300*len))&#123; list.style.left = '-300px' &#125; animated = false; &#125; &#125; go(); &#125; function showButton()&#123; for(var i=0 ; i&lt;buttons.length ; i++)&#123; if(buttons[i].className == 'on')&#123; buttons[i].className = ''; break; &#125; &#125; buttons[index - 1].className = 'on'; &#125; function play()&#123; timer = setTimeout(function()&#123; next.onclick(); play(); &#125;,interval); &#125; function stop()&#123; clearTimeout(timer); &#125; next.onclick = function()&#123; if(animated) &#123; return; &#125; if(index == 5)&#123; index = 1; &#125;else&#123; index++; &#125; animate(-300); showButton(); &#125; prev.onclick = function()&#123; if(animated) &#123; return; &#125; if(index == 1)&#123; index = 5; &#125;else&#123; index--; &#125; animate(300); showButton(); &#125; for (var i = 0; i &lt; buttons.length; i++) &#123; buttons[i].onclick = function () &#123; if (animated) &#123; return; &#125; if(this.className == 'on') &#123; return; &#125; var myIndex = parseInt(this.getAttribute('index')); var offset = -300 * (myIndex - index); animate(offset); index = myIndex; showButton(); &#125; &#125; container.onmouseover = function()&#123; prev.style.display = next.style.display = 'block'; stop(); &#125; container.onmouseout = function()&#123; prev.style.display = next.style.display = 'none'; play(); &#125; play(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. 返回顶部 返回顶部按钮(基于 JQuery)： 123456789101112131415function goTop(btn) &#123; $(window).scroll(function() &#123; if ($(window).scrollTop() &gt; 400) &#123; btn.fadeIn(800); &#125; else &#123; btn.fadeOut(1000); &#125; &#125;); //按钮消失和出现 btn.click(function() &#123; $('body,html').animate(&#123; scrollTop: 0 &#125;, 500); return false; &#125;); &#125; 4. 倒计时 获取验证码倒计时(基于 JQuery)： 1234567891011121314151617181920212223242526272829303132333435function countDown(btn) &#123; var one = true, onceGetTime = 60; //onceGetTime为倒计时总时间 btn.click(function() &#123; if (one) &#123; getcode(); &#125; function sendCode() &#123; if (onceGetTime &gt; 1) &#123; onceGetTime--; gsc.html(onceGetTime + \"s\" + \"后重新获取\"); timer = setTimeout(arguments.callee, 1000); one = false; gsc.css(&#123; cursor: 'default', background: '#f5f5f5' &#125;) &#125; else &#123; gsc.html(\"再次获取验证码\"); one = true; gsc.css(&#123; cursor: 'pointer', background: '#ccc' &#125;) &#125; &#125; function getcode() &#123; onceGetTime = 60; sendCode(); &#125; &#125;);&#125; 5. 复选框的全选和反选 实现复选框的全选和反选（基于 JQuery）： 123456789101112131415161718// 全选function allPick() &#123; $(\"[type=checkbox]:checkbox\").each(function () &#123; this.checked = true; &#125;)&#125;// 全不选function unAllPick() &#123; $(\"[type=checkbox]:checkbox\").each(function () &#123; this.checked = false; &#125;)&#125;// 反转function inverserPick() &#123; $(\"[type=checkbox]:checkbox\").each(function () &#123; this.checked = !this.checked; &#125;)&#125; 6. 导航滑块（跟随鼠标） 跟随鼠标的导航滑块（基于 JQuery）： 12345678910111213141516171819202122232425262728293031323334353637/** * slip为滑块 * nav为单个导航 * padding为单个导航的左右padding距离 * index为滑块初始位置(通过为初始位置加 .active 类名) * eg：setSlip($('#navSlip'), $('.navList li'), 10, $('.navBig .active')); */function setSlip(slip, nav, padding, index) &#123; var a = index.parent().index(), w = nav.eq(a).width(), b = 2 * a + 1; slip.width(nav.children().width()); slip.css('left', parseInt(nav.eq(a).position().left) + padding * b + 'px'); nav.hover(function() &#123; if (slip.css('display') == 'none') &#123; slip.show(); nav.children().removeClass('active'); &#125; if (navigator.userAgent.indexOf(\"MSIE\") != -1) &#123; //IE浏览器下体验animate slip.stop().animate(&#123; left: parseInt($(this).position().left) + padding + 'px' &#125;, 300) &#125; else &#123; //非IE下体验css3 slip.stop().css('left', parseInt($(this).position().left) + padding + 'px') &#125; &#125;, function() &#123; if (navigator.userAgent.indexOf(\"MSIE\") != -1) &#123; slip.animate(&#123; left: a * w + b * padding + 'px' &#125;, 300); &#125; else &#123; slip.css('left', a * w + b * padding + 'px'); &#125; &#125;) &#125; 7. 输入框字数提示123456789101112131415161718192021&lt;div class=\"meArea\"&gt; &lt;label for=\"mArea\"&gt;&amp;nbsp;&amp;nbsp; 内容：&lt;/label&gt; &lt;textarea id=\"mArea\" placeholder=\"留言需审核后才会显示\" required maxlength=\"200\" name=\"myText\"&gt;&lt;/textarea&gt; &lt;p class=\"wordN\"&gt;已输入&lt;span id=\"readyN\"&gt;0&lt;/span&gt;个字符，还可输入&lt;span id=\"leftN\"&gt;200&lt;/span&gt;个字符。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$('#mArea').on('keyup blur',function () &#123; var area=$(this); var max=parseInt(area.attr('maxlength'),10);//转化为10进制 if (max&gt;0)&#123; if (area.val().length &gt; max) &#123; //textarea的文本长度大于maxlength area.val(area.val().substr(0, max)); //截断textarea的文本重新赋值 &#125; var already=area.val().length,left=max-already; $('#readyN').text(already); $('#leftN').text(left); &#125;&#125;);&lt;/script&gt; 8. 随机验证码1234567891011121314151617181920212223&lt;label for=\"mCheck\"&gt;&amp;nbsp;验证码：&lt;/label&gt;&lt;input type=\"text\" id=\"mCheck\" placeholder=\"不区分大小写\"&gt;&lt;span id=\"seccode\"&gt;&lt;/span&gt;&lt;a href=\"javascript:;\" id=\"changeA\"&gt;换一换&lt;/a&gt;&lt;script&gt;function rand() &#123; var i=0, t=''; do &#123; var tempNum=Math.floor(Math.random()*123); if ((48&lt;=tempNum&amp;&amp;tempNum&lt;=57)||(65&lt;=tempNum&amp;&amp;tempNum&lt;=90)||(97&lt;=tempNum&amp;&amp;tempNum&lt;=122))&#123; t+= String.fromCharCode(tempNum); i++; &#125; &#125;while (i&lt;4); return t;&#125;;$('#seccode').text(rand());$('#changeA').click(function () &#123; $('#seccode').text(rand());&#125;);&lt;/script&gt; 9. 超出部分以省略号显示123456789101112131415&lt;p class=\"newsOver\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, animi beatae dicta dolorem excepturi facilis, illum maiores quia, repellat sit vero voluptate voluptates? Aspernatur et iusto, omnis qui quo velit.&lt;/p&gt;&lt;script&gt;function cut(text) &#123; text.each(function()&#123; var maxwidth=55;//限制的字符数 if($(this).text().length&gt;maxwidth)&#123; $(this).text($(this).text().substring(0,maxwidth)); $(this).html($(this).html()+'... ...'); &#125; &#125;);&#125;cut($('.newsOver'));&lt;/script&gt; 以上代码都是经本人亲自测试过的，不保证性能最佳，留着做个参考。","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"common.js 总结","slug":"article-js-common","date":"2017-02-02T06:59:15.000Z","updated":"2021-06-24T04:02:41.964Z","comments":true,"path":"2017/02/02/article-js-common/","link":"","permalink":"https://doubleray.top/2017/02/02/article-js-common/","excerpt":"本文旨在总结一些在 JavaScript 中常用的算法及通用脚本。","text":"本文旨在总结一些在 JavaScript 中常用的算法及通用脚本。 1. rem 布局处理根字体1.1 旧版（已过时）123456789101112/** * document.documentElement为html * 640为设计尺寸（按需改） * 100为初始字体大小方便在css中进行计算（好计算） */(function(win, doc) &#123; function change() &#123; document.documentElement.style.fontSize = 100 / 640 * document.documentElement.clientWidth + 'px'; &#125; doc.addEventListener('DOMContentLoaded', change, false); win.addEventListener('resize', change, false);&#125;)(window, document); 1.2 新版（推荐）123456789101112131415161718192021222324252627282930313233343536//这是阿里团队的高清方案布局代码，所谓高清方案就是根据设备屏幕的DPR（设备像素比，又称DPPX，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。! function(e) &#123; function t(a) &#123; if (i[a]) return i[a].exports; var n = i[a] = &#123; exports: &#123;&#125;, id: a, loaded: !1 &#125;; return e[a].call(n.exports, n, n.exports, t), n.loaded = !0, n.exports &#125; var i = &#123;&#125;; return t.m = e, t.c = i, t.p = \"\", t(0)&#125;([function(e, t) &#123; \"use strict\"; Object.defineProperty(t, \"__esModule\", &#123; value: !0 &#125;); var i = window; t[\"default\"] = i.flex = function(e, t) &#123; var a = e || 100, n = t || 1, r = i.document, o = navigator.userAgent, d = o.match(/Android[\\S\\s]+AppleWebkit\\/(\\d&#123;3&#125;)/i), l = o.match(/U3\\/((\\d+|\\.)&#123;5,&#125;)/i), c = l &amp;&amp; parseInt(l[1].split(\".\").join(\"\"), 10) &gt;= 80, p = navigator.appVersion.match(/(iphone|ipad|ipod)/gi), s = i.devicePixelRatio || 1; p || d &amp;&amp; d[1] &gt; 534 || c || (s = 1); var u = 1 / s, m = r.querySelector('meta[name=\"viewport\"]'); m || (m = r.createElement(\"meta\"), m.setAttribute(\"name\", \"viewport\"), r.head.appendChild(m)), m.setAttribute(\"content\", \"width=device-width,user-scalable=no,initial-scale=\" + u + \",maximum-scale=\" + u + \",minimum-scale=\" + u), r.documentElement.style.fontSize = a / 2 * s * n + \"px\" &#125;, e.exports = t[\"default\"]&#125;]);flex(100, 1); 2. 处理 CSS3 在 JS 中的兼容性（自动加前缀）123456789101112/** * obj事件对象 * name属性名 * val属性值； */function setStyle(obj, name, val) &#123; var w = name.charAt(0).toUpperCase() + name.substring(1); obj.style['webkit' + w] = val; obj.style['moz' + w] = val; obj.style['ms' + w] = val; obj.style['o' + w] = val; &#125; 3. 获得从n到m的随机数123function rnd(n, m) &#123; return parseInt(Math.random() * (n - m) + n) &#125; 4. 角度转弧度（三角函数时用）123function a2d(n) &#123; return n * 180 / Math.PI; &#125; 5. 勾股定理求斜边长123function sideX(x, y) &#123; return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)); &#125; 6. 交换变量值为数字的两个变量的值123456789function swap(a, b) &#123; if (a === b) &#123; return [a, b]; &#125; b = b - a; // 此处的 b - a中的b和a的值是最初的值 a = a + b; // a = a + b -a; 实现了将b的值赋给a b = a - b; // b = a - (b - a) = 2a - b 相当于 2b = 2a;实现了将a的值赋给b return [a, b]; &#125; 7. 数组的冒泡排序方法12345678910111213function bubbleSort(arr) &#123; for (var i = 1; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - i; j++) &#123; var temp; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125; 8. 数组的快速排序方法1234567891011121314151617181920212223function quickSort(arr) &#123; //如果数组&lt;=1,则直接返回 if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); //找基准，并把基准从原数组删除 var pivot = arr.splice(pivotIndex, 1)[0]; //定义左右数组 var left = []; var right = []; //比基准小的放在left，比基准大的放在right for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt;= pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot], quickSort(right)); &#125; 9. 求数组中的最大差值1234567891011121314function getMaxProfit(arr) &#123; // 定义两个变量，分别存贮最大值和最小值 var maxNum = arr[0]; var minNum = arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; maxNum) &#123; maxNum = arr[i]; &#125; if (arr[i] &lt; minNum) &#123; minNum = arr[i]; &#125; &#125; return maxNum - minNum; &#125; 10. 数组去重的方法10.1 对象的key的方法1234567891011function unique(arr) &#123; var hashTable = &#123;&#125;; var data = []; for (var i = 0, l = arr.length; i &lt; l; i++) &#123; if (!hashTable[arr[i]]) &#123; hashTable[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data; &#125; 10.2 逻辑去重的方法123456789function fn(arr) &#123; var temp = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (temp.indexOf(arr[i]) == -1) &#123; temp.push(arr[i]); &#125; &#125; return temp; &#125; 11. 生成斐波那契数列12345678910111213function getFibonacci(n) &#123; var fibArr = []; var i = 0; while (i &lt; n) &#123; if (i &lt;= 1) &#123; fibArr.push(i); &#125; else &#123; fibArr.push(fibarr[i - 1] + fibArr[i - 2]) &#125; i++; &#125; return fibArr; &#125; 12. 获取任意长度的字符串12345678910111213function getRandomString(n) &#123; // 定义随机字符串的字符库 var str = 'qwertyuiopasdfghjklzxcvbnm1234567890'; // 定义一个临时变量tmp存储生成的随机字符串 var tmp = ''; //获取str的长度 var len = str.length; // 生成一个长度为n的随机字符串 for (var i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.floor(Math.random() * len)); &#125; return tmp; &#125; 13. 阶乘的算法1234567891011121314function factorialize(num) &#123; var result = num; if (num &lt; 0) &#123; return -1; &#125; else if (num === 0 || num === 1) &#123; return 1; &#125; else &#123; while (num &gt; 1) &#123; num--; result *= num; &#125; &#125; return result;&#125; 14. 判断不同设备加载不同代码1234567891011121314151617181920212223var checkMobile = function () &#123; var ua = navigator.userAgent.toLowerCase(); var brower = &#123;&#125;; if (ua.match(/iphone|nokia|sony|ericsson|mot|samsung|sgh|lg|philips|panasonic|alcatel|lenovo|cldc|midp|wap|mobile/i)) &#123; brower.mobile = true;//判断是否是手机访问 &#125; if (ua.match(/MicroMessenger/i)) &#123; brower.weinxin = true; //判断是不是微信 &#125; if (ua.match(/iphone|ipad/i)) &#123; brower.ios = true; //判断是不是ios系统 &#125; if (ua.match(/android/i)) &#123; brower.android = true; //判断是不是安卓系统 &#125; if (ua.match(/Windows Phone/i)) &#123; brower.wp = true; //判断是不是windows系统 &#125; return brower; &#125;; if(!!checkMobile().mobile)&#123; window.location.href = \"mobile/index_m.html\"; &#125;","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"理解 Web 缓存","slug":"article-web-cache","date":"2017-01-29T07:41:15.000Z","updated":"2021-06-24T04:02:41.981Z","comments":true,"path":"2017/01/29/article-web-cache/","link":"","permalink":"https://doubleray.top/2017/01/29/article-web-cache/","excerpt":"提到 Web 缓存大家都会觉得很简单，不就是检查资源是否有缓存，如果有就加以利用。如果追究下去，多数人还能扯出 cache-control, last-modified, etag之类的名词，但如果真的考究一下这些字段之间有什么区别，又是怎么工作的，其实很多人只有一个极为模糊的认识，所以写一篇文章来梳理一下 Web 缓存的工作方式。","text":"提到 Web 缓存大家都会觉得很简单，不就是检查资源是否有缓存，如果有就加以利用。如果追究下去，多数人还能扯出 cache-control, last-modified, etag之类的名词，但如果真的考究一下这些字段之间有什么区别，又是怎么工作的，其实很多人只有一个极为模糊的认识，所以写一篇文章来梳理一下 Web 缓存的工作方式。 缓存不仅仅是浏览器的事情 很多人对 Web 缓存的认识就是浏览器判断是否使用缓存，但缓存不是浏览器本身能够完成的事情，因为在没有服务器端的其他信息的情况下浏览器是无法判断一个资源是否过期的。代理缓存，CDN 缓存等不在本文的讨论范围内。 Headers 因为针对缓存的控制需要浏览器和服务器端协同完成，所以他们需要一个传递的信息的方式，事实上目前的 Web 缓存主要通过 Headers 来传递信息。 以知乎的一张图片资源为例 随便以知乎的一张图片资源为例，我们可以打开 Chrome 的开发者工具中的 network，随便找一个 200(from cache) 的资源，可以看到请求报文和响应报文的 Headers。 cache-control 和 max-age cache-control 大概是最广为人知的控制缓存的 Headers 了，这也是最简单的缓存控制策略，即浏览器通过最大生存时间来判断资源的缓存是否有效。 如图所见，来自服务器端的 response headers 的 Headers 中有 cache-control:public, max-age=31536000，这就是告诉浏览器这个资源的生存时间，在这个时间以内，浏览器不需要向服务器端再做任何确认，直接使用即可。下面我们也可以看到 request headers 一栏是空的。因为浏览器根本没有发出请求，这里显示的 response headers 是之前的请求中缓存的。 cache-control 除了 max-age 外还有一些其他的参数，本文暂不阐述。 expires 我们注意到在缓存的 response headers 里还有一个 Expires:Mon, 29 Jan 2018 07:38:47 GMT 字段。这个字段的意义实际上和 cache-control: max-age 的效果是相似的，在指定的时间之前浏览器都可以认为缓存是有效的。但当两个字段同时存在时，expires 会被 cache-control 覆盖。 那么为什么知乎要同时设置两个字段呢？由于 expires 是 HTTP/1.0 定义的而 cache-control 是 HTTP/1.1 定义的，我猜测可能是为了保持尽可能大的兼容性（待考证）。 304 Not Modified 上面的缓存策略只能很简单的让浏览器来确定缓存是否有效，而浏览器能够依赖的只有上次请求时服务器端留给它的资源存活时间。我们不能把存活时间设成永远，因为可能什么时候我们会更新资源，但隔一段时间重新请求一次并没有改变的资源同样浪费带宽。所以我们必须要有让服务器告诉浏览器缓存仍然有效的方法，那便是 304 Not Modified。 在服务器端判断缓存仍然有效时将会返回状态码 304 的响应。 那么服务器如何判断浏览器持有的缓存是否有效呢？这就需要浏览器将一些信息传递给服务器。 If-None-Match/ETag 知乎采用的是 ETag 来判断缓存是否有效，服务器端会在 response headers 中返回 ETag（文件的 hash）： 1etag:&quot;Ft-ifpb80DCLRrATs5py8dg84mtf&quot; 而当资源改变时 ETag 也会发生改变。浏览器在发起请求时在 If-None-Match字段携带缓存的 ETag： 1If-None-Match:&quot;2afd9676ae9046ed99dedd4635bb6e4a-gzip&quot; 服务器接到请求后如果一致（即资源没有修改），则返回 304 Not Modified，否则返回新的资源（200）。 If-Modified-Since/Last-Modified 除了文件特征码之外也可以通过上次修改时间，服务器端返回资源时通过 Last-Modified 携带资源修改时间，浏览器通过 If-Modified-Since 携带缓存中的资源的修改时间。 ETag 和 Last-Modified 的区别 Last-Modified 有个缺点就是它是精确到秒的，如果一秒中资源多次服务器不会感知到缓存失效，但这不是一个常见的需求。 而一般不推荐使用 ETag，原因有几点： Last-Modified 的缺点基本可以忽略不计 ETag 本身需要消耗 CPU，而它的优先级比 Last-Modified 高，当它存在时服务器无论 Last-Modified 是否存在都会使用它判断 ETag 在分布式系统中生成的值可能不一样，会导致缓存失效 一图胜千言 总结 大公司的静态资源优化方案，基本上要实现这么几个东西： 配置超长时间的本地缓存 —— 节省带宽，提高性能 版本控制 —— 精确的缓存控制 静态资源 CDN部署 —— 优化网络请求 更新资源发布路径实现 非覆盖式发布 —— 平滑升级 本文参考自 M-x codefalling 的 理解 Web 缓存 和 SimplyY 的 浏览器缓存介绍精简版。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://doubleray.top/tags/Web/"}]},{"title":"call() 和 apply() 详解","slug":"article-js-callapply","date":"2017-01-25T02:41:15.000Z","updated":"2021-06-24T04:02:41.963Z","comments":true,"path":"2017/01/25/article-js-callapply/","link":"","permalink":"https://doubleray.top/2017/01/25/article-js-callapply/","excerpt":"call() 和 apply() 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 二者的作用完全一样，只是接受参数的方式不太一样!","text":"call() 和 apply() 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 二者的作用完全一样，只是接受参数的方式不太一样! 1. 定义apply() : 方法能劫持另外一个对象的方法，继承另外一个对象的属性。 Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function（args–&gt;arguments） call() : 和 apply() 的意思一样,只不过是参数列表不一样。 Function.call(obj,[param1[,param2[,…[,paramN]]]]) obj：这个对象将代替Function类里this对象 params：这个是一个参数列表 2. 应用 首先要非常明确几个概念： JS 是面向对象语言； JS 的函数本质是对象，有对象就会有方法； call() 和 apply() 方法是JS函数对象的特有的方法，也就是自己调用自己。 以下是一段很简单的代码： 1234function writeZhihu()&#123; console.log(this)&#125;writeZhihu(); // [Object global] 在浏览器就是window; 在nodeJS中就是指node; 大家都知道在JS函数中都会有一个固定的实参this，这个this是指什么？ 因为我们在全局环境中声明的这个函数，这个函数目前不属于任何对象，只属于全局对象；在浏览器环境中，该函数他爹就是 window;在 nodeJS 环境中就是 node; 因为我们要面向对象编程么？编程就要声明对象，有对象就有方法，或者说对象就要调用函数。好了，以下我们就要给这个函数找个新爹； 123456789function writeZhihu()&#123; //声明一个写知乎的能力函数； console.log(this)&#125;var author =&#123;name:\"Zhangwei\"&#125; //我们声明一个对象，这个人的名字叫Zhangwei;writeZhihu.call(author); //所以当writeZhihu()这个函数自己调用自己的时候，同时传入一个对象的时候，我就牛逼了，我就有写作的超能力了。//这时候console.log(this)的this打印出来就是&#123;name:\"Zhangwei\"&#125;；//writeZhihu()这个函数表示有了归属感，么么哒。 那么这个方法的意义是什么？ 12345678910111213function writeZhihu()&#123; //写知乎的能力不可能就一个人拥有吧，很多人都可以啊？ console.log(this)&#125;var author1 =&#123;name:\"Zhangwei\"&#125;var author2 =&#123;name:\"Mayun\"&#125;var author3 =&#123;name:\"Mahuateng\"&#125;//我们创建很多个对象；writeZhihu.call(author1); //&#123;name:\"Zhangwei\"&#125;writeZhihu.call(author2); //&#123;name:\"Mayun\"&#125;writeZhihu.call(author3); //&#123;name:\"Mahuateng\"&#125;//这样这些人就有写知乎的能力了，writeZhihu()函数表示好多土豪包养我呀！！！ 那么这些人，每个人写知乎的内容都应该不一样吧，所以这就涉及到传参数的问题； 12345678910111213141516function writeZhihu(header,content)&#123; //写知乎的能力不可能就一个人拥有吧，很多人都可以啊？ console.log(this.name+\"的文章\"+header+\"，内容：\"+content)&#125;var author1 =&#123;name:\"Zhangwei\"&#125;var author2 =&#123;name:\"Mayun\"&#125;var author3 =&#123;name:\"Mahuateng\"&#125;//我们创建很多个对象；writeZhihu.call(author1,\"《JS权威指南》\",\"js不拉不拉...\"); writeZhihu.call(author2,\"《老司机带带我》\",\"江南皮革厂倒闭了...\"); writeZhihu.call(author3,\"《不转不是中国人》\",\"14亿中国人都看哭了...\"); /*那么打印出来的内容就是：1.zhangwei的文章《JS权威指南》，内容：js不拉不拉...2.Mayun的文章《老司机带带我》，内容：江南皮革厂倒闭了...3.Mahuateng的文章《不转不是中国人》，内容：14亿中国人都看哭了...*/ 那么好了，问题来了，尼玛，你标题不是说call()方法和apply()方法吗？为什么一直都在说call()方法，apply()方法喂狗了吗？ call()和apply()的方法的区别 call()和apply()的方法的区别在于参数的传递； call()方法有个缺陷就是传实参的时候走位比较耿直，比如我要传6个实参(header, content,license,platform,date,language;)； 1writeZhihu.call(author1,\"《五年高考三年模拟》\",\"我想你最爱\",\"教育部\",\"知乎\",\"2016\",\"Chinese\"); 是不是觉得这样传参数很傻逼。最要命的是，如果有的对象传递参数的数量的3个有的是4有的是5个，你是不是就彻底整懵逼了。 apply() 方法就是解决这个问题的，apply() 方法实参的传递是数组传递； 这个时候就可以这样咯： 1234var args = [\"《五年高考三年模拟》\",\"我想你最爱\",\"教育部\",\"知乎\",\"2016\",\"Chinese\"];var args2 = [\"《黄冈密卷》\",\"童年阴影\",\"教育部\",\"2016\",\"Chinese\"];writeZhihu.apply(author,args);writeZhihu.apply(author,args2) 3. 总结 这个一定要多敲代码，理解，目前我的理解是aplly,call都是调用别人的方法并且讲方法里面的this改变，两者传参数不同，正因为传参数不同，所以可以用aplly用在一些目标函数只需要接受n个参数列表，而不接受数组的函数里面，文章中部分内容参考自这里、JS中的call、apply、bind方法。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JavaScript 严格模式（strict）","slug":"article-js-strict","date":"2017-01-24T04:19:15.000Z","updated":"2021-06-24T04:02:41.971Z","comments":true,"path":"2017/01/24/article-js-strict/","link":"","permalink":"https://doubleray.top/2017/01/24/article-js-strict/","excerpt":"JavaScript 严格模式（strict mode）即在严格的条件下运行。 本文转自 阮一峰的网络日志 的 Javascript 严格模式详解 ，参考文档Strict mode。","text":"JavaScript 严格模式（strict mode）即在严格的条件下运行。 本文转自 阮一峰的网络日志 的 Javascript 严格模式详解 ，参考文档Strict mode。 1. 概述 除了正常运行模式，ECMAscript 5添加了第二种运行模式：“严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 2. 进入标志 进入”严格模式”的标志，是下面这行语句： 1 \"use strict\"; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 3. 如何调用 “严格模式”有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件 将&quot;use strict&quot;放在脚本文件的第一行(之前有任何代码（包括一个空的分号）都不会启用严格模式)，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 1234567 &lt;script&gt; \"use strict\"; console.log(\"这是严格模式。\"); &lt;/script&gt; &lt;script&gt; console.log(\"这是正常模式。\");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers. &lt;/script&gt; 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 3.2 针对单个函数 将&quot;use strict&quot;放在函数体的第一行，则整个函数以”严格模式”运行。 1234567function strict()&#123; \"use strict\"; return \"这是严格模式。\"; &#125; function notStrict() &#123; return \"这是正常模式。\"; &#125; 3.3 脚本文件的变通写法 因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 123456 (function ()&#123; \"use strict\"; // some code here &#125;)(); 4. 语法和行为改变 严格模式对Javascript的语法和行为，都做了一些改变。 4.1 全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 1234\"use strict\"; v = 1; // 报错，v未声明 for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明 &#125; 因此，严格模式下，变量都必须先用var命令声明，然后再使用。 4.2 静态绑定 Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 4.2.1 禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。 12345 \"use strict\"; var v = 1; with (o)&#123; // 语法错误 v = 2; &#125; 4.2.2 创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。 严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 1234 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 4.3 增强的安全措施4.3.1 禁止this关键字指向全局对象123456789 function f()&#123; return !this; &#125; // 返回false，因为\"this\"指向全局对象，\"!this\"就是false function f()&#123; \"use strict\"; return !this; &#125; // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。 12345 function f()&#123; \"use strict\"; this.a = 1; &#125;; f();// 报错，this未定义 4.3.2 禁止在函数内部遍历调用栈123456 function f1()&#123; \"use strict\"; f1.caller; // 报错 f1.arguments; // 报错 &#125; f1(); 4.4 禁止删除变量 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 12345678 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 4.5 显式报错 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 12345 \"use strict\"; var o = &#123;&#125;; Object.defineProperty(o, \"v\", &#123; value: 1, writable: false &#125;); o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。 12345 \"use strict\"; var o = &#123; get v() &#123; return 1; &#125; &#125;; o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。 1234 \"use strict\"; var o = &#123;&#125;; Object.preventExtensions(o); o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。 12 \"use strict\"; delete Object.prototype; // 报错 4.6 重名错误 严格模式新增了一些语法错误。 4.6.1 对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 12345 \"use strict\"; var o = &#123; p: 1, p: 2 &#125;; // 语法错误 4.6.2 函数不能有重名的参数 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 1234 \"use strict\"; function f(a, a, b) &#123; // 语法错误 return ; &#125; 4.7 禁止八进制表示法 正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。 12 \"use strict\"; var n = 0100; // 语法错误 4.8 arguments对象的限制4.8.1 不允许对arguments赋值123456\"use strict\"; arguments++; // 语法错误 var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误 try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误 function arguments() &#123; &#125; // 语法错误 var f = new Function(\"arguments\", \"'use strict'; return 17;\"); // 语法错误 4.8.2 arguments不再追踪参数的变化1234567891011function f(a) &#123; a = 2; return [a, arguments[0]]; &#125; f(1); // 正常模式为[2,2] function f(a) &#123; \"use strict\"; a = 2; return [a, arguments[0]]; &#125; f(1); // 严格模式为[2,1] 4.8.3 禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 123 \"use strict\"; var f = function() &#123; return arguments.callee; &#125;; f(); // 报错 4.9 函数必须声明在顶层 将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 1234567 \"use strict\"; if (true) &#123; function f() &#123; &#125; // 语法错误 &#125; for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123; &#125; // 语法错误 &#125; 4.10 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。 1234 function package(protected) &#123; // 语法错误 \"use strict\"; var implements; // 语法错误 &#125; 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super, const等）。还可参考 ECMAScript 6，了解新版本特性，结合 “严格模式” 写出更加优雅的代码。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JavaScript 中 Null 和 Undefined","slug":"article-js-nullundefined","date":"2017-01-20T13:25:15.000Z","updated":"2021-06-24T04:02:41.968Z","comments":true,"path":"2017/01/20/article-js-nullundefined/","link":"","permalink":"https://doubleray.top/2017/01/20/article-js-nullundefined/","excerpt":"本文转自 颜海镜的探索JavaScript中Null和Undefined的深渊。 当讨论JavaScript中的原始数据类型时，大多数人都知道的基本知识，从String，Number到Boolean。这些原始类型相当简单，行为符合常识。但是，本文将更多聚焦独特的原始数据类型Null和Undefined，是什么让他们如此相似，却又似是而非。","text":"本文转自 颜海镜的探索JavaScript中Null和Undefined的深渊。 当讨论JavaScript中的原始数据类型时，大多数人都知道的基本知识，从String，Number到Boolean。这些原始类型相当简单，行为符合常识。但是，本文将更多聚焦独特的原始数据类型Null和Undefined，是什么让他们如此相似，却又似是而非。 1. 理解Null和Undefined 在JavaScript中，null是字面量同时也是语言中的关键字，用来表示无法识别的对象值。换句话说，这用来表示 无值（no value）。虽然相似，undefined实际上代表了不存在的值（non-existence of a value）。都是完全不可变的，没有属性和方法，也不能给其属性赋值。事实上，试图访问或定义一个属性将会引发一个类型错误（TypeError）。正如他们的名字暗示的那样，他们是完全无效的值。 没有值代表的布尔值是false，这意味着他们在条件上下文中会被被计算为false，如if语句。使用相等操作符( == )比较这两个值和其他false值,他们并不等于除了自己: 12345null == 0; // falseundefined == \"\"; // falsenull == false; // falseundefined == false; // falsenull == undefined; // true 尽管如此，和其他相似之处，但null和undefined并不是等价的。每个作为其独特的类型的唯一成员,undefined是Undefined类型和null是Null类型。使用全等操作符（===）比较这两个值，这要求类型和值都相等，下面证明这一点： 1undefined === null; // false 这是一个重要的区别，服务于不同的目的和理由。区分这两个值，你可以认为undefined代表一个意想不到的没有值而null作为预期没有值的代表。 2. 产生Undefined 有许多的方法产生一个undefined值的代码。它通常遇到当试图访问一个不存在的值时。在这种情况下，在JavaScript这种动态的弱类型语言中，只会默认返回一个undefined值，而不是上升为一个错误。 任何声明变量时没有提供一个初始值，都会有一个为undefined的默认值: 1var foo; // 默认值为 undefined 当试图访问一个不存在的对象属性或数组项时，返回一个undefined值: 123var array = [1, 2, 3];var foo = array.foo; // foo 属性不存在, 返回 undefinedvar item = array[5]; // 数组中没有索引为5的项，返回 undefined 如果省略了函数的返回语句,返回undefined: 1var value = (function()&#123;&#125;)(); // 返回 undefined 函数调用时未提供的值结果将为undefined参数值： 123(function(undefined)&#123; // 参数是 undefined&#125;)(); void操作符也可以返回一个undefined值。像Underscore的库使用它作为一个防御式的类型检查，因为它是不可变的，可以在任何上下文依赖返回undefined: 123function isUndefined(obj)&#123; return obj === void 0;&#125; 最后，undefined是一个预定义的全局变量(不像null关键字)初始化为undefined值: 1'undefined' in window; // true ECMAScript 5中，这个变量是只读的，以前并非如此。 3. Null的用例 null的用例是使他与众不同的主要方面，因为不像undefined，null被认为是更有用。这正是为什么typeof操作符作用于null值时返回“object”。最初的理由是，现在仍然是，通常用作一个空引用一个空对象的预期,就像一个占位符。typeof的这种行为已经被确认为一个错误，虽然提出了修正，出于后兼容的目的，这一点已经保持不变。 这就是为什么JavaScript环境从来没有设置一个值为null；它必须以编程方式完成。正如文档MDN所说： 在api中，null是经常检索对象的地方可以预期，但没有相关的对象。 这适用于DOM，它是独立于语言的，不属于ECMAScript规范的范围。因为它是一个外部API，试图获取一个不存在的元素返回一个null值，而不是undefined。 一般来说,如果你需要给一个变量或属性指定一个不变值，将它传递给一个函数，或者从一个函数返回null，null几乎总是最好的选择。简而言之，JavaScript使用undefined并且程序员应该使用null。 null的另一个可行的用例，也被认为是良好的实践是一个显式指定变量为无效(object= null)当一个引用不再是必需的。通过分配null值，有效地清除引用，并假设对象没有引用其他代码，指定垃圾收集，确保回收内存。 4. 深入挖掘 使null和undefined像黑洞的不只是他们的行为，而是在他们在JavaScript环境的内部的处理方式。他们似乎通常并不具有同样的关联特征与其他原生或内置对象。 在 ES5 中，Object.prototype.toString方法，已经成为实际的类型检查标准，这在null和undefined中被证明是一致的： 12Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(undefined); // [object Undefined] 然而，Object.prototype.toString方法实际上并不是检索null的内部[[Class]]属性或undefined的公开构造函数。根据文档，以下步骤发生在被调用过程中： 如果值是undefined，返回“[object Undefined]”。 如果这个值为null，则返回“[object Null]”。 让 O 作为调用ToObject同时传递this值作为参数的结果值。 让class是 O 的内部属性[[Class]]的值。 返回的结果连接三个字符串“[object ”，class，和“]”的结果的字符串值。 该方法执行一个简单的字符串返回值，如果它检测到null或undefined和其他对象统一的功能。在整个规范中这是很常见的，因为当遇到null和undefined值时大多数方法包含一个简单的捕捉并返回。事实上，没有迹象表明他们包含与任何原生对象相关联的内部属性。就好像他们不是对象。我很想知道如果一个JavaScript的原生环境内部实际存在的显式方案会怎样？也许有人更熟悉一个可以参与的实现。 5. 结论 无论这些原生对象多么不寻常，理解null和undefined之间的差异，和他们在JavaScript的语言基础中截然不同的角色。它可能不能使你的应用程序有所突破，但是一般来说，它仅被证明在开发和调试中长期有益。","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"初探 CoffeeScript","slug":"article-cs-know","date":"2017-01-18T04:19:15.000Z","updated":"2021-06-24T04:02:41.954Z","comments":true,"path":"2017/01/18/article-cs-know/","link":"","permalink":"https://doubleray.top/2017/01/18/article-cs-know/","excerpt":"CoffeeScript是一门简洁的，构架于JavaScript之上的预处理器语言，可以静态编译成JavaScript，语法主要受ruby和python影响，目前已经为众多rails和node项目采用。","text":"CoffeeScript是一门简洁的，构架于JavaScript之上的预处理器语言，可以静态编译成JavaScript，语法主要受ruby和python影响，目前已经为众多rails和node项目采用。 1. 前言 为什么要用CoffeeScript? 更少，更紧凑，和更清晰的代码 通过规避和改变对JavaScript中不良部分的使用，只留下精华，让代码减少出错率，更容易维护 在很多常用模式的实现上采用了JavaScript中的最佳实践 CoffeeScript生成的JavaScript代码都可以完全通过JSLint的检测 什么情况下不推荐使用CoffeeScript? CoffeeScript不是JavaScript的超集，也不是完全替代品，不应该在不会JavaScript的情况下使用CoffeeScript工作。 CoffeeScript是一种需要预编译的语言，不能在运行时(Runtime)解释，这造成了她普遍被人质疑的一点，就是如果代码中出现运行时错误时难以调试，不过从实际使用上来看，因为CoffeeScript的编译结果大部分情况下自然而合理，至少我从来没有发现从生成的JavaScript代码回溯到对应的CoffeeScript代码有什么困难之处，我们稍后会看到这种对应关系的细节。 这种静态编译还有一个额外的好处，就是CoffeeScript和现有的环境(浏览器, Node , Rhino 等)与库完全兼容。 CoffeeScript安装 最简单的安装和测试CoffeeScript的方法，是使用node.js的npm安装，然后使用命令行脚本实时编译: 123npm install -g coffee-script# watch and compilecoffee -w --output lib --compile src 这里假设你的coffee代码在src目录下，这个 demo 会自动检测文件的改变，并编译成js文件放到lib目录下。 2. 语法 与SASS/LESS和CSS的关系不同，CoffeeScript不是JavaScript的超集，不能在CoffeeScript程序中写JavaScript代码，比如function等关键字。 2.1 格式 在js中，如果认为当前语句和随后语句是一个整体的话，就不会自己加;，比如以下javascript代码: 123456//javascript codevar y = x+f(a+b).toString()//parsed to:var y = x+f(a+b).toString(); 很多js中的问题由此引起(实际上现在把;放在哪里，在js社区内也是个争论的话题)； 而CoffeeScript在编译时为每条语句加上;，因此在代码中不需要写;； CoffeeScript中的注释采用#: 1234# single line comment### multi line comment### CoffeeScript中对空白敏感，这种做法来自python，任何需要({})的场合下，可以用缩进代替。 2.2 作用域 在js中最糟糕的设计就是全局变量，当你忘记用var声明变量的时候，这个变量会成为全局对象上的一个属性;CoffeeScript避免了这点： 1foo = \"bar\" 会编译成： 1234(function() &#123; var foo; foo = \"bar\";&#125;).call(this); 任何的代码都会使用Immediate Function包装，这样foo成为了本地变量，并且，可以通过call指定的this引用全局对象，为了方便起见，之后的编译后代码描述不会再加上这个包装。 实际上在CoffeeScript中，你也不需要再用var声明变量，编译后会自动加上var，并且将声明hoisting，即放到作用域的顶部，看一个来自官方文档的例子： 12345outer = 1change = -&gt; inner = -1 outer = 10inner = change() -&gt;是函数定义的简写方式，之后我们会探讨；编译后的js如下： 1234567891011var change, inner, outer;outer = 1;change = function() &#123; var inner; inner = -1; return outer = 10;&#125;;inner = change(); 这是类似ruby中的自然的作用域实现方式，inner在change()内定义成了局部变量，因为在代码中之前没有定义过。 2.3 赋值 首先是字符串可以用类ruby的语法内嵌： 12target = \"world\"alert \"hello, #&#123;target&#125;\" 其次是字面量，可以用类似YAML的方法定义对象字面量： 12345object1 = one: 1, two: 2object2 = one: 1 two: 2 class: \"numbers\" 注意保留字class，现在可以直接作为对象的key了。 数组也可以分行： 1234arr = [ 1 2] 也可以解构赋值(Destructuring)： 1234obj = &#123;a:\"foo\", b:\"bar\"&#125;&#123;a, b&#125; = objarr = [1, 2][a, b] = arr 2.4 数组 数组的操作引入了来自ruby的Range概念，并且可以将字符串完全作为数组操作： 123numbers = [0..9]numbers[3..5] = [-3, -4, -5]my = \"my string\"[0..1] 判断一个值是否在数组内，在js中可以用Array.prototype.indexOf，不过 IE8 及以下不支持，CoffeeScript提供了跨浏览器的in操作符解决： 12arr = [\"foo\", \"bar\"]\"foo\" in arr 具体的实现上，是一个对indexOf的Shim： 123456789101112 var arr, __indexOf = [].indexOf || function(item) &#123; for (var i = 0, l = this.length; i &lt; l; i++) &#123; if (i in this &amp;&amp; this[i] === item) return i; &#125; return -1; &#125;;arr = [\"foo\", \"bar\"];__indexOf.call(arr, \"foo\") &gt;= 0; for..in语法可以用在数组上了，背后是用js的for循环实现的，这比数组的迭代器方法要效率高一些： 12for name, i in [\"Roger\", \"Roderick\"] alert \"#&#123;i&#125; - Release #&#123;name&#125;\" 也具有过滤器when： 12prisoners = [\"Roger\", \"Roderick\", \"Brian\"]release prisoner for prisoner in prisoners when prisoner[0] is \"R\" 看起来很像普通英语了，也可以用()收集遍历的结果： 1result = (item for item in array when item.name is \"test\") 遍历对象的属性可以用of,这是用js自己的for..in实现的： 12names = sam: seaborn, donna: mossalert(\"#&#123;first&#125; #&#123;last&#125;\") for first, last of names 2.5 流程控制 CoffeeScript使用来自ruby的省略语法，让控制流变得很紧凑，也引进了unless,not,then等语法糖式的关键字： 12result = if not true then \"false\"result = unless true then \"false\" CoffeeScript中非常好的一点，就是直接取消了js中的==判断，改成全部用===进行严格比较，js中的==会做大量诡异的类型转换，很多情况下是 bug 的来源； 1234if \"1\" == 1 alert(\"equal\")else alert(\"not equal\") 在使用if来进行空值的判断时，js有时会让人困扰，因为&quot;&quot;和0都会被转换成false，Coffee 提供了?操作符解决这个问题，她只有在变量为null或undefined时才为false。 12\"\"? #truenull? #false 也可以用常见的类似ruby中||=的方法，判断赋值，此外还可以用and,or,is关键字代替&amp;&amp;,||,==。 12hash or= &#123;&#125;hash ?= &#123;&#125; 经常有当某个属性存在的时候，才会调用属性上的方法的情况，这时候也可以用?； 1knight.hasSword()?.poke() 只有当hasSword()返回对象不为空时，才会调用poke方法，以下是编译的js代码： 1234var _ref;if ((_ref = knight.hasSword()) != null) &#123; _ref.poke();&#125; 另一种情况是当poke方法存在时才调用： 1knight.hasSword().poke?() 对应的js代码： 1234var _base;if (typeof (_base = knight.hasSword()).poke === \"function\") &#123; _base.poke();&#125; switch case语句也有了一些语法糖，并且会默认加上break： 1234switch day when \"Sun\" then go relax when \"Sat\" then go dancing else go work 2.6 函数 CoffeeScript对JavaScript的函数做了很大的简化，举个例子，看一个求和函数： 1234sum = (nums...) -&gt; nums.reduce (x, y) -&gt; x+ysum 1,2,3 对应JavaScript： 123456789101112var sum, __slice = [].slice;sum = function() &#123; var nums; nums = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : []; return nums.reduce(function(x, y) &#123; return x + y; &#125;);&#125;;sum(1, 2, 3); 可以使用和ruby 1.9类似的lambda函数写法-&gt;来代替function 参数列表放在-&gt;的前边，且可省略 取消了函数声明，只能将函数作为值定义 在CoffeeScript中，任何语句都是表达式(除了break和continue)，都有返回值，因此像ruby一样，不需要显式return js的函数参数有一个很讨厌的地方，就是参数对象arguments不是一个真正的数组，要使用数组方法，必须转换成数组[].slice.call(arguments, 0)这样，而在CoffeeScript中收束(加...)的参数是一个真正的数组 CoffeeScript的函数可以有默认参数，如： 1times = (a = 1, b = 2) -&gt; a * b CoffeeScript的函数调用可以不用()语法包围参数，像ruby一样跟在函数名后面就可以，不过这也有时候会带来问题，特别是没有参数的调用： 1alert 对应的js： 1alert; 而不是alert()，这和ruby不同，需要注意! 缩进的格式有时需要小心，比如用多个函数做参数的时候，需要这样写： 1234$(\".toggle\").toggle -&gt; \"on\", -&gt; \"off\" 对应js： 12345$(\".toggle\").toggle(function() &#123; return \"on\";&#125;, function() &#123; return \"off\";&#125;); 3. 模式 使用CoffeeScript的一个重要理由，就是她用自己的语法实现了很多很常用的js编程模式，而且，通常是在社区内广泛被承认的最佳实践，如果不熟悉JavaScript的这些模式，可能会在调试代码上遇到一些麻烦，不过，基本上来说还是比较简单易懂的，下面我们会花一些时间研究一下CoffeeScript是用什么样的方法来封装这些通用编程模式的。 3.1 闭包 在js中，普遍会使用闭包实现各种事件的handler或封装模块，以下是CoffeeScript对这一普遍模式的实现。 12345closure = do -&gt; _private = \"foo\" -&gt; _privateconsole.log(closure()) #=&gt; \"foo\" do关键词可以产生一个Immediate Function,下面是对应js代码： 123456789var closure;closure = (function() &#123; var _private; _private = \"foo\"; return function() &#123; return _private; &#125;;&#125;)(); 闭包中经常需要绑定this的值给闭包的私有变量，CoffeeScript使用特殊的=&gt;语法省去了这个麻烦。 12@clickHandler = -&gt; alert \"clicked\"element.addEventListener \"click\", (e) =&gt; @clickHandler(e) 使用=&gt;生成函数，可以看到生成代码中会加上对this的绑定： 123456789var _this = this;this.clickHandler = function() &#123; return alert(\"clicked\");&#125;;element.addEventListener(\"click\", function(e) &#123; return _this.clickHandler(e);&#125;); 这里CoffeeScript对于this有简单的别名@。 3.2 扩展 在js中，所有的对象都是开放的，有时候会扩展原有对象的行为(比如对数组的ECMA5 shim)，这也称为Monkey patching： 1String::dasherize = -&gt; @replace /_/g, \"-\" ::代表原型的引用，js代码如下： 123String.prototype.dasherize = function() &#123; return this.replace(/_/g, \"-\");&#125;; 3.3 类 在js中是否要模拟传统编程语言的类，是个一直以来都有争议的话题，不同的项目，不同的团队，在类的使用上会有不同的看法，不过，一旦决定要使用类，那么至少需要一套良好的实现，CoffeeScript在语言内部实现了类的模拟，我们来看一看一个完整的例子： 1234567891011121314151617181920class Gadget @CITY = \"beijing\" @create: (name, price) -&gt; new Gadget(name, price) _price = 0 constructor: (@name, price) -&gt; _price = price sell: =&gt; \"Buy #&#123;@name&#125; with #&#123;_price&#125; in #&#123;Gadget.CITY&#125;\"iphone = new Gadget(\"iphone\", 4999)console.log iphone.name #=&gt; \"iphone\"console.log iphone.sell() #=&gt; \"Buy iphone with 4999 in beijing\"ipad = Gadget.create(\"ipad\", 3999)console.log ipad.sell() #=&gt; \"Buy ipad with 3999 in beijing\" 这个Gadget类具有通常语言中类的功能： constructor是构造函数，必须用这个名称，类似ruby中的initialize name是实例变量,可以通过iphone.name获取 构造函数中如果给实例变量赋值，直接将@name写在参数中即可，等价于在函数体中的@name = name _price是私有变量,需要赋初始值 sell是实例方法 create是类方法，注意这里使用了@create，这和ruby有些像，在定义时的this指的是这个类本身 CITY是类变量 要注意的是，对于实例方法，要用=&gt;来绑定this，这样可以作为闭包传递，比如： 12iphone = new Gadget(\"iphone\", 4999)$(\"#sell\").click(iphone.sell()) 如果不用=&gt;，闭包被调用时就会丢失实例对象的值(iphone)。 对于熟悉基于类的面向对象编程的人，CoffeeScript的类是一目了然的，下面来看看对应的js代码： 1234567891011121314151617181920212223242526272829var Gadget, __bind = function(fn, me)&#123; return function()&#123; return fn.apply(me, arguments); &#125;; &#125;;Gadget = (function() &#123; var _price; Gadget.name = 'Gadget'; Gadget.CITY = \"beijing\"; Gadget.create = function(name, price) &#123; return new Gadget(name, price); &#125;; _price = 0; function Gadget(name, price) &#123; this.sell = __bind(this.sell, this); this.name = name; _price = price; &#125; Gadget.prototype.sell = function() &#123; return \"Buy \" + this.name + \" with \" + _price + \" in \" + Gadget.CITY; &#125;; return Gadget;&#125;)(); 以上的代码有很多值得注意的地方： 整体上来说，CoffeeScript的类模拟使用的是一个构造函数闭包，这是最常用的模拟类的模式，好处是可以完整地封装内部变量，且可以使用new来生成实例对象 _price就是被封装在闭包内部的私有变量 sell这样的实例方法是原型方法，并且在初始化时使用自定义的bind函数绑定实例(用=&gt;定义的情况) reate和CITY这样的类成员使用构造函数的属性实现，重复一下，在CoffeeScript类定义中的this指的是整个闭包Gadget Gadget.name是额外定义的类名属性 3.4 类的继承 CoffeeScript中为方便地实现类的继承也定义了自己的语法，我们把上面的类简化，来看一下如何继承： 123456789101112class Gadget constructor: (@name) -&gt; sell: =&gt; \"Buy #&#123;@name&#125;\" class IPhone extends Gadget constructor: -&gt; super(\"iphone\") nosell: =&gt; \"Don't #&#123;@sell()&#125;\"iphone = new IPhoneiphone.nosell() #=&gt; Don't Buy iphone 使用extends关键字可以继承父类中的所有实例属性,比如sell super方法可以调用父类的同名方法 如果不覆盖constructor，则她被子类默认调用 来看一下对应的js代码，这有一些复杂，我们把和上边类定义中重复的地方去掉，只留下继承的实现部分； 12345678910111213141516171819202122232425262728293031323334var Gadget, IPhone, __extends = function(child, parent) &#123; for (var key in parent) &#123; if (&#123;&#125;.hasOwnProperty.call(parent, key)) child[key] = parent[key]; &#125; function ctor() &#123; this.constructor = child; &#125; ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; &#125;;IPhone = (function(_super) &#123; __extends(IPhone, _super); IPhone.name = 'IPhone'; function IPhone() &#123; this.nosell = __bind(this.nosell, this); IPhone.__super__.constructor.call(this, \"iphone\"); &#125; IPhone.prototype.nosell = function() &#123; return \"Don't \" + (this.sell()); &#125;; return IPhone;&#125;)(Gadget); 这里重点有三个： __extends函数使用了代理构造函数ctor来实现继承，这是非常普遍的js中对象继承的实践模式，进一步解释一下： 使用代理构造函数的目的是为了避免子类被更改时父类受到影响 使用ctor.prototype = parent.prototype的意义是只继承定义在prototype上的公用属性 父类的类成员被直接引用拷贝到子类，而不是原型继承 super的实现方法是parent.prototype.constructor.call(this) 3.5 混入(Mixin) 在ruby语言中的Mixin，能够让你的类获得多个模块的方法，可以说是对多重继承一种很好的实现，虽然在CoffeeScript中并没有像ruby的include一样的内置功能，但很容易实现他： 123456789101112131415161718192021222324class Module @extend: (obj) -&gt; for key, value of obj @[key] = value @include: (obj) -&gt; for key, value of obj @::[key] = valueclassProperties = find: (id) -&gt; console.log(\"find #&#123;id&#125;\")instanceProperties = save: -&gt; console.log(\"save\")class User extends Module @extend classProperties @include instancePropertiesuser = User.find(1)user = new Useruser.save() 继承了Module的类才可以Mixin，当然，这里也可以用组合或者直接为js的构造函数做Monkey patching classProperties是类成员模块，使用@extend来Mixin`，实现是简单的拷贝对象的属性 instanceProperties是实例成员模块，使用@include来Mixin，实现是拷贝对象原型的属性 需要指出的是，这里的拷贝是引用拷贝，有可能外部会更改被Mixin的模块内部值，更好的方法是深层值拷贝(clone)，包括JQuery在内的很多类库都实现了这类扩展方法 4. 结语 CoffeeScript提供了一门比JavaScript更强大，优雅，表现力丰富的语言，但她毕竟架构于JavaScript之上，而且是静态地编译成JavaScript代码，也就是说，她不能完全避免对JavaScript中一些不良部分的滥用，比如eval,typeof,instanceof等，所以，在任何情况下，建议始终开启Strict Mode： 1\"use strict\" 严格模式是一个ECMA5标准提出的js子集，禁用了很多js设计中不好的方面，在未来会逐渐成为js的语言标准，详细介绍在这里。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"https://doubleray.top/tags/CoffeeScript/"}]},{"title":"JavaScript 闭包（Closure）","slug":"article-js-closure","date":"2017-01-16T04:19:15.000Z","updated":"2021-06-24T04:02:41.964Z","comments":true,"path":"2017/01/16/article-js-closure/","link":"","permalink":"https://doubleray.top/2017/01/16/article-js-closure/","excerpt":"JavaScript 里的闭包（Closure），对于跟 js 接触不够深的前端新手来说基本是闻之变色，那么闭包真的有那么难以理解和使用吗？前辈们有很多有声有色的解释和阐述，比如阮一峰老师的 学习Javascript闭包（Closure）、明城的 闭包的秘密 、vuturn的专栏 的 JavaScript闭包详解 等等好多，今天正好看到《JavaScript 高级程序设计》里的闭包一块，我就集百家之长再说一说闭包。","text":"JavaScript 里的闭包（Closure），对于跟 js 接触不够深的前端新手来说基本是闻之变色，那么闭包真的有那么难以理解和使用吗？前辈们有很多有声有色的解释和阐述，比如阮一峰老师的 学习Javascript闭包（Closure）、明城的 闭包的秘密 、vuturn的专栏 的 JavaScript闭包详解 等等好多，今天正好看到《JavaScript 高级程序设计》里的闭包一块，我就集百家之长再说一说闭包。 1. 什么是闭包 闭包 是指有权访问另一个函数作用域中的变量的函数。 或者这么理解，函数 和 函数内部能访问到的变量（也叫环境）的总和，就是一个闭包。 闭包的常见形式一般就是一个函数内部创建另一个函数，如下： 12345678910111213141516171819//原生js经典案例function fx()&#123; var local = 88; function bar()&#123; local++ return local; &#125; return bar;&#125; //local 变量和 bar 函数就组成了一个闭包（Closure）var func = fx();func()//jQuery经典案例$(function() &#123; var selections = []; $(\".niners\").click(function() &#123; // 此闭包可以访问选择变量​ selections.push (this.prop(\"name\")); // 更新外部函数作用域中的选择变量 &#125;)&#125;); 1.1 为什么要函数套函数呢？ 其实函数套函数只是为了造出一个局部变量，闭包的原文是 Closure，其实跟 包 没有任何关系，并不是说非得用什么包起什么来才行。 1.2 闭包与作用域链 闭包中内部函数访问了外部函数的变量 local。即使这个内部函数被返回了，而且是在其他地方被调用了，但是他仍然可以访问外部函数的变量 local，之所以能够访问变量 local，是因为内部函数的作用域链中包含了 fx() 的作用域。 小提示：理解 js 的作用域链 及 js 的变量范围 对真正的彻底的理解闭包至关重要。 2. 闭包的作用 闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中(参考这里)。 123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 函数 result 执行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。 这段代码中另一个值得注意的地方，就是 “nAdd=function(){n+=1}“ 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，可以在函数外部对函数内部的局部变量进行操作。 通过上面的阐述，其实可以延伸出闭包在实际中的应用： 2.1 匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。 除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包： 123456789101112var datamodel = &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(datamodel); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。但是这种立即执行函数 （IIFE） 也要合理的使用，具体可以参看如何 合理使用IIFE。 2.2 闭包缓存 设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 1234567891011121314151617181920212223var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(\"input1\"); 这样，当我们第二次调用 CachedSearchBox.attachSerachBox(“input1”) 的时候，我们就可以从缓存中取道该对象，而不用再去创建一个新的searchbox 对象。 2.3 实现封装 先看一个关于封装的经典例子： 1234567891011121314151617181920function celebrityID () &#123; var celebrityID = 999; //用内部函数返回一个对象 // 所有的内部函数可以访问外部函数的变量 return &#123; getID: function () &#123; //这个内部函数将返回更新celebrityID变量 return celebrityID; // 它将返回celebrityID的当前值，即使changeTheID函数更改 &#125;, setID: function (theNewID) &#123; //这个内部函数会随时改变外部函数的变量 celebrityID = theNewID; &#125; &#125;;&#125;;var mjID = celebrityID (); // 此时，该celebrityID外部函数返回。mjID.getID(); // 999​ mjID.setID(567); // 改变外部函数变量 mjID.getID(); // 567 这个例子又说明了 闭包引用外部函数的变量存储 ，不存储实际值，而是储存的整个变量对象；这个例子同时也实现了面向对象中的对象。 3. 闭包的副作用3.1 内存消耗 通常来说，函数的活动对象会随着执行期上下文一起销毁，但是，由于闭包引用另外一个函数的活动对象，因此这个活动对象无法被销毁，也就是要维护额外的作用域，这意味着，闭包比一般的函数需要更多的内存消耗。尤其在 IE 浏览器中需要关注。由于 IE 使用非原生 javascript 对象实现 DOM 对象，因此闭包会导致内存泄露问题，例如： 12345678function A()&#123; var a=document.createElement(\"div\"),// msg=\"Hello\"; a.onclick=function()&#123; alert(msg); &#125; &#125; A(); 以上的闭包会在IE下导致内存泄露，假设A()执行时创建的作用域对象 ScopeA，ScopeA 引用了 DOM 对象 a,DOM 对象 a 引用了 function(aleert(msg))，函数 function(alert(msg)) 引用了 ScopeA，这是一个循环引用，在 IE 会导致内存泄露。 3.2 性能问题 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。 不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"Flex 布局新旧混合写法详解","slug":"article-css-flex","date":"2017-01-15T04:19:15.000Z","updated":"2021-06-24T04:02:41.956Z","comments":true,"path":"2017/01/15/article-css-flex/","link":"","permalink":"https://doubleray.top/2017/01/15/article-css-flex/","excerpt":"flex 是个非常好用的属性，如果说有什么可以完全代替 float 和 position ，那么肯定是非它莫属了（虽然现在还有很多不支持 flex 的浏览器）。然而在移动开发中，本来绝大多数浏览器（包括安卓2.3以上的自带浏览器）都支持的属性，偏偏有个例外，就是国产某某 X5 内核神器（不知哪个版本的webkit，仅支持 display:box），自主研发这东西也不好多说什么了，下面入正题。","text":"flex 是个非常好用的属性，如果说有什么可以完全代替 float 和 position ，那么肯定是非它莫属了（虽然现在还有很多不支持 flex 的浏览器）。然而在移动开发中，本来绝大多数浏览器（包括安卓2.3以上的自带浏览器）都支持的属性，偏偏有个例外，就是国产某某 X5 内核神器（不知哪个版本的webkit，仅支持 display:box），自主研发这东西也不好多说什么了，下面入正题。 首先还是从两个版本的语法开始讲吧，这里还是假设 flex 容器为 .box ，子元素为 .item 。 先来一张属性图来梳理一下他们之间的一些关系： 这张图可以在接下来的属性分析中用到。 旧语法篇1. 定义容器的display属性12345.box&#123; display: -moz-box; /*Firefox*/ display: -webkit-box; /*Safari,Opera,Chrome*/ display: box;&#125; 2. 容器属性2.1 box-pack 属性 box-pack定义子元素主轴对齐方式。 12345.box&#123; -moz-box-pack: center; /*Firefox*/ -webkit-box-pack: center; /*Safari,Opera,Chrome*/ box-pack: center;&#125; box-pack属性总共有4个值： 1234.box&#123; box-pack: start | end | center | justify;/*主轴对齐：左对齐（默认）| 右对齐 | 居中对齐 | 左右对齐*/&#125; 2.2 box-align 属性 box-align定义子元素交叉轴对齐方式。 12345.box&#123; -moz-box-align: center; /*Firefox*/ -webkit-box-align: center; /*Safari,Opera,Chrome*/ box-align: center;&#125; box-align属性总共有5个值： 1234.box&#123; box-align: start | end | center | baseline | stretch;/*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/&#125; 2.3 box-direction 属性 box-direction定义子元素的显示方向。 12345.box&#123; -moz-box-direction: reverse; /*Firefox*/ -webkit-box-direction: reverse; /*Safari,Opera,Chrome*/ box-direction: reverse;&#125; box-direction属性总共有3个值： 1234.box&#123; box-direction: normal | reverse | inherit;/*显示方向：默认方向 | 反方向 | 继承子元素的 box-direction*/&#125; 2.4 box-orient 属性 box-orient定义子元素是否应水平或垂直排列。 12345.box&#123; -moz-box-orient: horizontal; /*Firefox*/ -webkit-box-orient: horizontal; /*Safari,Opera,Chrome*/ box-orient: horizontal;&#125; box-orient属性总共有5个值： 1234.box&#123; box-orient: horizontal | vertical | inline-axis | block-axis | inherit; /*排列方向：水平 | 垂直 | 行内方式排列（默认） | 块方式排列 | 继承父级的box-orient*/&#125; 2.5 box-lines 属性 box-lines定义当子元素超出了容器是否允许子元素换行。 12345.box&#123; -moz-box-lines: multiple; /*Firefox*/ -webkit-box-lines: multiple; /*Safari,Opera,Chrome*/ box-lines: multiple;&#125; box-lines属性总共有2个值： 1234.box&#123; box-lines: single | multiple; /*允许换行：不允许（默认） | 允许*/&#125; 3. 子元素属性3.1 box-flex 属性 box-flex定义是否允许当前子元素伸缩。 12345.item&#123; -moz-box-flex: 1.0; /*Firefox*/ -webkit-box-flex: 1.0; /*Safari,Opera,Chrome*/ box-flex: 1.0;&#125; box-flex属性使用一个浮点值： 1234.item&#123; box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/&#125; 3.2 box-ordinal-group 属性 box-ordinal-group定义子元素的显示次序，数值越小越排前。 12345.item&#123; -moz-box-ordinal-group: 1; /*Firefox*/ -webkit-box-ordinal-group: 1; /*Safari,Opera,Chrome*/ box-ordinal-group: 1;&#125; box-direction属性使用一个整数值： 1234.item&#123; box-ordinal-group: &lt;integer&gt;; /*显示次序：&lt;一个整数，默认为1，数值越小越排前&gt;*/&#125; 新版语法1. 定义容器的display属性123456789.box&#123; display: -webkit-flex; /*webkit*/ display: flex;&#125;/*行内flex*/.box&#123; display: -webkit-inline-flex; /*webkit*/ display:inline-flex;&#125; 2. 容器样式12345678910111213141516171819.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125; 3. 子元素属性12345678910111213141516171819.item&#123; order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 兼容写法1. 定义容器的 display 属性1234567.box&#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125; 由于旧版语法并没有列入W3C标准，所以这里不用写 display:box ，下面的语法也是一样的。 这里还要注意的是，如果子元素是行内元素，在很多情况下都要使用 display:block 或 display:inline-block 把行内子元素变成块元素（例如使用 box-flex 属性），这也是旧版语法和新版语法的区别之一。 2. 子元素主轴对齐方式123456.box&#123; -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center;&#125; 这里旧版语法有4个参数，而新版语法有5个参数，兼容写法新版语法的 space-around 是不可用的： 1234567.box&#123; box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/&#125; 3. 子元素交叉轴对齐方式123456.box&#123; -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center;&#125; 这里的参数除了写法不同，其实是功能是一样的： 1234567.box&#123; box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 4. 子元素的显示方向 子元素的显示方向可通过 box-direction + box-orient + flex-direction 实现，下面请看实例： 4.1 左到右1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row;&#125; 4.2 右到左12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse;&#125; 这里补充说明一点： box 写法的 box-direction 只是改变了子元素的排序，并没有改变对齐方式，需要新增一个 box-pack 来改变对齐方式。 4.3 上到下1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column;&#125; 4.4 下到上12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse;&#125; 5. 是否允许子元素伸缩 123456.item&#123; -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1;&#125; 123456.item&#123; -webkit-box-flex: 1.0; -moz-flex-shrink: 1; -webkit-flex-shrink: 1; flex-shrink: 1;&#125; 上面是允许放大，box语法中 box-flex 如果不是0就表示该子元素允许伸缩，而flex是分开的，上面 flex-grow 是允许放大（默认不允许），下面的 flex-shrink 是允许缩小（默认允许）。box-flex 默认值为0，也就是说，在默认的情况下，在两个浏览器中的表现是不一样的： 这里还有一点，就是新旧语法的算法是不一样的，假设 box-flex 的值不等于0，旧语法中，如果有多余的空间，box-flex 的值越大，说明空白部分的占比越多，反之亦然： 而新版的语法中，放大的比例是直接按 flex-grow 的值来分配的，flex-grow 的缩放会覆盖 flex-shrink:0，看例子： 参数： 12345678910.item&#123; box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/&#125; 6. 子元素的显示次序123456.item&#123; -webkit-box-ordinal-group: 1; -moz-order: 1; -webkit-order: 1; order: 1;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://doubleray.top/tags/CSS/"},{"name":"Flex","slug":"Flex","permalink":"https://doubleray.top/tags/Flex/"}]},{"title":"JavaScript 原型及原型链","slug":"article-js-prototypes","date":"2017-01-14T13:25:15.000Z","updated":"2021-06-24T04:02:41.970Z","comments":true,"path":"2017/01/14/article-js-prototypes/","link":"","permalink":"https://doubleray.top/2017/01/14/article-js-prototypes/","excerpt":"之前对 JavaScript 中的原型链和原型对象有所了解，每当别人问我什么是原型链和原型对象时，我总是用很官方（其实自己不懂）的解释去描述。有一句话说的好：如果你不能把一个很复杂的东西用最简单的话语描述出来，那就说明你没有真正的理解。 本文转自 trigkit4专栏—— 原型和原型链详解。","text":"之前对 JavaScript 中的原型链和原型对象有所了解，每当别人问我什么是原型链和原型对象时，我总是用很官方（其实自己不懂）的解释去描述。有一句话说的好：如果你不能把一个很复杂的东西用最简单的话语描述出来，那就说明你没有真正的理解。 本文转自 trigkit4专栏—— 原型和原型链详解。 1. 私有变量和函数 在函数内部定义的变量和函数，如果不对外提供接口，外部是无法访问到的，也就是该函数的私有的变量和函数。 123456789&lt;script type=\"text/javascript\"&gt; function Box()&#123; var color = \"blue\";//私有变量 var fn = function() //私有函数 &#123; &#125; &#125;&lt;/script&gt; 这样在函数对象Box外部无法访问变量color和fn，他们就变成私有的了： 123var obj = new Box(); alert(obj.color);//弹出 undefined alert(obj.fn);//同上 2. 静态变量和函数 当定义一个函数后通过点号 “.” 为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。 12345678910111213141516&lt;script type=\"text/javascript\"&gt; function Obj()&#123;&#125;; Obj.num = 72;//静态变量 Obj.fn = function() //静态函数 &#123; &#125; alert(Obj.num);//72 alert(typeof Obj.fn)//function var t = new Obj(); alert(t.name);//undefined alert(typeof t.fn);//undefined&lt;/script&gt; 3. 实例变量和函数 在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样: 123456789101112&lt;script type=\"text/javascript\"&gt; function Box()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125; &#125; console.log(typeof Box.a); //undefined console.log(typeof Box.fn); //undefined var box=new Box(); console.log(typeof box.a); //object console.log(typeof box.fn); //function&lt;/script&gt; 为实例变量和方法添加新的方法和属性: 123456789101112131415&lt;script type=\"text/javascript\"&gt;function Box()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125; &#125; var box1=new Box(); box1.a.push(1); box1.fn=&#123;&#125;; console.log(box1.a); //[1] console.log(typeof box1.fn); //object var box2=new Box(); console.log(box2.a); //[] console.log(typeof box2.fn); //function&lt;/script&gt; 在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。 这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。 4. 基本概念 我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用 构造函数 而创建的那个对象实例的原型对象。 使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。 在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为 原型 。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为 原型链 。 4.1 含义 函数可以用来作为构造函数来使用。另外只有函数才有prototype属性并且可以访问到，但是对象实例不具有该属性，只有一个内部的不可访问的__proto__属性。__proto__是对象中一个指向相关原型的神秘链接。按照标准，__proto__是不对外公开的，也就是说是个私有属性，但是 Firefox 的引擎将他暴露了出来成为了一个共有的属性，我们可以对外访问和设置。 123456789&lt;script type=\"text/javascript\"&gt; var Browser = function()&#123;&#125;; Browser.prototype.run = function()&#123; alert(\"I'm Gecko,a kernel of firefox￼\"); &#125; var Bro = new Browser(); Bro.run();&lt;/script&gt; 当我们调用Bro.run()方法时，由于Bro中没有这个方法，所以，他就会去他的__proto__中去找，也就是Browser.prototype，所以最终执行了该run()`方法（在这里，函数首字母大写的都代表构造函数，以用来区分普通函数）。 当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。 12345678910111213141516&lt;script type=\"text/javascript\"&gt;function Person(name)&#123; //构造函数 this.name=name; &#125; Person.prototype.printName=function() //原型对象 &#123; alert(this.name); &#125; var person1=new Person('Byron');//实例化对象 console.log(person1.__proto__);//Person console.log(person1.constructor);//自己试试看会是什么吧 console.log(Person.prototype);//指向原型对象Person var person2=new Person('Frank');&lt;/script&gt; Person的实例person1中包含了name属性，同时自动生成一个__proto__属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法，大概就是这个样子的: 每个JavaScript函数都有prototype属性，这个属性引用了一个对象，这个对象就是原型对象。原型对象初始化的时候是空的，我们可以在里面自定义任何属性和方法，这些方法和属性都将被该构造函数所创建的对象继承。 那么，现在问题来了。构造函数、实例和原型对象三者之间有什么关系呢？ 5. 构造函数、实例和原型对象的区别 实例就是通过构造函数创建的。实例一创造出来就具有constructor属性（指向构造函数）和__proto__属性（指向原型对象），构造函数中有一个prototype属性，这个属性是一个指针，指向它的原型对象。原型对象内部也有一个指针（constructor属性）指向构造函数：Person.prototype.constructor = Person；实例可以访问原型对象上定义的属性和方法。在这里person1和person2就是实例，prototype是他们的原型对象。 再举个栗子： 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function Animal(name) //积累构造函数 &#123; this.name = name;//设置对象属性 &#125; Animal.prototype.behavior = function() //给基类构造函数的prototype添加behavior方法 &#123; alert(\"this is a \"+this.name); &#125; var Dog = new Animal(\"dog\");//创建Dog对象 var Cat = new Animal(\"cat\");//创建Cat对象 Dog.behavior();//通过Dog对象直接调用behavior方法 Cat.behavior();//output \"this is a cat\" alert(Dog.behavior==Cat.behavior);//output true;&lt;/script&gt; 可以从程序运行结果看出，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。（可以试一下将Animal.prototype.behavior 中的prototype属性去掉，看看还能不能运行。）在这里，prototype属性指向Animal对象。 6. 数组对象实例 再看个数组对象的实例。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下： 1var array1 = [1,2,3]; array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素： 1array1.push(4); push这个方法来自于array1的__proto__成员指向对象的一个方法(Array.prototye.push())。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象(Array.prototype)的__proto__成员，才使得这些数组对象可以使用push,reverse等方法。 7. 函数对象实例123function Base() &#123; this.id = \"base\" &#125; 1var obj = new Base(); 这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是： new操作符具体干了什么呢?其实很简单，就干了三件事情: 123var obj = &#123;&#125;; obj.__proto__ = Base.prototype; Base.call(obj); 8. 原型链 原型链：当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; function Shape()&#123; this.name = \"shape\"; this.toString = function()&#123; return this.name; &#125; &#125; function TwoShape()&#123; this.name = \"2 shape\"; &#125; function Triangle(side,height)&#123; this.name = \"Triangle\"; this.side = side; this.height = height; this.getArea = function()&#123; return this.side*this.height/2; &#125; &#125; TwoShape.prototype = new Shape(); Triangle.prototype = new TwoShape();&lt;/script&gt; 这里，用构造器Shape()新建了一个实体，然后用它去覆盖该对象的原型。 123456789101112131415161718192021222324252627282930&lt;script type=\"text/javascript\"&gt; function Shape()&#123; this.name = \"shape\"; this.toString = function()&#123; return this.name; &#125; &#125; function TwoShape()&#123; this.name = \"2 shape\"; &#125; function Triangle(side,height)&#123; this.name = \"Triangle\"; this.side = side; this.height = height; this.getArea = function()&#123; return this.side*this.height/2; &#125; &#125; TwoShape.prototype = new Shape(); Triangle.prototype = new TwoShape(); TwoShape.prototype.constructor = TwoShape; Triangle.prototype.constructor = Triangle; var my = new Triangle(5,10); my.getArea(); my.toString();//Triangle my.constructor;//Triangle(side,height)&lt;/script&gt; 9. 原型继承 原型继承：在原型链的末端，就是Object构造函数prototype属性指向的那个原型对象。这个原型对象是所有对象的祖先，这个老祖宗实现了诸如toString等所有对象天生就该具有的方法。其他内置构造函数，如Function，Boolean，String，Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。 ECMAScript中，实现继承的方法就是依靠原型链实现的。 12345678910111213141516&lt;script type=\"text/javascript\"&gt; function Father()&#123; //被继承的函数叫做超类型（父类，基类） this.name = \"Jack\";&#125;function Son()&#123; //继承的函数叫做子类型（子类，派生类） this.age = 10;&#125;//通过原型链继承，赋值给子类型的原型属性//new Father()会将father构造里的信息和原型里的信息都交给SonSon.prototype = new Father();//Son继承了Father,通过原型，形成链条var son = new Son();alert(son.name);//弹出 Jack&lt;/script&gt; 原型链的问题：原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中最主要的问题来自包含引用类型的值原型。包含引用类型的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上回变成另一个类型的实例。于是，原先的实例属性也就变成了原型的属性。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。再加上刚刚讨论的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 再举个栗子： 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; function Person(name) &#123; this.name = name;//设置对象属性 &#125;; Person.prototype.company = \"Microsoft\";//设置原型的属性 Person.prototype.SayHello = function() //原型的方法 &#123; alert(\"Hello,I'm \"+ this.name+ \" of \" + this.company); &#125;; var BillGates = new Person(\"BillGates\");//创建person对象 BillGates.SayHello();//继承了原型的内容，输出\"Hello,I'm BillGates of Microsoft\" var Jobs = new Person(\"Jobs\"); Jobs.company = \"Apple\";//设置自己的company属性，掩盖了原型的company属性 Jobs.SayHello = function() &#123; alert(\"Hi,\"+this.name + \" like \" + this.company); &#125;; Jobs.SayHello();//自己覆盖的属性和方法，输出\"Hi,Jobs like Apple\" BillGates.SayHello();//Jobs的覆盖没有影响原型，BillGates还是照样输出&lt;/script&gt; 10. ptoto属性 __ptoto__属性（IE 浏览器不支持）是实例指向原型对象的一个指针，它的作用就是指向构造函数的原型属性constructor，通过这两个属性，就可以访问原型里的属性和方法了。 Javascript中的对象实例本质上是由一系列的属性组成的，在这些属性中，有一个内部的不可见的特殊属性——__proto__，该属性的值指向该对象实例的原型，一个对象实例只拥有一个唯一的原型。 123456789101112131415&lt;script type=\"text/javascript\"&gt; function Box()&#123; //大写，代表构造函数 Box.prototype.name = \"trigkit4\";//原型属性 Box.prototype.age = \"21\"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; &#125; var box1 = new Box(); var box2 = new Box(); alert(box1.constructor);//构造属性，可以获取构造函数本身， //作用是被原型指针定位，然后得到构造函数本身&lt;/script&gt; 10.1 proto属性和prototype属性的区别 prototype是function对象中专有的属性。 __proto__是普通对象的隐式属性，在new的时候，会指向prototype所指的对象；__ptoto__实际上是某个实体对象的属性，而prototype则是属于构造函数的属性。__ptoto__只能在学习或调试的环境下使用。 11. 原型模式的执行流程 先查找构造函数实例里的属性或方法，如果有，就立即返回。 如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回。 11.1 原型对象的123456789101112131415161718&lt;script type=\"text/javascript\"&gt; function Box()&#123; //大写，代表构造函数 Box.prototype.name = \"trigkit4\";//原型属性 Box.prototype.age = \"21\"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; &#125; var box1 = new Box(); alert(box1.name);//trigkit4,原型里的值 box1.name = \"Lee\"; alert(box1.name);//Lee,就进原则 var box2 = new Box(); alert(box2.name);//trigkit4,原型的值，没有被box1修改&lt;/script&gt; 11.2 构造函数的1234567891011121314151617&lt;script type=\"text/javascript\"&gt; function Box()&#123; this.name = \"Bill\"; &#125; Box.prototype.name = \"trigkit4\";//原型属性 Box.prototype.age = \"21\"; Box.prototype.run = function()//原型方法 &#123; return this.name + this.age + 'studying'; &#125; var box1 = new Box(); alert(box1.name);//Bill,原型里的值 box1.name = \"Lee\"; alert(box1.name);//Lee,就进原则&lt;/script&gt; 综上，整理一下： 123456789101112131415161718&lt;script type=\"text/javascript\"&gt; function Person()&#123;&#125;; Person.prototype.name = \"trigkit4\"; Person.prototype.say = function()&#123; alert(\"￼Hi\"); &#125; var p1 = new Person();//prototype是p1和p2的原型对象 var p2 = new Person();//p2为实例化对象，其内部有一个__proto__属性，指向Person的prototype console.log(p1.prototype);//undefined,这个属性是一个对象，访问不到 console.log(Person.prototype);//Person console.log(Person.prototype.constructor);//原型对象内部也有一个指针（constructor属性）指向构造函数 console.log(p1.__proto__);//这个属性是一个指针指向prototype原型对象 p1.say();//实例可以访问到在原型对象上定义的属性和方法 &lt;/script&gt; 123构造函数.prototype = 原型对象原型对象.constructor = 构造函数(模板)原型对象.isPrototypeof(实例对象) // 判断实例对象的原型 是不是当前对象 12. 工厂模式123456 function createObject(name,age)&#123; var obj = new Object(); obj.name = name; obj.age = age; return obj;&#125; 工厂模式解决了实例化对象大量重复的问题，但还有一个问题，那就是根本无法搞清楚他们到底是哪个对象的实例。使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。 使用构造函数的方法和工厂模式的不同之处在于： 构造函数方法没有显示的创建对象(new Object()); 直接将属性和方法赋值给this对象; 没有return 语句。 当使用了构造函数，并且new 构造函数，那么就在后台执行了new Object()； 函数体内的this代表了new Object()出来的对象。 判断属性是在构造函数的实例里，还是在原型里，可以使用hasOwnProperty()函数 字面量创建的方式使用constructor属性不会指向实例，而会指向Object，构造函数创建的方式则相反；为什么指向Object？因为Box.prototype = {};这种写法其实就是创建了一个新对象。而每创建一个函数，就会同时创建它的prototype，这个对象也会自动获取constructor属性 如果是实例方法，不同的实例化，他们的方法地址是不一样的，是唯一的 如果是原型方法，那么他们的地址的共享的","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"IIFE 详解","slug":"article-js-IIFE","date":"2017-01-14T11:25:15.000Z","updated":"2021-06-24T04:02:41.961Z","comments":true,"path":"2017/01/14/article-js-IIFE/","link":"","permalink":"https://doubleray.top/2017/01/14/article-js-IIFE/","excerpt":"在 JavaScript 中，每一个函数在被调用的时候都会创建一个执行上下文，在该函数内部定义的变量和函数只能在该函数内部被使用，而正是因为这个上下文，使得我们在调用函数的时候能创建一些私有变量。 本文参考 合理使用 IIFE 优化 JS 引擎的性能、详解javascript立即执行函数表达式（IIFE）。","text":"在 JavaScript 中，每一个函数在被调用的时候都会创建一个执行上下文，在该函数内部定义的变量和函数只能在该函数内部被使用，而正是因为这个上下文，使得我们在调用函数的时候能创建一些私有变量。 本文参考 合理使用 IIFE 优化 JS 引擎的性能、详解javascript立即执行函数表达式（IIFE）。 1. 立即执行函数（IIFE） 说起立即执行函数（IIFE，Immediately-invoked function expression）大家应该都不陌生，在 JavaScript 中可以声明一个函数然后立即执行它： 123(function()&#123;/* 函数体 */&#125;)()!function()&#123;/* 函数体 */&#125;() IIFE 通常用于实现私有变量、实现独立模块等等地方，比如喜闻乐见的 jQuery 最顶层的结构就是这样的： 12345(function(global, factory) &#123; //......&#125;)(typeof window !== \"undefined\" ? window : this, function(window, noGlobal) &#123; //......&#125;) 1.1 写法 立即执行函数 的写法可以说是五花八门： 1234567891011121314151617181920// 最常用的两种写法(function()&#123; /* code */ &#125;()); // 老道推荐写法(function()&#123; /* code */ &#125;)(); // 当然这种也可以 // 括号和JS的一些操作符（如 = &amp;&amp; || ,等）可以在函数表达式和函数声明上消除歧义// 如下代码中，解析器已经知道一个是表达式了，于是也会把另一个默认为表达式// 但是两者交换则会报错var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); // 如果你不怕代码晦涩难读，也可以选择一元运算符!function()&#123; /* code */ &#125;();~function()&#123; /* code */ &#125;();-function()&#123; /* code */ &#125;();+function()&#123; /* code */ &#125;(); // 你也可以这样new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 带参数 无论何时，给立即执行函数加上括号是个好习惯。 1.2 与闭包的暧昧关系 立即执行函数能配合闭包保存状态。 像普通的函数传参一样，立即执行函数也能传参数。如果在函数内部再定义一个函数，而里面的那个函数能引用外部的变量和参数（闭包），利用这一点，我们能使用立即执行函数锁住变量保存状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 并不会像你想象那样的执行，因为i的值没有被锁住// 当我们点击链接的时候，其实for循环已经执行完了// 于是在点击的时候i的值其实已经是elems.length了var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + i ); &#125;, 'false' ); &#125; // 这次我们得到了想要的结果// 因为在立即执行函数内部，i的值传给了lockedIndex，并且被锁在内存中// 尽管for循环结束后i的值已经改变，但是立即执行函数内部lockedIndex的值并不会改变var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; (function( lockedInIndex )&#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;, 'false' ); &#125;)( i ); &#125; // 你也可以这样，但是毫无疑问上面的代码更具有可读性var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', (function( lockedInIndex )&#123; return function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;; &#125;)( i ), 'false' ); &#125; 其实上面代码的lockedIndex也可以换成i，因为两个i是在不同的作用域里，所以不会互相干扰，但是写成不同的名字更好解释。以上便是立即执行函数+闭包的作用。 1.3 IIFE 与 Module 模式 立即执行函数在模块化中也大有用处。用立即执行函数处理模块化可以减少全局变量造成的空间污染，构造更多的私有变量。 12345678910111213141516171819202122232425262728293031// 创建一个立即执行的匿名函数// 该函数返回一个对象，包含你要暴露的属性// 如下代码如果不使用立即执行函数，就会多一个属性i// 如果有了属性i，我们就能调用counter.i改变i的值// 对我们来说这种不确定的因素越少越好 var counter = (function()&#123; var i = 0; return &#123; get: function()&#123; return i; &#125;, set: function( val )&#123; i = val; &#125;, increment: function() &#123; return ++i; &#125; &#125;;&#125;()); // counter其实是一个对象 counter.get(); // 0counter.set( 3 );counter.increment(); // 4counter.increment(); // 5 counter.i; // undefined i并不是counter的属性i; // ReferenceError: i is not defined (函数内部的是局部变量) 1.4 自执行匿名函数和立即执行的函数表达式区别 在这篇帖子里，我们一直叫自执行函数，确切的说是自执行匿名函数（Self-executing anonymous function），但英文原文作者一直倡议使用立即调用的函数表达式（Immediately-Invoked Function Expression）这一名称，作者又举了一堆例子来解释，好吧，我们来看看： 12345678910111213141516171819202122232425// 这是一个自执行的函数，函数内部执行自身，递归function foo() &#123; foo(); &#125;// 这是一个自执行的匿名函数，因为没有标示名称// 必须使用arguments.callee属性来执行自己var foo = function () &#123; arguments.callee(); &#125;;// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数var foo = function () &#123; foo(); &#125;;// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。(function () &#123; /* code */ &#125; ());// 为函数表达式添加一个标示名称，可以方便Debug// 但一定命名了，这个函数就不再是匿名的了(function foo() &#123; /* code */ &#125; ());// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了(function () &#123; arguments.callee(); &#125; ());(function foo() &#123; foo(); &#125; ());// 另外，下面的代码在黑莓5里执行会出错，因为在一个命名的函数表达式里，他的名称是undefined// 呵呵，奇怪(function foo() &#123; foo(); &#125; ()); 2. 针对 JS 引擎的一处性能优化 先从一个小问题说起吧，想实现一个立即执行的函数，上面提到有很多种写法，比如下面这两种： 123456789101112// 方法一，传入一个匿名函数function run(f)&#123; return f();&#125;run(function()&#123; //......&#125;);// 方法二，使用IIFE(function()&#123; //......&#125;)() 是的，这两种写法完全是等价的，无论怎么看都不会有什么区别，但是在一些 JavaScript 引擎中，它们其实性能相差甚远。 使用 Node 分别对两种情况运行了十万次，方法一的运行时间平均在 360 毫秒左右，方法二平均是 50 毫秒左右，性能相差 7 倍还多。 为什么使用 IIFE 之后性能会提升那么多呢？这就要从 JS 引擎（比如V8、SpiderMonkey）对于函数的优化上说起了。 现在的 JS 引擎都是十分聪明的，它们在真正执行代码之前会对代码中函数声明做一遍 pre-parse（预解析），为啥要做 pre-parse 呢？因为实际情况中大多数的函数都不是立即被使用的（甚至完全没被调用过），不需要对它们做一次完整的解析，只需要做一次性能开销更小的 pre-parse（比如检查一下语法错误），等函数真正被调用时，再进行完整的 full-parse。 1234567// 下面的函数会先进行pre-parsefunction foo() &#123; //......&#125;// 2秒之后函数被执行，又会进行一遍full-parsesetTimeout(foo, 2000); 但是有个问题！对于立即执行函数这种奇葩来说，它不适用于上面的规则，应该直接进行 full-parse。现在的大多数引擎也完全考虑到了这一点： 1234// 只会进行一次full-parse(function() &#123; //......&#125;)(); 但是还有个问题！！现在的大多数引擎检测 IIFE 的时候都不完全，大部分都是通过判别函数声明前有没有类似『 ( 』或者『 ! 』这样的字符来实现的，比如下面这种情况就被忽略掉了： 1234567// 这里要进行pre-parse和full-parse，而前者是多余的function run(f)&#123; return f();&#125;run(function()&#123; //......&#125;) 所以我们可以通过一个小 trick 来优化这里的性能（加了一对括号），这样引擎就会把这里识别为立即执行函数，然后只做一次 full-parse： 1234567// 只进行一次full-parsefunction run(f)&#123; return f();&#125;run((function()&#123; //......&#125;)); 所以针对这个问题，有一个专门的小工具来解决： nolanlawson/optimize-js: Optimize a JavaScript file for faster initial load by wrapping eagerly-invoked functions 还有一个相关的讨论： Turn off negate_iife by default as it hurts V8 performance. · Issue #886 · mishoo/UglifyJS2 这个看似不起眼的 trick 实际对于性能有很显著的提升： 这个问题本质上来讲是 JS 引擎对于立即执行函数的识别有遗漏导致的，比如在 Safari 10 中这个问题基本不会发生，而 Chrome 的 V8 中就经常出现。不过感觉随着引擎版本的迭代，这个问题应该会得到修复。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://doubleray.top/categories/学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"JavaScript 变量作用域","slug":"article-js-variate","date":"2017-01-13T04:19:15.000Z","updated":"2021-06-24T04:02:41.972Z","comments":false,"path":"2017/01/13/article-js-variate/","link":"","permalink":"https://doubleray.top/2017/01/13/article-js-variate/","excerpt":"在 JavaScript 当中一个变量的作用域（scope）是程序中定义这个变量的区域。变量分为两类：全局（global）的和局部的。其中全局变量的作用域是全局性的，即在 JavaScript 代码中，它处处都有定义。而在函数之内声明的变量，就只在函数体内部有定义。它们是局部变量，作用域是局部性的。 函数的参数也是局部变量，它们只在函数体内部有定义，局部变量省略了 var 也就默认成为了全局变量。 在函数体内部，局部变量的优先级高于同名的全局变量，如果在函数体内声明一个局部变量或者函数的参数中带有的变量和全局变量重名，那么全局变量就会被局部变量所遮盖，函数体内部可以读取到函数外的变量，而函数外不能读取到函数内的变量。","text":"在 JavaScript 当中一个变量的作用域（scope）是程序中定义这个变量的区域。变量分为两类：全局（global）的和局部的。其中全局变量的作用域是全局性的，即在 JavaScript 代码中，它处处都有定义。而在函数之内声明的变量，就只在函数体内部有定义。它们是局部变量，作用域是局部性的。 函数的参数也是局部变量，它们只在函数体内部有定义，局部变量省略了 var 也就默认成为了全局变量。 在函数体内部，局部变量的优先级高于同名的全局变量，如果在函数体内声明一个局部变量或者函数的参数中带有的变量和全局变量重名，那么全局变量就会被局部变量所遮盖，函数体内部可以读取到函数外的变量，而函数外不能读取到函数内的变量。 先看一个实例： code 1 12345var i=10; function a() &#123; alert(i); &#125;; a(); code 2 123456var i=10; function a() &#123; alert(i); var i = 2; &#125;; a(); 根据“多年”的编程经验你可能觉得这两个代码输出是一样的，但是事实却是第一个代码正常输出了变量的值—10，而第二个代码输出的却是 undefined。由此可以引出关于变量应该关注的几个问题： 1. 函数作用域 为什么说JavaScript没有块级作用域呢，有以下代码为证： 123456var name=\"global\"; if(true)&#123; var name=\"local\"; console.log(name) &#125; console.log(name); 都输出是 “local”，如果有块级作用域，明显 if 语句将创建局部变量 name，并不会修改全局 name，可是没有这样，所以Js没有块级作用域。 2. 声明提升 JavaScript 的变量声明具有hoisting机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面，包括变量和函数的声明。 先看一段代码: 123456(function()&#123; var a = \"1\"; var f = function()&#123;&#125;; var b = \"2\"; var c = \"3\";&#125;)(); 变量 a,f,b,c 的声明会被提升到函数作用域的最前面，类似如下： 1234567(function()&#123; var a,f,b,c; a = \"1\"; f = function()&#123;&#125;; b = \"2\"; c = \"3\";&#125;)(); 请注意函数表达式并没有被提升，这也是函数表达式与函数声明的区别。进一步看二者的区别： 123456789(function()&#123; //var f1,function f2()&#123;&#125;; //hoisting,被隐式提升的声明 f1(); //ReferenceError: f1 is not defined f2(); var f1 = function()&#123;&#125;; function f2()&#123;&#125;&#125;)(); 上面代码中函数声明f2被提升，所以在前面调用f2是没问题的。虽然变量f1也被提升，但f1提升后的值为undefined,其真正的初始值是在执行到函数表达式处被赋予的。所以只有声明是被提升的。 名字解析顺序 JavaScript 中一个名字(name)以四种方式进入作用域(scope)，其优先级顺序如下： 语言内置：所有的作用域中都有 this 和 arguments 关键字 形式参数：函数的参数在函数作用域中都是有效的 函数声明：形如function foo() {} 变量声明：形如var bar; 名字声明的优先级如上所示，也就是说如果一个变量的名字与函数的名字相同，那么函数的名字会覆盖变量的名字，无论其在代码中的顺序如何。但名字的初始化却是按其在代码中书写的顺序进行的，不受以上优先级的影响。看代码： 1234567(function()&#123; var foo; console.log(typeof foo); //function function foo()&#123;&#125; foo = \"foo\"; console.log(typeof foo); //string&#125;)(); 如果形式参数中有多个同名变量，那么最后一个同名参数会覆盖其他同名参数，即使最后一个同名参数并没有定义。 以上的名字解析优先级存在例外，比如可以覆盖语言内置的名字arguments。 3. 作用域链 先来看一段代码： 123456789101112131415var name=\"lwy\"; function t()&#123; var name=\"tlwy\"; function s()&#123; var name=\"slwy\"; console.log(name); &#125; function ss()&#123; console.log(name); &#125; s(); ss(); &#125; t(); 当执行 s() 时，将创建函数s的执行环境(调用对象),并将该对象置于链表开头，然后将函数 t 的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量 name,很明显 name 是 “slwy”。但执行 ss()时，作用域链是： ss() -&gt; t() -&gt; window，所以 name 是 “tlwy”，下面看一个很容易犯错的例子： 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function buttonInit()&#123; for(var i=1;i&lt;4;i++)&#123; var b=document.getElementById(\"button\"+i); b.addEventListener(\"click\",function()&#123; alert(\"Button\"+i);&#125;,false); &#125; &#125; window.onload=buttonInit; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"button1\"&gt;Button1&lt;/button&gt; &lt;button id=\"button2\"&gt;Button2&lt;/button&gt; &lt;button id=\"button3\"&gt;Button3&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 当文档加载完毕，给几个按钮注册点击事件，当我们点击按钮时，会弹出什么提示框呢？ 很容易犯错，对是的，三个按钮都是弹出：”Button4”，你答对了吗？当注册事件结束后， i 的值为4，当点击按钮时，事件函数即function(){ alert(&quot;Button&quot;+i);}这个匿名函数中没有i，根据作用域链，所以到buttonInit函数中找，此时i的值为4，所以弹出 ”button4“。 with 语句 说到作用域链，不得不说 with语句。with` 语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。看下面代码： 1234person=&#123;name:\"yhb\",age:22,height:175,wife:&#123;name:\"lwy\",age:21&#125;&#125;; with(person.wife)&#123; console.log(name); &#125; with 语句将 person.wife 添加到当前作用域链的头部，所以输出的就是：“lwy”。with 语句结束后，作用域链恢复正常。","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://doubleray.top/categories/面试总结/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://doubleray.top/tags/JavaScript/"}]},{"title":"gulp 实用指南","slug":"article-gulp-configure","date":"2017-01-11T11:45:15.000Z","updated":"2021-06-24T04:02:41.959Z","comments":true,"path":"2017/01/11/article-gulp-configure/","link":"","permalink":"https://doubleray.top/2017/01/11/article-gulp-configure/","excerpt":"本文旨在记录 gulp 配置及使用的过程，方便日后查阅。（本文参考 一点|gulp详细入门教程 ） gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。","text":"本文旨在记录 gulp 配置及使用的过程，方便日后查阅。（本文参考 一点|gulp详细入门教程 ） gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp 是基于 Nodejs 的自动任务运行器， 她能自动化地完成javascript/coffee/sass/less/html/image/css等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，它借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 gulp 参考地址：gulp官方网址、gulp插件地址、gulp 官方API、gulp 中文API、gulp.js 中文网… … gulp 配置 首先当然是安装 nodejs，通过 nodejs 的 npm 全局安装和项目安装 gulp，其次在项目里安装所需要的 gulp 插件，然后新建 gulp 的配置文件 gulpfile.js 并写好配置信息（定义 gulp 任务），最后通过命令提示符运行 gulp 任务即可。 安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务 1. node.js 安装 打开nodejs官网，点击硕大的绿色 Download 按钮，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意）。 通过命令行 node -v 和 npm -v 分别检查 node 和 npm 是否全局安装成功（如下图出现版本号即为安装成功，npm是在安装nodejs时一同安装的）。 2. npm 使用 npm（node package manager）nodejs 的包管理器，用于 node 插件管理（包括安装、卸载、管理依赖等），使用npm安装插件：命令提示符执行 npm install &lt;name&gt; -g --save-dev ,-g 为全局安装、--save-dev 为保存到本地，信息会配置到 package.json 内。 因为 npm 的服务器在国外，受网络影响大，可能出现异常，所以我们选择 淘宝的 npmjs.org 镜像 ，命令提示符执行 npm install cnpm -g –registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号 cnpm -v 或关闭命令提示符重新打开，安装完直接使用有可能会出现错误。 注：cnpm 跟 npm 用法完全一致，只是在执行命令时将 npm 改为 cnpm （以下操作将以 cnpm 代替 npm ）。 3. gulp 安装 在安装 gulp 之前需先在项目根目录下新建 package.json 文件或通过命令提示符执行 cnpm init（文件内不允许写注释，为什么？）。 3.1 全局安装 gulp 命令提示符执行 cnpm install gulp -g 全局安装 gulp，gulp -v 出现版本号即为正确安装（全局安装 gulp 目的是为了通过她执行 gulp 任务）。 3.2 本地安装 gulp 在项目根目录下执行命令提示符 cnpm install gulp --save-dev 本地安装 gulp（本地安装 gulp 目的是为了调用 gulp 插件的功能）。 4. gulp 插件安装 gulp的插件数量虽然没有grunt那么多，但也可以说是应有尽有了，下面列举一些常用的插件。 浏览器自动刷新页面：命令提示符执行 cnpm install gulp-livereload --save-dev； 自动处理浏览器前缀：命令提示符执行 cnpm install gulp-autoprefixer --save-dev； 合并javascript文件：命令提示符执行 cnpm install gulp-concat --save-dev； 压缩css文件：命令提示符执行 cnpm install gulp-clean-css --save-dev； 压缩图片文件：命令提示符执行 cnpm install gulp-imagemin --save-dev； 压缩html：命令提示符执行 cnpm install gulp-htmlmin --save-dev； less(sass)文件编译成css：命令提示符执行 cnpm install gulp-less(sass) --save-dev； 插件安装完成后打开 package.json 查看一下各个插件的版本号是否已被记录在 devDependencies 下，如被记录（如下）则说明插件安装成功。 1234567891011&quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-autoprefixer&quot;: &quot;^3.1.1&quot;, &quot;gulp-clean-css&quot;: &quot;^2.3.2&quot;, &quot;gulp-concat&quot;: &quot;^2.6.1&quot;, &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, &quot;gulp-imagemin&quot;: &quot;^3.1.1&quot;, &quot;gulp-less&quot;: &quot;^3.3.0&quot;, &quot;gulp-livereload&quot;: &quot;^3.8.1&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;&#125; gulp 运行 在 gulp 插件安装完成之后，还需要在项目根目录下新建一个 gulpfile.js 的配置文件（很重要）,参考配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 var gulp = require('gulp'), //导入工具包 require('node_modules里对应模块') less = require('gulp-less'),//编译less clean = require('gulp-clean-css'),//压缩css imagemin = require('gulp-imagemin'),//图片压缩 uglify = require('gulp-uglify'),//压缩js htmlmin = require('gulp-htmlmin'), //html压缩 livereload = require('gulp-livereload'), //浏览器自动刷新页面 autoprefixer = require('gulp-autoprefixer'), //根据设置浏览器版本自动处理浏览器前缀 concat = require('gulp-concat'); //合并js文件 //css压缩 gulp.task('testCssmin', function () &#123; gulp.src('src/index.css') .pipe(clean(&#123; advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7', //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) . pipe(gulp.dest('src')); &#125;); //less编译 gulp.task('less', function() &#123; gulp.src('Machinery/public/less/index.less') .pipe(less()) .pipe(gulp.dest('Machinery/build/css')) &#125;); //js压缩 gulp.task('jsmin', function () &#123; gulp.src('Machinery/public/js/*.js') .pipe(uglify()) .pipe(gulp.dest('Machinery/build/js')); &#125;); //js合并 gulp.task('testConcat', function () &#123; gulp.src('src/*.js') .pipe(concat('zepto.concat.js'))//合并后的文件名 .pipe(gulp.dest('src')); &#125;); //图片压缩 gulp.task('testImagemin', function () &#123; gulp.src('last/construction/public/images/*.&#123;png,jpg,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('last/construction/build/images')); &#125;); //html压缩 gulp.task('testHtmlmin', function () &#123; var options = &#123; removeComments: true,//清除HTML注释 collapseWhitespace: true,//压缩HTML collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" minifyJS: true,//压缩页面JS minifyCSS: true//压缩页面CSS &#125;; gulp.src('Machinery/*.html') .pipe(htmlmin(options)) .pipe(gulp.dest('Machinery/.min.html')); &#125;); //自动刷新页面 gulp.task('less', function() &#123; gulp.src('src/less/*.less') .pipe(less()) .pipe(gulp.dest('src/css')) .pipe(livereload()); &#125;); //自动处理浏览器前缀 gulp.task('testAutoFx', function () &#123; gulp.src('src/css/index.css') .pipe(autoprefixer(&#123; browsers: ['last 2 versions', 'Android &gt;= 4.0','last 2 Explorer versions'], cascade: false, //是否美化属性值 默认：true 像这样： //-webkit-transform: rotate(45deg); // transform: rotate(45deg); remove:true //是否去掉不必要的前缀 默认：true &#125;)) .pipe(gulp.dest('dist/css')); &#125;); gulp.task('default',['testLess', 'elseTask']); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务 //当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。 //gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数 //gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径 以上为我现在本地的配置内容，最基础的使用足够，还有更深度的配置可参照 一点|gulp详细入门教程，gulp 相关的 API 介绍看 这里 。 1. 命令提示符运行 gulp 任务 运行 gulp 时执行命令提示符 gulp 任务名称，例如：编译less：命令提示符执行 gulp testLess。 2. webstorm 运行gulp任务 使用 webstorm 可视化运行 gulp 任务，首先将项目导入 webstorm ，右键 gulpfile.js 选择 ”Show Gulp Tasks” 打开 Gulp 窗口，若出现 ”No task found” ，选择右键 ”Reload tasks” ，双击运行即可。 总结 安装 nodejs； 新建 package.json 文件； 全局和本地安装 gulp； 安装 gulp 插件； 新建 gulpfile.js 文件； 通过命令提示符或 webstorm 运行 gulp 任务。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://doubleray.top/tags/gulp/"},{"name":"node","slug":"node","permalink":"https://doubleray.top/tags/node/"}]},{"title":"awesome-gulp 中文版","slug":"article-awesome-gulp","date":"2017-01-11T02:13:05.000Z","updated":"2021-06-24T04:02:41.953Z","comments":true,"path":"2017/01/11/article-awesome-gulp/","link":"","permalink":"https://doubleray.top/2017/01/11/article-awesome-gulp/","excerpt":"一份gulp的资源，插件和使用实例清单， 致力于打造更好的前端工程构建流程。 本文转自 Pines-Cheng github 的 awesome-gulp-cn 项目。 被老外的awesome 清单刺激到，觉得有必要翻译一份，为国产的程序员们做点事情，本清单将保持实时更新同步。","text":"一份gulp的资源，插件和使用实例清单， 致力于打造更好的前端工程构建流程。 本文转自 Pines-Cheng github 的 awesome-gulp-cn 项目。 被老外的awesome 清单刺激到，觉得有必要翻译一份，为国产的程序员们做点事情，本清单将保持实时更新同步。PS:进都进来了，就顺便看看其他的吧: awesome-nodejs-cn awesome-react-cn awesome-npm-cn awesome-react-native-cn 项目的Github地址：awesome-react-cn,欢迎start。 翻译得仓促，如有问题，请提issues。 如果想贡献，请Pull Requests。 目录 资源 通用资源 官方文档 组织 入门教程 Gulp 入门 Gulp 4 入门 Gulp with Browserify Gulp with Angular Gulp with Angular and Browserify Gulp with Angular and Webpack Gulp with React and Browserify Gulp with Ember 其他资源 插件 编辑 编译 合并 压缩 优化 资源注入 模板 代码校验 实时加载 缓存 流控制 日志 测试 其他插件 脚手架 参考工程 Yeoman生成器 其他 资源1.通用资源 官网 Github库 插件注册 NPM模块 插件黑名单 2.官方文档 快速开始 API文档 CLI 文档 开始写一个插件 使用诀窍 3.组织 StackOverflow Twitter 4.入门教程1）Gulp入门 使用Gulp构建前端工程 通过Gulp.js轻松自动化构建你的前端工程 Gulp，让前端工程可视化 Gulp.js是什么？ 使用Gulp在你的HTML中直接插入Scripts和Styles标签 5节课学会使用Gulp.js 我是怎样摆脱前端工程的困扰的？ 第一次开始Gulp Task 为什么你不自己写一个Gulp插件？ 6个最好的从根本改善你的开发经验的Gulp实战练习 Gulp初学者教程 2）Gulp 4 入门 迁移到Gulp 4的例子 Gulp 4: 新的task执行系统 - gulp.parallel 和 gulp.series 3）Gulp with Browserify Gulp + Browserify, the Gulp-y Way Gulp + Browserify 快速构建Browserify和Watchify 4）Gulp with Angular Angular工程需要什么 - Gulp能提供什么 5）Gulp with Angular and Browserify 使用 Gulp, Node and Browserify构建先进的 AngularJS工程结构 6）Gulp with React and Browserify Browserify、Gulp 和 React Taking React to the Next Level: Mixins, Gulp, and Browserify 7）Gulp with Ember 使用Gulp.js改进你的Ember.js工作流 5.其他资源 Gulp 备忘录 Gulp清单 插件1.编译 gulp-sass - 通过 libsass将Sass编译成 CSS gulp-ruby-sass - 通过 Ruby Sass将Sass编译成CSS gulp-compass - 通过 Ruby Sass和CompassSass编译成CSS gulp-less - Less编译成 CSS. gulp-stylus - Stylus 编译成 CSS. gulp-postcss - Pipe CSS 通过 PostCSS processors with a single parse. gulp-coffee - Coffeescript 编译成 JavaScript. gulp-typescript - TypeScript编译成JavaScript. gulp-react - Facebook React JSX 模板编译成JavaScript. webpack-stream - 将webpack集成在Gulp中使用。 gulp-babel - ES6编译成ES5 通过 babel. gulp-traceur - ES6编译成ES5 通过 Traceur. gulp-regenerator - ES6编译成ES5 通过 Regenerator. gulp-es6-transpiler - [过时的] ES6编译成ES5 通过 es6-transpiler. gulp-myth - Myth - a polyfill for future versions of the CSS spec. gulp-cssnext - [过时的] 使用下一代的 CSS 规范通过 cssnext. 2.合并 gulp-concat - 合并文件. 3.压缩 gulp-clean-css - 压缩 CSS 通过 clean-css. gulp-csso - 压缩 CSS 通过 CSSO. gulp-uglify - 压缩 JavaScript 通过 UglifyJS2. gulp-htmlmin - 压缩 HTML 通过 html-minifier. gulp-minify-html - 压缩 HTML 通过Minimize. gulp-imagemin - 压缩 PNG, JPEG, GIF and SVG 图片 通过 imagemin. gulp-svgmin - 通过Gulp压缩 SVG 文件 4.优化 gulp-uncss - 移除未使用的CSS选择器通过 UnCSS. gulp-css-base64 - 将CSS文件中所有的资源(有url()声明的)变成base64-encoded 数据的URI字符串 gulp-svg2png - 将SVGs转换成PNGs gulp-responsive - 生成不同尺寸的图片 gulp-svgstore -将svg files 合并成一个通过 元素 gulp-iconfont - 通过SVG icons创建 icon fonts 5.资源注入 gulp-useref - 解析HTML文件中特殊标签里面的script或style标签，合并成一个script或css文件，并替换。 gulp-inject - 将指定的css或js文件以标签的形式插入到HTML中的指定标志内。 wiredep - 将Bower依赖自动注入HTML文件中。 6.模板 gulp-angular-templatecache - 在$templateCache中联系并注册AngularJS模板 gulp-jade - Jade 转换成 HTML. gulp-handlebars - Handlebars模板转换成 JavaScript. gulp-hb - Handlebars 模板转换成 HTML. gulp-nunjucks - Nunjucks模板转换成JavaScript. gulp-dustjs - Dust模板转换成JavaScript. gulp-riot - Riot模板转换成JavaScript. gulp-markdown - Markdown → HTML. gulp-template - Lodash 模板转换成JavaScript. gulp-swig - Swig模板转换成HTML. gulp-remark - Gulp plugin for [remark]的Gulp插件(https://github.com/wooorm/remark) 通过插件处理markdown 7.代码校验 gulp-csslint - 通过CSSLint自动校验CSS. gulp-htmlhint - 通过HTMLHint校验HTML. gulp-jshint - 通过JSHint发现错误和潜在的问题. gulp-jscs - 通过jscs检查JavaScript代码风格. gulp-coffeelint - 一种用来保证CoffeeScript代码风格统一的检查。 gulp-tslint - gulp的TypeScript代码校验插件. gulp-eslint - ECMAScript/JavaScript代码校验. gulp-w3cjs - 通过w3cjs检验HTML. gulp-lesshint - 通过lesshint校验LESS. 8.实时加载 browser-sync - 保证多个浏览器或设备网页同步显示 (recipes). gulp-livereload - Gulp的实时加载插件. 9.缓存 gulp-changed - 仅让发生改变的文件通过. gulp-cached - 一个简单的文件内存缓存. gulp-remember - 记忆并回收通过了的文件. gulp-newer - 只让新的源码通过. 10.流控制 merge-stream - 合并多个流到一个插入的流. streamqueue - 逐渐输入队列的流. run-sequence - 按要求运行一些依赖的Gulptask. gulp-if - 按照条件运行task. 11.日志 gulp-notify - Gulp的通知插件. gulp-size - 显示你的项目的大小. gulp-debug - 通过调试文件流来观察那些文件通过了你的Gulp管道. 12.测试 gulp-mocha - 运行Mocha测试用例. gulp-jasmine - 在Node.js中运行Jasmine 2 测试用例. gulp-protractor - 为Protractor测试用例包裹Gulp. gulp-coverage - 为Node.js覆盖相对于运行的测试运行独立的报告. gulp-karma - 通过Gulp运行Karma测试用例. gulp-ava- 通过Gulp运行AVA 测试用例. 13.其他插件 gulp-util - 包含一系列有用插件. gulp-plumber - 防止错误引起管道中断Prevent pipe breaking caused by errors. gulp-load-plugins - 自动加载Gulp插件. main-bower-files - 构建时自动获取bower库的文件. autoprefixer - 解析CSS且根据规则添加浏览器兼容性前缀. gulp-sourcemaps - 提供source map支持. gulp-replace - Gulp的一个字符串替换插件. gulp-rename - 轻松重命名文件. gulp-rev - 在静态文件名的后面添加hash值，如: unicorn.css → unicorn-d41d8cd98f.css. del - 使用globs删除文件/文件夹. gulp-exec - 运行一个shell命令. gulp-strip-debug - 除去javascript代码中的console,alert,debugger声明. gulp-cssimport - 解析CSS文件，找到imports,将连接文件替换成imort声明. gulp-inline-css - 将HTML中的css属性放到style标签中. gulp-gh-pages - 将内容发布到GiHub有页面. gulp-ng-annotate - 通过ng-annotate添加Angular依赖注入. gulp-bump - 通过Gulp Bump任何semvar JSON版本. gulp-file-include - 通过Gulp Include文件. gulp-zip - 以ZIP格式压缩文件. gulp-git - 通过Gulp运行git命令. gulp-filter - 使用globbing过滤文件. gulp-preprocess - 基于自定义内容或环境配置预处理文件. 脚手架1.模板 web-starter-kit - Google的Web Starter Kit. gulp-plugin-boilerplate - 创建Gulp插件的开始模板. polymer-starter-kit -Polymer 1.0 应用的起点. este - 同构的web应用最全面的React/Flux开发栈和开始模板. mnml - 开发响应式HTML5/Sass项目的最小开始模板. kraken 一个轻量级的、移动端优先的前端开发开始模板. angularjs-gulp-browserify-boilerplate - 一个使用AngularJS, Sass, gulp, 和 Browserify技术的开始模板. hapi-ninja - 一个使用Node.js, Hapi, and Swig技术的开始模板. laravel-5-boilerplate - 一个Laravel 5 开始模板. react-starterkit - 包含react-router, Reflux, jest, webpack, gulp and Stylus的React开始模板. 2.Yeoman生成器 generator-gulp-webapp - A 一个流行的web应用的gulp生成器. generator-gulp-angular - 使用Gulp的AngularJS 的Yeoman生成器. generator-react-gulp-browserify - 一个React库的Yeoman生成器，包含gulp, Browserify, Browsersync and Bootstrap. generator-node-gulp - 一个Node.js模块生成器，包含gulp和 Mocha. generator-gulp-bootstrap - 一个包含Bootstrap, gulp 和libsass的Yeoman生成器·. generator-angulpify - 一个包含AngularJS, gulp和Browserify的Yeoman生成器. generator-ionic-gulp - 一个Ionic工厂的Yeoman生成器. generator-gulp-plugin-boilerplate -一个输出 gulp plugin boilerplate的脚手架. generator-jekyllized - 一个包含gulp, Sass, AutoPrefixer,资源优化，缓存等的Jekyll工作流. 其他 elixir - 一个为你的应用定义基本的gulp任务的干净、灵活的API. gulp-app - 将Gulp作为一个应用(OS X). lmn-gulp-tasks - gulp任务的单元测试示例. gulp-chef - 一个优雅的、简单的重复使用gulp task的方法.","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://doubleray.top/tags/gulp/"}]},{"title":"Liquid 指南","slug":"article-liquid-skills","date":"2017-01-10T11:25:15.000Z","updated":"2021-06-24T04:02:41.973Z","comments":true,"path":"2017/01/10/article-liquid-skills/","link":"","permalink":"https://doubleray.top/2017/01/10/article-liquid-skills/","excerpt":"最近折腾 github pages 上博客的时候, 遇到一些 jekyll 问题，准确的来说应该是 Liquid 用法的问题。 于是一系列搜索之后终于找到了两篇根据 Liquid for Designers 翻译的不错的文档可以做基本的参考，分别是 Coffee coder 的 liquid用法笔记 和 Havee’s Space 的 Jekyll 扩展的 Liquid 设计 。","text":"最近折腾 github pages 上博客的时候, 遇到一些 jekyll 问题，准确的来说应该是 Liquid 用法的问题。 于是一系列搜索之后终于找到了两篇根据 Liquid for Designers 翻译的不错的文档可以做基本的参考，分别是 Coffee coder 的 liquid用法笔记 和 Havee’s Space 的 Jekyll 扩展的 Liquid 设计 。 一下是本人参考以上文档做的小指南，方便以后翻阅。 在 Liquid 中有两种类型的标记：Output(用于输出文本) 和 Tag(用于执行命令或者处理) 。 Output 标记被包含在： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123;&#123; 两个配对的花括号中 &#125;&#125;``` + `Tag` 标记被包含在: ```ruby&#123;% 成对的花括号和百分号中 %&#125;``` ## Output### 1. 基本输出 下面是关于输出标记的简单实例：```liquidHello &#123;&#123; name &#125;&#125;Hello &#123;&#123; user.name &#125;&#125;Hello &#123;&#123; 'tobi' &#125;&#125;``` ### 2. 高级 Output：过滤器 (Filters) 输入标记带有过滤器，方法很简单。第一个参数总是过滤器左边值的输出。当下个过滤器运行时，刚刚所得到的过滤器返回值就会成为新的左边值。直到最后没有过滤器时，模板就会接受最后的结果字符串。```liquidHello &#123;&#123; 'tobi' | upcase &#125;&#125;Hello tobi has &#123;&#123; 'tobi' | size &#125;&#125; letters!Hello &#123;&#123; 'tobi' | capitalize &#125;&#125;Hello &#123;&#123; '1984-02-01' | date: \"%Y\" &#125;&#125;``` 输出结果是：```rubyHello &#123;&#123; 'tobi' | upcase &#125;&#125;Hello tobi has &#123;&#123; 'tobi' | size &#125;&#125; letters!Hello &#123;&#123; 'tobi' | capitalize &#125;&#125;Hello &#123;&#123; '1984-02-01' | date: \"%Y\" &#125;&#125;``` ### 3. 标准过滤器```liquiddate - 格式化日期capitalize - 将输入语句的首字母大写downcase - 将输入字符串转为小写upcase - 将输入字符串转为大写first - 得到传递数组的第一个元素last - 得到传递数组的最后一个元素join - 将数组中的元素连成一串，中间通过某些字符分隔sort - 对数组元素进行排序map - 从一个给定属性中映射/收集一个数组size - 返回一个数组或字符串的大小escape - 对一串字符串进行编码escape_once - 返回一个转义的html版本，而不影响现有的转义文本strip_html - 去除一串字符串中的所有html标签strip_newlines - 从字符串中去除所有换行符(\\n)newline_to_br - 将所有的换行符(\\n)换成 html 的换行标记replace - 匹配每一处指定字符串，如 &#123;&#123; 'foofoo' | replace:'foo','bar' &#125;&#125; #=&gt; 'barbar'replace_first - 匹配第一处指定的字符串，如 &#123;&#123; 'barbar' | replace_first:'bar','foo' &#125;&#125; #=&gt; 'foobar'remove - 删除每一处匹配字符串，如 &#123;&#123; 'foobarfoobar' | remove:'foo' &#125;&#125; #=&gt; 'barbar'remove_first - 删除第一处匹配的字符串，如 &#123;&#123; 'barbar' | remove_first:'bar' &#125;&#125; #=&gt; 'bar'truncate - 将一串字符串截断为x个字符truncatewords - 将一串字符串截断为x个单词prepend - 在一串字符串前面加上指定字符串，如 &#123;&#123; 'bar' | prepend:'foo' &#125;&#125; #=&gt; 'foobar'append - 在一串字符串后面加上指定字符串，如 &#123;&#123; 'foo' | append:'bar' &#125;&#125; #=&gt; 'foobar'minus - 减，如 &#123;&#123; 4 | minus:2 &#125;&#125; #=&gt; 2plus - 加，如 &#123;&#123; '1' | plus:'1' &#125;&#125; #=&gt; '11', &#123;&#123; 1 | plus:1 &#125;&#125; #=&gt; 2times - 乘，如 &#123;&#123; 5 | times:4 &#125;&#125; #=&gt; 20divided_by - 除，如 &#123;&#123; 10 | divided_by:2 &#125;&#125; #=&gt; 5split - 将一串字符串根据匹配模式分割成数组，如 &#123;&#123; \"a~b\" | split:~ &#125;&#125; #=&gt; \\['a','b'\\]modulo - 余数，如 &#123;&#123; 3 | modulo:2 &#125;&#125; #=&gt; 1 Tags Tags 用于你的模板逻辑。新的标签很容易开发，因此我希望在发布这些代码后，大家可以为标准标签库增加更多的内容。 下列是当前已经支持的标签： 12345678910assign - 将一些值赋给一个变量capture - 块标记，把一些文本捕捉到一个变量中case - 块标记，标准的 case 语句Comments - 块标记，将一块文本作为注释cycle - Cycle 通常用于循环轮换值，如颜色或 DOM 类。for - 用于循环 For loopif - 标准的 if/else 块include - 包含其他的模板；对于区块化非常有效raw - 暂时性的禁用的标签的解析unless - if 语句的简版 1. Comments 注释是最简单的标签，它只是把内容包含起来。 12345678910111213We made 1 million dollars &#123;% comment %&#125; in losses &#123;% endcomment %&#125; this year``` ### 2. Raw Raw 暂时性的禁用标签的解析。这在需要展示一些可能产生冲突的内容（如本页面，要展示 liquid 语句，就需要包含在 raw 标签间，否则会被解析）时非常有用。 &#123;% raw %&#125;```liquid｛% raw %｝ We made 1 million dollars &#123;% comment %&#125; in losses &#123;% endcomment %&#125; this year｛% endraw %｝ 3. If/Else if/else 在其他编程语言里应该已经被熟知了。Liquid 使得你可以通过 if``` 或 unless ( elsif 和 else 为可选 ) 编写简单的表达式: {% if user %} Hello {{ user.name }} {% endif %} {% if user.name == 'tobi' %} Hello tobi {% elsif user.name == 'bob' %} Hello bob {% endif %} {% if user.name == 'tobi' or user.name == 'bob' %} Hello tobi or bob {% endif %} {% if user.name == 'bob' and user.age > 45 %} Hello old bob {% endif %} {% if user.name != 'tobi' %} Hello non-tobi {% endif %} # 同上 {% unless user.name == 'tobi' %} Hello non-tobi {% endunless %} # 检测是否用户有一张信用卡 {% if user.creditcard != null %} poor sob {% endif %} # 同上 {% if user.creditcard %} poor sob {% endif %} # Check for an empty array {% if user.payments == empty %} you never paid ! {% endif %} {% if user.age > 18 %} Login here {% else %} Sorry, you are too young {% endif %} # array = 1,2,3 {% if array contains 2 %} array includes 2 {% endif %} # string = &apos;hello world&apos; {% if string contains 'hello' %} string includes 'hello' {% endif %} 4. Case 如果你需要更多的条件判断，你可以使用 case 语句: {% case condition %} {% when 1 %} hit 1 {% when 2 or 3 %} hit 2 or 3 {% else %} ... else ... {% endcase %} Example: {% case template %} {% when 'label' %} // {{ label.title }} {% when 'product' %} // {{ product.vendor | link_to_vendor }} / {{ product.title }} {% else %} // {{page_title}} {% endcase %} 5. Cycle 我们常常需要在不同的颜色或类似的任务间轮流切换。Liquid 对于这样的操作有内置支持，通过使用 cicle``` 标签。 {% cycle 'one', 'two', 'three' %} {% cycle 'one', 'two', 'three' %} {% cycle 'one', 'two', 'three' %} {% cycle 'one', 'two', 'three' %} will result in one two three one 如果一组 cycle 没有命名，那默认情况下有用相同参数的会被认为是一个组。如果你希望完全控制 cycle 组，你可以指定一个组名，这个组名甚至可以是一个变量。 {% cycle 'group 1': 'one', 'two', 'three' %} {% cycle 'group 1': 'one', 'two', 'three' %} {% cycle 'group 2': 'one', 'two', 'three' %} {% cycle 'group 2': 'one', 'two', 'three' %} will result in one two one two 6. for 循环 Liquid 允许循环一个集合 : {% for item in array %} {{ item }} {% endfor %} 在每次循环期间，下列的帮助变量都可用于额外的展示需要: forloop.length # =&gt; length of the entire for loop forloop.index # =&gt; index of the current iteration forloop.index0 # =&gt; index of the current iteration (zero based) forloop.rindex # =&gt; how many items are still left? forloop.rindex0 # =&gt; how many items are still left? (zero based) forloop.first # =&gt; is this the first iteration? forloop.last # =&gt; is this the last iteration? 你可以使用一些属性来影响接受循环中的哪项。 limit:int 使你可以限制接受的循环项个数；offset:int 可以可以让你从循环集合的第 n 项开始。 # array = \\[1,2,3,4,5,6\\] {% for item in array limit:2 offset:2 %} {{ item }} {% endfor %} # results in 3,4 反转循环: {% for item in collection reversed %} {{item}} {% endfor %} 除了对一个已经存在的集合进行循环，你还可以定义一段范围区域内的数字进行循环。这段区域既可以通过文字也可以通过变量数定义得到: # if item.quantity is 4... {% for i in (1..item.quantity) %} {{ i }} {% endfor %} # results in 1,2,3,4 7. Variable Assignment(变量赋值) 你可以把数据存储在你自己定义的变量中，以便在输出或者其他标签中使用。创建一个变量的最简单方式是使用 assign 标签，其语法也是简单明了的： {% assign name = 'freestyle' %} {% for t in collections.tags %} {% if t == name %} Freestyle! {% endif %} {% endfor %} 另一种常见用法是把 true/false 值赋给变量: {% assign freestyle = false %} {% for t in collections.tags %} {% if t == 'freestyle' %} {% assign freestyle = true %} {% endif %} {% endfor %} {% if freestyle %} Freestyle! {% endif %} 如果你希望把一系列字符串连接为一个字符串，并将其存储到变量中，你可以使用 capture 标签。这个标签是一个块级标签，它会 captures 任何在其中渲染的元素，并把捕获的值赋给给定的变量，而不是把这些值渲染在页面中。 {% capture attribute_name %}{{ item.title | handleize }}-{{ i }}-color{% endcapture %} &lt;label for=\"{{ attribute_name }}\"&gt;Color:&lt;/label&gt; &lt;select name=\"attributes[{{ attribute_name }}]\" id=\"{{ attribute_name }}\"&gt; &lt;option value=\"red\"&gt;Red&lt;/option&gt; &lt;option value=\"green\"&gt;Green&lt;/option&gt; &lt;option value=\"blue\"&gt;Blue&lt;/option&gt; &lt;/select&gt;","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://doubleray.top/tags/Jekyll/"}]},{"title":"Jekyll 插件（持续更新···）","slug":"article-jekyll-plug-ins","date":"2017-01-10T02:25:15.000Z","updated":"2021-06-24T04:02:41.961Z","comments":true,"path":"2017/01/10/article-jekyll-plug-ins/","link":"","permalink":"https://doubleray.top/2017/01/10/article-jekyll-plug-ins/","excerpt":"博客的基础已经搭建完成，该优化的也优化了，现在本该可以安安静静的写东西了，但谁让我是一个折腾起来停不下来的小菜鸟，看着静悄悄的博客，总感觉缺少的太多的，开始从网上撸各种 jekyll 的插件让自己的页面变得丰富起来。 评论功能 和 目录 已经在模板中躺着了，再次感谢 @Freud, Kang 的 LessOrMore！本文旨在记录一下本博客中使用的 jekyll 插件 ··· ···","text":"博客的基础已经搭建完成，该优化的也优化了，现在本该可以安安静静的写东西了，但谁让我是一个折腾起来停不下来的小菜鸟，看着静悄悄的博客，总感觉缺少的太多的，开始从网上撸各种 jekyll 的插件让自己的页面变得丰富起来。 评论功能 和 目录 已经在模板中躺着了，再次感谢 @Freud, Kang 的 LessOrMore！本文旨在记录一下本博客中使用的 jekyll 插件 ··· ··· 1. 站内搜索 首先第一个想到的就是得有一个站内搜索的功能，终于被我发现了一个 JavaScript 库，可用于向 Jekyll 博客添加搜索功能。 这个 js 库的使用也是非常简单，步骤如下 首先在自己的项目中引入 jekyll-search.js 在项目根目录下新建 search.json，该文件的数据参考 这里，如果设置全文搜索可参考 这里； 在相关的 html 中加入如下代码，并自行编写 css； 12345&lt;!-- Html Elements for Search --&gt;&lt;div id=\"search-container\"&gt; &lt;input type=\"text\" id=\"search-input\" placeholder=\"search...\"&gt; &lt;ul id=\"results-container\"&gt;&lt;/ul&gt;&lt;/div&gt; 在项目的 js 文件中加入如下配置： 12345678910SimpleJekyllSearch(&#123; searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search.json', searchResultTemplate: '&lt;li&gt;&lt;a href=\"&#123;url&#125;\"&gt;&#123;title&#125;&lt;/a&gt;&lt;/li&gt;', noResultsText: '', limit: 6, fuzzy: true, exclude: ['Welcome']&#125;); 一个简单的搜索框就算完成了，当然要做到完美还差的多，如有任何问题可参看 Simple-Jekyll-Search的具体说明。 2. 代码高亮 代码高亮可以说是程序员必备，无论是搭建模块，或者是产品的说明网站都是需要展示代码的，而代码的样式直接的影响了阅读效果，一个好的代码高亮插件将会有好的体验。 网上有很多的代码高亮插件的说明 QiuJuer Tinker 列举了代码高亮的几种选择，而我选择了 Jekyll 可以默认编译的 Rouge 。 首先修改 Jekyll 项目的 _config.yml 文件，修改其中的 highlighter 为： 12markdown: kramdownhighlighter: rouge 代码高亮简单的理解其实就是根据 language 编译出特定 class ，然后再通过这些类获得特定的样式，So 那么问题来了，从哪儿得到这个 css 呢？感谢 Pygments 官网的 demo 已经帮我们设计好了一些样式，从 demo 中获取 css 文件的方法一般前端人员都肯定是轻车熟路，右键查看网页源代码， head 中有一个 link 是 pygments.css， 单击这个路径出现这个文件的源码，就可以 Ctrl + A - C - V 一气呵成了。 在自己的项目下引用这个 pygments.css 文件，然后重启 Jekyll 服务。 接下来就是怎么在 Markdown 里面书写了，基本格式就是这样： {% highlight ruby %} def show @widget = Widget(params[:id]) respond_to do |format| format.html # show.html.erb format.json { render json: @widget } end end #本段代码的作用其实就是ruby编译markdown上的代码生成html {% endhighlight %} -------或者-------- 12345678def show @widget = Widget(params[:id]) respond_to do |format| format.html # show.html.erb format.json &#123; render json: @widget &#125; end end #本段代码的作用其实就是ruby编译markdown上的代码生成html 编译后的结果就是这个样子滴： {% highlight ruby %} def show @widget = Widget(params[:id]) respond_to do |format| format.html # show.html.erb format.json { render json: @widget } end end #本段代码的作用其实就是ruby编译markdown上的代码生成html {% endhighlight %} highlight 后的 “ruby”（` 后的 “ruby” ）就是告诉编译器这段代码是什么 language，rouge 大概支持60多种语言，具体查阅rouge-support。 3. paginate 分页 首先推荐参考 白召策的博客 比较详细的写了基本的分页功能以及自定义的分页插件。 在 Jekyll 3 中，需要在 gems 中安装 jekyll-paginate 插件，并添加到 _config.yml 中，然后在 _config.yml 里边开启分页功能，格式如下： 123paginate:5paginate_path: \"page:num\"gems: [jekyll-paginate] 博客在 username..github.io 目录下的话，在其根目录的 index.html 下（Jekyll 的分页功能不支持 Jekyll site 中的 Markdown 或 Textile 文件。分页功能从名为 index.html 的 HTML 文件中被调用时，才能工作）添加如下代码： 12345678910111213141516171819202122232425&lt;!--遍历分页后的文章--&gt;&#123;% for post in paginator.posts %&#125; &lt;h1&gt;&lt;a href=\"&#123;&#123; post.url &#125;&#125;\"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;&lt;/h1&gt; &lt;p class=\"author\"&gt; &lt;span class=\"date\"&gt;&#123;&#123; post.date &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;div class=\"content\"&gt; &#123;&#123; post.content &#125;&#125; &lt;/div&gt;&#123;% endfor %&#125;&lt;!-- 分页链接 --&gt;&lt;div class=\"pagination\"&gt; &#123;% if paginator.previous_page %&#125; &lt;a href=\"/page&#123;&#123; paginator.previous_page &#125;&#125;\" class=\"previous\"&gt;Previous&lt;/a&gt; &#123;% else %&#125; &lt;span class=\"previous\"&gt;Previous&lt;/span&gt; &#123;% endif %&#125; &lt;span class=\"page_number \"&gt;Page: &#123;&#123; paginator.page &#125;&#125; of &#123;&#123; paginator.total_pages &#125;&#125;&lt;/span&gt; &#123;% if paginator.next_page %&#125; &lt;a href=\"/page&#123;&#123; paginator.next_page &#125;&#125;\" class=\"next\"&gt;Next&lt;/a&gt; &#123;% else %&#125; &lt;span class=\"next \"&gt;Next&lt;/span&gt; &#123;% endif %&#125;&lt;/div&gt; 个人觉得逻辑更好的分页在 bicky.me，本博客就是参考的这个。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://doubleray.top/tags/Jekyll/"}]},{"title":"Markdown 实用技巧","slug":"article-markdown-skills","date":"2017-01-09T11:19:15.000Z","updated":"2021-06-24T04:02:41.973Z","comments":true,"path":"2017/01/09/article-markdown-skills/","link":"","permalink":"https://doubleray.top/2017/01/09/article-markdown-skills/","excerpt":"最开始接触了解 Markdown 是在 github 中写 README.md ，Markdown 的目标是实现「易读易写」，其语法格式最大灵感来源其实是纯文本电子邮件的格式，因此 Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。 Markdown 语法说明 (简体中文版) 有对 Markdown 的比较完整的介绍，本文旨在总结一些实用的小技巧。","text":"最开始接触了解 Markdown 是在 github 中写 README.md ，Markdown 的目标是实现「易读易写」，其语法格式最大灵感来源其实是纯文本电子邮件的格式，因此 Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。 Markdown 语法说明 (简体中文版) 有对 Markdown 的比较完整的介绍，本文旨在总结一些实用的小技巧。 1. 首行缩进 ① 在段首加入 &amp;ensp; 来输入一个空格；加入 &amp;emsp; 来输入两个空格 （注：首行缩进为四个空格）； ② 将输入法切换到 全角 状态（Shift + Space），按两下空格即可，输完后记得切换回正常输入的 半角 状态（尽量不用）。 2. 插入代码 ① 在每行代码前加入4个空格或者添加一个制表符（Tab键），其缩进是相对于当前格式状态下的，在列表项状态下，需要输入两次TAB键(制表符)才能以代码格式插入。 ② 在代码两侧添加三个反引号 ‘ ，最好在代码的前后行添加，而不是直接加在代码两边。123456789## 3. 限制图片大小并居中 MarkDown 中是直接按原图大小显示图片的，让图片大小一致且居中显示可以通过内嵌 html 代码来实现。```html&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;图片地址&quot; width=&quot;宽度&quot; height=&quot;高度&quot; alt=&quot;图片名称&quot;/&gt;&lt;/div&gt; 注意： HTML 的块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，并且开始标签与结尾标签不能用制表符或空格来缩进； HTML 的行内元素——如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用，特殊符号 的输入同 html。 4. 流程图画法 在编辑器中插入如下代码，在这之前需引入 flowchart.js ,即可生成流程图，实例可参考 Z.K.的博客。 12345678910111213st=&gt;start: Start|past:&gt;http://www.baidu.come=&gt;end: Ende|future:&gt;http://www.baidu.comop1=&gt;operation: My Operationop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yes or No|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|futurest-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://doubleray.top/tags/Markdown/"}]},{"title":"常用 git 命令行总结","slug":"article-git-skills","date":"2017-01-09T05:13:05.000Z","updated":"2021-06-24T04:02:41.958Z","comments":true,"path":"2017/01/09/article-git-skills/","link":"","permalink":"https://doubleray.top/2017/01/09/article-git-skills/","excerpt":"这些基础命令是首次使用 git 配置连接 github 时常用的命令（本人博客搭建过程中主要使用的）。","text":"这些基础命令是首次使用 git 配置连接 github 时常用的命令（本人博客搭建过程中主要使用的）。 $ ssh-keygen -t rsa -C youremail@example.com # 生成SSH Key与github连接用； $ ssh -T git@github.com # 通过连接一次到GitHub测试连接成功否； $ git clone http[s]://example.com/path/to/repo.git/， $ git clone ssh://example.com/path/to/repo.git/， # 从github上fork其他人的repo； $ git init # 初始化一个版本库（.git的隐藏文件夹）； $ git status # 查看状态； $ git push -u origin master # 第一次将本地项目push到服务器,再次push时将-u去掉； $ git commit -m &apos;first commit’ # 提交更改及描述到仓库； $ git add (u&amp;A&amp;i)[&lt;path&gt;] # 把我们要提交的文件的信息添加到索引库中; $ git remote add origin git@github.com:daixu/WebApp.git # 添加远程仓库; $ git remote rm origin # 删除远程仓库； $ git remote -v # 列出已经存在的远程分支； 以下内容参考学习 阮一峰的网络日志，转载请注明出处。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库git 新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]git 配置 Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot;git 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]git 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...git 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]git 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]git 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git refloggit 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --allgit 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop其他# 生成一个可供发布的压缩包 $ git archive","categories":[{"name":"干货分享","slug":"干货分享","permalink":"https://doubleray.top/categories/干货分享/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://doubleray.top/tags/Git/"}]},{"title":"Jekyll 博客搭建历程","slug":"article-build-blog","date":"2017-01-08T05:15:15.000Z","updated":"2021-06-24T04:02:41.954Z","comments":true,"path":"2017/01/08/article-build-blog/","link":"","permalink":"https://doubleray.top/2017/01/08/article-build-blog/","excerpt":"最近赋闲在家，想着自己也搭建一个自己的技术博客，记录分享一些技术点，说干就干，开始着手搭建感觉有点无从下手，是先写个页面？还是先找个例子学习一下？千般辗转，发现 github pages 的学习成本最低，相比其他搭建方式而言，不需要太多的服务器基础，天然基于 git 版本控制，便于对代码进行迁移，而且前一阵一直捣鼓 ruby 的一些东西，所以最终选择了 github + git + Jekyll 的搭建方案（ windows7 64bit 环境），那么开始折腾。 现用 hexo+next 搭建，极大的简化了搭建流程！","text":"最近赋闲在家，想着自己也搭建一个自己的技术博客，记录分享一些技术点，说干就干，开始着手搭建感觉有点无从下手，是先写个页面？还是先找个例子学习一下？千般辗转，发现 github pages 的学习成本最低，相比其他搭建方式而言，不需要太多的服务器基础，天然基于 git 版本控制，便于对代码进行迁移，而且前一阵一直捣鼓 ruby 的一些东西，所以最终选择了 github + git + Jekyll 的搭建方案（ windows7 64bit 环境），那么开始折腾。 现用 hexo+next 搭建，极大的简化了搭建流程！ 网上已经有很多关于这方面的教程，只是有一些教程已经过时了，比如大家可以参考 猿blog、Github建站系列教程、简书 、Pwnny’s Blog、BIGBALLON的博客 等的教程，这些融合在一起完全可以搭建一个简单的 github 博客，本文主要记录一下自己造的坑。 Github Pages 本身就可以作为一个 git 项目，其他人可以 fork 或者参与到你的博客建设中，这本身可以独立也可以互相协作，换而言之，这也是你的 contributions。 准备工作 注册一个 Github 账号 安装并简单学习 git 版本控制 学习 Markdown 语法 安装 ruby、gem、jekyll 等 学习一下 jekyll 的基本配置和简单的工作机制流程 购买一个个人域名（ B 格提升专用） 1.Github 对于Github的注册及使用可以参考 这里，我就不细表了，主要作一下补充及更新。 在 setting 页面下的 github pages 里没有了之前的 Launch automatic page generator (启动自动页面生成器) 消失了，当然 github pages 完全可以直接放在 master 下; 同git建立连接时需要的SSH在如下图的位置（当然刚建库的时候也会看到，但当时真的没有注意） ![SSH位置](/styles/images/build blog/SSH.png) 2.git 版本控制 git 在 windows 下的安装路劲是任意的，这个不用纠结； git的基本配置与命令行使用 Git - Book 的讲解的非常清楚，也可以参考我自己总结的常用 git 命令行的总结； 当命令行使用熟练后推荐通过 webstorm 进行 git 的操作，使用过程一目了然而且还非常的方便。推荐教程 简书、戴眼镜的小女孩。 3.Markdown 语法 Markdown的语法非常之简单，Markdown 语法说明 进行了详细的讲解；这里 是本人总结的写 Markdown 文本的一些小技巧。 4.域名配置 这个装X方案起初我内心是拒绝的，但后来转念一想个人博客还是有个人的域名比较好，这个过程还是遇到点的坑，网上关于 CNAME 这个东西给的解释很明确，但是通过我亲自尝试，最终的配置结果如下图 DNS配置 CNAME文件![CNAME文件](/styles/images/build blog/CNAME.png) 首先说明这个方案是成功的，这里没有设置 IP 的解析是因为亲测 IP 确实不太稳定，如果各位看官有更好的方案，欢迎留言交流讨论！ 按照我的这个配置不成功的可以看看 流风雨情的博客。 5.Jekyll 配置 关于 jekyll 的安装与配置在 Github建站系列教程 讲解的很详细，参照着做就行了，另外推荐 jekyll 介绍与使用 和 Jekyll 语法小节 ，可加深对 Jekyll 的理解，并在构建博客的过程中更加得心应手。 jekyll也有不太丰富的插件提供，满足基本需求还是够的，不过本人推荐使用一些纯 js 的类插件来达到功能需求（因为github对.rb插件不怎么友好）。 关于 RubyGems 被墙的问题，淘宝的 gems 镜像已经不再维护了，可以用 RubyGems 镜像- Ruby China ，基于国内 CDN + 国外服务器的方式，能确保几乎无延迟的同步。 6.过程总结最后对我自己的搭建过程做一下总结，基本的流程如下： 先找了一个模板，fork 到自己的 github； 将项目名称改为 github 的用户名（ usename.github.io ），这样就可以直接通过 https://usename.github.io/ 来访问 master 的页面（即博客内容）； 安装 git，在项目（ blog ）目录右键 Git Bash Here，进行 git 的基本设置（设置用户名，邮箱，生成 SSH Key 与 github 连接，设置远程仓库连接，init 本地仓库等）； 通过 git pull origin master 将 github 的内容pull到本地目录； 先通过 git add -A 将目录中的文件 tracked，然后进行 change； 1）如果没有自己的域名，目录中不能出现 CNAME 文件； 2）改 _config.yml 时 markdown: kramdown ， 如果项目名称为（usename.github.io）则 baseurl = “ “ ； Change 完了之后通过 git status 查看当前的状态，检查一下； 通过 git commit -m ‘first commit’ 将更改的东西添加到暂存区（再次提交去掉-m即可）； 最后在通过 git push origin master 将更改过的文件信息 push 到 github 上； 在这之前可以在本地通过 jekyll 先查看检查一下，配置好 jekyll 之后在 git 的当前目录下输入 jekyll build ，然后 jekyll serve ，那么现在就可以通过 localhost：4000 来访问到更改后的本地页面了。 OK 到了这里，就可以踏踏实实的来专注自己的博文了。 结语 本文大部分的技术点都在相关的推荐文档里，因为我可能和正在看本文的您一样也是第一次搭建 github 的博客，所以大部分知识都是从前辈总结的经验和官方的文档中得来的，只是自己通过实践来发现更适合自己的方法方式。","categories":[{"name":"实践之路","slug":"实践之路","permalink":"https://doubleray.top/categories/实践之路/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://doubleray.top/tags/Jekyll/"},{"name":"Github","slug":"Github","permalink":"https://doubleray.top/tags/Github/"},{"name":"Markdown","slug":"Markdown","permalink":"https://doubleray.top/tags/Markdown/"}]}]}